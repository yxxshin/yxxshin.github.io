{"pages":[{"title":"About Me","text":"Yeonsang Shin Student Developer, interested in AI/ML at Seoul, South Korea My Resume Education Seoul National University, Bachelor of Electrical and Computer EngineeringMar 2019 ~ Present Seoul Science High SchoolMar 2016 ~ Feb 2019 Experiences Deep Learning Engineer(Part-time) at Theta OneNov 2022 ~ Jan 2023 Associate member of NAEK YEHSJan 2023 ~ Present Microwave Systems Operator-Maintainer at Republic of Korea Defense Communication Command (Military Service)Aug 2021 ~ Feb 2023 Software Developer Intern at DesiloApr 2021 ~ Jul 2021 Scholarship student of Presidential Science Scholarship (대통령과학장학금)Jan 2019 ~ Present Email samshin3910 [at] gmail [dot] com samshin3910 [at] snu [dot] ac [dot] kr","link":"/about/index.html"}],"posts":[{"title":"Sorting Algorithm - O(N^2)","text":"시간복잡도가 O(n^2) 인 정렬에는 선택정렬, 삽입정렬, 버블정렬 등이 있다. 참고) 아래의 정렬 구현 시에는 다음과 같은 매크로를 사용하였다.#define SWAP(x,y,temp) ( (temp)=(x), (x)=(y), (y)=(temp) ) 1. 선택 정렬 (Selection Sort)123456789101112131415void selection_sort(int list[], int n) { int i, j, min, temp; //마지막 숫자는 자동 정렬이므로 n-1번 반복 for(i=0; i&lt;n-1; i++) { min = i; //최솟값 탐색 for(j=i+1; j&lt;n; j++) { if(list[j]&lt;list[min]) min = j; } if(i != min) SWAP(list[i],list[min],temp); }} 전체 배열에서 최솟값을 찾고, 가장 앞의 숫자와 바꾼다.그 다음 숫자는 두 번째로 작은 숫자와 바꾼다. 2. 삽입 정렬 (Insertion Sort)123456789101112void insertion_sort(int list[], int n) { int i, j, key; for(i=1; i&lt;n; i++) { key = list[i]; // 삽입될 숫자(i번째 정수)를 key 변수로 복사 // 현재 정렬된 배열은 i-1 까지이므로 i-1부터 역순으로 조사한다 // key 보다 정렬된 배열에 있는 값이 크면 j번째를 j+1번째로 이동 for(j=i-1; j&gt;=0 &amp;&amp; list[j]&gt;key; j--) { list[j+1] = list[j]; } list[j+1] = key; }} 두 번째 숫자는 첫 번째 숫자와 비교한다.세 번째 숫자는 앞의 두 숫자와 비교하여, 자리에 맞게 정렬한다. 단, 자신의 바로 앞 숫자부터 앞으로 가면서 비교한다.오름차순 정렬의 경우, 자신(key)보다 숫자가 크다면 그 숫자를 한 칸 뒤로 보내고, 자신(key)는 앞으로 한 칸씩 옮긴다. 자신(key)보다 숫자가 작이지는 순간 그 자리에 key를 삽입한다. 3. 버블 정렬 (Bubble Sort)123456789void bubble_sort(int list[], int n){ int i, j, temp; for(i=n-1; i&gt;0; i--) { for(j=0; j&lt;i; j++) { if(list[j+1]&lt;list[j]) SWAP(list[j+1],list[j],temp); } }} 인접한 두 개씩을 비교하여 정렬하는 방식이다.오름차순 정렬의 경우, 1회전을 하면 가장 큰 숫자가 맨 뒤로 가게 된다.한 회전을 할 때마다 뒤에 (알맞게 정렬된) 숫자를 하나씩 쌓는다.","link":"/2020/03/06/2020-03-06-Sorting-Algorithm-O(N%5E2)/"},{"title":"Baekjoon 10989 (수 정렬하기 3)","text":"Baekjoon 10989, 백준 10989 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제 보기1234567891011121314151617181920212223#include &lt;stdio.h&gt;#define MAX_NUM 10000int main() { int N; scanf(&quot;%d&quot;,&amp;N); int temp, count[MAX_NUM+1]={0,}; // 숫자 입력받고 count 배열 만들기 for(int i=0; i&lt;N; i++) { scanf(&quot;%d&quot;,&amp;temp); count[temp]++; } // 차례대로 출력 for(int i=0; i&lt;MAX_NUM+1; i++) { while(count[i]) { printf(&quot;%d\\n&quot;,i); count[i]--; } }}개수가 10,000,000인 배열을 선언할 수 없으므로(메모리 부족)일반적으로 사용하는 ‘누적합’ 방식을 사용할 수 없었다.그냥 count 배열에 입력하고 바로 출력하였다.","link":"/2020/03/13/2020-03-13-Baekjoon-10989/"},{"title":"Baekjoon 2751 (수 정렬하기 2)","text":"Baekjoon 2751, 백준 2751 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제 보기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#define MAX_ELEMENT 1000010typedef struct { int heap[MAX_ELEMENT]; int heap_size;} HeapType;// 현재 요소의 개수가 heap_size인 힙 h에 data을 삽입한다.void insert_heap(HeapType *h, int data) { int i; i = ++(h-&gt;heap_size); // 힙 크기를 하나 증가 // 트리를 거슬러 올라 가며 부모 노드와 비교하는 과정 // i가 루트 노드가 아니고,data 값이 부모노드(i/2)보다 작으면 while( (i!=1) &amp;&amp; (data &lt; h-&gt;heap[i/2])) { h-&gt;heap[i] = h-&gt;heap[i/2]; i /= 2; } h-&gt;heap[i] = data;}int delete_heap(HeapType *h) { if(h-&gt;heap_size == 0) return -1; int ret = h-&gt;heap[1]; int temp = h-&gt;heap[(h-&gt;heap_size)--]; // 마지막 노드를 temp에 담고 heap_size를 1 줄임. int parent = 1, child = 2; while(child &lt;= h-&gt;heap_size) { // 현재 노드의 자식 노드 중 더 작은 자식 노드를 찾는다. if( child &lt; h-&gt;heap_size &amp;&amp; h-&gt;heap[child] &gt; h-&gt;heap[child+1] ) child++; // 더 작은 자식 노드보다 마지막 노드가 작으면 while문 정지 if( temp &lt;= h-&gt;heap[child] ) break; // 그렇지 않으면, 부모 노드와 작은 자식 노드 교환 h-&gt;heap[parent] = h-&gt;heap[child]; parent = child; child *= 2; } h-&gt;heap[parent] = temp; return ret;}int main() { int N, data; scanf(&quot;%d&quot;,&amp;N); HeapType heap1; heap1.heap_size = 0; for(int i=0; i&lt;N; i++){ scanf(&quot;%d&quot;,&amp;data); insert_heap(&amp;heap1,data); } for(int i=0; i&lt;N; i++) { printf(&quot;%d\\n&quot;, delete_heap(&amp;heap1)); }}quick sort 등의 간편한 함수를 사용하지 않고, 직접 heap sort를 구현해 보았다.while 문 내부의 if 문 조건이 하나 틀어져서 오류 찾는데 엄청 오래 걸렸다.","link":"/2020/03/13/2020-03-13-Baekjoon-2751/"},{"title":"Backtracking - Queen Problem","text":"백트래킹(Backtracking)은 문제에서 주어지는 한정된 조건을 만족하는 해를 구할 때 사용하는 알고리즘이다. 문제에서 가능한 모든 해 집합을 대입하면, 당연히 만족하는 해를 찾을 수 있다. 여기서, 백트래킹을 이용하면 시간을 크게 단축시킬 수 있다. 쉽게 말하자면 다음과 같다: 노드의 유망성을 확인한 후, 유망하지 않으면 그 노드의 부모 노드로 돌아간다. 즉, 유망하지 않은 노드는 배제한다. 노드가 ‘유망하다’는 것은 문제의 조건을 (아직까지는) 만족한다는 뜻이다. 이러한 논리를 가장 쉽게 이해할 수 있는 대표적인 문제는 Queen Problem이다. Queen Problem은 N*N 체스판에 N개의 Queen을 놓는데, 각각의 Queen이 서로를 위협시키지 않도록 위치시키는 문제이다. 위와 같이 N개의 Queen을 놓을 수 있는 방법의 수를 구해야 한다고 하자. 백트래킹을 사용하여 다음과 같이 문제를 해결할 수 있다. 우선, 각 행에 한 개의 Queen이 있어야 한다는 점은 명백하다. 따라서, 우리는 체스판을 1차원 배열로 표현할 것이다. 배열 chess[N]을 놓고, i 행 j 열에 Queen이 놓인다면 chess[i] = j 와 같이 표현한다. 이렇게 놓음과 동시에 우리는 한 행에 두 개의 Queen이 놓이는 경우를 모두 제외하였다. 남은 두 조건은 같은 열과 대각선에 Queen이 놓이지 않는 것이다. 같은 열에 놓이지 않는 것은 모든 a, b에 대해 chess[a] != chess[b] 이면 되며, 같은 대각선에 놓이지 않는 것은 i와 j의 차를 이용하여 구할 수 있다. (chess[i]와 chess[j]의 차와, i와 j의 차가 달라야 한다!) 이제 문제의 조건을 모두 (코드로) 구현하였다. 남은 것은 모든 해집합에서 위 조건을 모두 만족시키는 경우를 모두 찾는 것이다. 여기서 백트래킹을 사용한다. 첫 번째 행(chess[0])부터 시작하여, i 번째행을 i번째 깊이로 생각한다. chess[0]의 값을 정한다. chess[0] = 0 이 된 첫 번째 상황을 생각하자. Queen을 처음 한 개 놓았으므로 어긋나는 조건이 없다. 다음, chess[1]의 값을 정한다. chess[1] = 0 이라면, 조건에 어긋난다. ( 한 열에 두 개의 Queen이 놓임) 따라서 chess[1] = 0 인 노드는 “유망하지 않은 노드”가 되는 것이다. 이미 조건을 만족시키지 못하기 때문이다. 이 경우 백트래킹을 통해, 아래의 노드들은 확인할 필요도 없이 다음 노드로 넘어간다. chess[1] = 1 인 경우이다. 이 경우도 조건을 만족하지 않으므로 (대각선에 두 개의 Queen이 놓임), chess[1] = 2 인 경우로 바로 넘어간다. 이 노드는 조건을 만족하는 “유망한 노드”이다. 따라서 다음 level로 넘어가 chess[2] 의 값을 정해준다…. 위와 같은 방법으로 ‘노드의 유망성’을 판단하여 유망하지 않다면 바로 스킵하는 전략이 백트래킹이다. 모든 경우의 수를 확인하는 DFS와 비해 시간이 훨씬 절약되는 것을 느낄 수 있을 것이다. 완성된 코드는 여기 에서 확인할 수 있다. (백준 9663)","link":"/2020/03/20/2020-03-20-Backtracking-Queen-Problem/"},{"title":"Sorting Algorithm - O(NlogN)","text":"시간 복잡도가 O(n^2)인 정렬은 간단하다는 장점이 있으나, 시간이 오래 걸린다는 단점을 피해갈 수 없다. 따라서 시간을 단축시키기 위해서는 시간 복잡도가 O(nlogn)인 정렬을 사용해야 한다. 본 글에서는 시간 복잡도가 O(nlogn)인 정렬로 힙 정렬, 합병 정렬을 소개한다. 1. 힙 정렬 (Heap Sort)‘힙(Heap)’은 완전 이진 트리의 일종이다. 최대 힙(max heap)과 최소 힙(min heap)이 있는데, 각각은 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은(작거나 같은) 힙을 의미한다. 힙은 표준적으로 배열을 이용하여 저장한다(사진 참고). 쉬운 구현을 위해 index 0을 사용하지 않으며 (즉, 1부터 시작), index들은 다음과 같은 관계를 가진다. 왼쪽 자식의 index = (부모의 index) * 2 오른쪽 자식의 index = (부모의 index) * 2 + 1 부모의 index = (자식의 index) / 2 다음과 같이 구조체를 이용하여 표현해 볼 수 있다.1234typedef struct { int heap[MAX_ELEMENT]; int heap_size;} HeapType; 이제, 최소 힙의 구현을 생각해 보자. (위의 그림은 최대 힙임)우선, 힙을 추가하는 경우(숫자를 대입하여 정렬하는 경우)를 생각한다. 힙이 추가되면, 우선 가장 마지막 index에 대입한다. 이후, 부모 노드와 비교하면서 부모 노드가 본인보다 작을 때까지 부모 노드와 자신을 교환한다. 12345678910111213// 현재 요소의 개수가 heap_size인 힙 h에 data을 삽입한다.void insert_heap(HeapType *h, int data) { int i; i = ++(h-&gt;heap_size); // 힙 크기를 하나 증가 // 트리를 거슬러 올라 가며 부모 노드와 비교하는 과정 // i가 루트 노드가 아니고,data 값이 부모노드(i/2)보다 작으면 while( (i!=1) &amp;&amp; (data &lt; h-&gt;heap[i/2])) { h-&gt;heap[i] = h-&gt;heap[i/2]; i /= 2; } h-&gt;heap[i] = data;} 다음으로, 최소 힙(가장 작은 숫자)을 삭제하는 경우(숫자를 빼내는 경우. 마지막 출력할 때)를 생각한다.최소 힙을 삭제하고, 가장 마지막 index의 힙을 그 자리(맨 위)로 올린다.이후, 힙의 성격에 맞게 정렬을 한다. 단, 주의할 점은 두 자식노드를 비교하여 정렬해야 한다는 점이다. 예로 최소 힙의 경우에는 두 자식 중 더 작은 자식 노드와 교환해야 한다. 12345678910111213141516171819202122232425int delete_heap(HeapType *h) { if(h-&gt;heap_size == 0) return -1; int ret = h-&gt;heap[1]; int temp = h-&gt;heap[(h-&gt;heap_size)--]; // 마지막 노드를 temp에 담고 heap_size를 1 줄임. int parent = 1, child = 2; while(child &lt;= h-&gt;heap_size) { // 현재 노드의 자식 노드 중 더 작은 자식 노드를 찾는다. if( child &lt; h-&gt;heap_size &amp;&amp; h-&gt;heap[child] &gt; h-&gt;heap[child+1] ) child++; // 더 작은 자식 노드보다 마지막 노드가 작으면 while문 정지 if( temp &lt;= h-&gt;heap[child] ) break; // 그렇지 않으면, 부모 노드와 작은 자식 노드 교환 h-&gt;heap[parent] = h-&gt;heap[child]; parent = child; child *= 2; } h-&gt;heap[parent] = temp; return ret;} 우리는 힙의 삽입, 삭제를 이용하여 힙 정렬을 할 수 있다.완성된 전체 코드는 다음과 같다. (백준 2751 수 정렬하기(2))1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#define MAX_ELEMENT 1000010typedef struct { int heap[MAX_ELEMENT]; int heap_size;} HeapType;// 현재 요소의 개수가 heap_size인 힙 h에 data을 삽입한다.void insert_heap(HeapType *h, int data) { int i; i = ++(h-&gt;heap_size); // 힙 크기를 하나 증가 // 트리를 거슬러 올라 가며 부모 노드와 비교하는 과정 // i가 루트 노드가 아니고,data 값이 부모노드(i/2)보다 작으면 while( (i!=1) &amp;&amp; (data &lt; h-&gt;heap[i/2])) { h-&gt;heap[i] = h-&gt;heap[i/2]; i /= 2; } h-&gt;heap[i] = data;}int delete_heap(HeapType *h) { if(h-&gt;heap_size == 0) return -1; int ret = h-&gt;heap[1]; int temp = h-&gt;heap[(h-&gt;heap_size)--]; // 마지막 노드를 temp에 담고 heap_size를 1 줄임. int parent = 1, child = 2; while(child &lt;= h-&gt;heap_size) { // 현재 노드의 자식 노드 중 더 작은 자식 노드를 찾는다. if( child &lt; h-&gt;heap_size &amp;&amp; h-&gt;heap[child] &gt; h-&gt;heap[child+1] ) child++; // 더 작은 자식 노드보다 마지막 노드가 작으면 while문 정지 if( temp &lt;= h-&gt;heap[child] ) break; // 그렇지 않으면, 부모 노드와 작은 자식 노드 교환 h-&gt;heap[parent] = h-&gt;heap[child]; parent = child; child *= 2; } h-&gt;heap[parent] = temp; return ret;}int main() { int N, data; scanf(&quot;%d&quot;,&amp;N); HeapType heap1; heap1.heap_size = 0; for(int i=0; i&lt;N; i++){ scanf(&quot;%d&quot;,&amp;data); insert_heap(&amp;heap1,data); } for(int i=0; i&lt;N; i++) { printf(&quot;%d\\n&quot;, delete_heap(&amp;heap1)); }}힙 정렬의 시간 복잡도는 다음과 같이 구할 수 있다:힙 트리의 높이는 logn, 따라서 한 힙을 삽입할 때 걸리는 시간 logn,총 n개의 힙을 삽입할 때 걸리는 총 시간은 nlogn.또한, 힙 정렬은 안정 정렬(기존의 순서가 정렬 후에도 유지)이라는 성질이 있다. 2. 합병 정렬 (Merge Sort)합병 정렬은 폰 노이만(Von Neumann)이 제안한 방법이며, 분할 정복 알고리즘의 하나이다.분할 정복(Divide and Conquer)은 문제를 분리하여 각각을 해결한 다음, 결과를 모아 원래 문제를 해결하는 전략이다. 따라서 합병 정렬은 분할 &gt; 정복 &gt; 결합 의 순서로 이루어진다.분할 단계에서는 입력 받은 배열을 크기가 같은 두 개의 부분 배열로 분할한다.정복 단계에서는 각각의 부분 배열을 정렬한다. 부분 배열의 크기가 2보다 크다면 재귀 호출을 통해 그 부분 배열에서의 분할 단계로 넘어간다.결합 단계에서는 정렬이 끝난 부분 배열들을 하나의 배열로 합친다. 합병 정렬의 시간 복잡도는 다음과 같이 구할 수 있다:합병 단계 수 logn, 비교 연산은 각 정렬 단계(혹은 크기 2인 부분 배열)에서 최대 n번,따라서 총 nlogn의 시간 복잡도를 가진다.","link":"/2020/03/13/2020-03-13-Sorting-Algorithm-O(NlogN)/"},{"title":"Baekjoon 15650 (N과 M(2))","text":"Baekjoon 15650, 백준 15650 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제 보기12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;int N, M;int arr[10];bool check[10]; // 기본이 false(0)이다// count가 뽑은 갯수, current가 시작점 (current 이상의 수들로만 수열이 구성되어야 함)void pick(int count, int current) { if(count==M) { // M개 숫자를 모두 뽑음 for(int i=0; i&lt;M; i++) printf(&quot;%d &quot;, arr[i]); // 모두 출력 printf(&quot;\\n&quot;); return; } for(int i=current; i&lt;=N; i++){ if(!check[i]){ check[i] = true; arr[count] = i; // i번 숫자를 뽑음 pick(count+1,i+1); // pick 재귀호출, 다음 깊이(숫자)로 들어감 check[i] = false; } }}int main(){ scanf(&quot;%d %d&quot;,&amp;N, &amp;M); pick(0,1); return 0;}Backtracking의 기본적인 형태이다.코드를 살짝 변형하면 N과 M 시리즈 1~4를 모두 해결할 수 있었다.","link":"/2020/03/20/2020-03-20-Baekjoon-15650/"},{"title":"Baekjoon 9663 (N-Queen)","text":"Baekjoon 9663, 백준 9663 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제 보기123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;int result=0, N;// 체스판 구현. i번째 행의 퀸의 위치를 chess[i]int chess[15];// chess[i], chess[j]가 같은 대각선/열에 놓이면 false를 배출bool isOkay(int line){ for(int i=1; i&lt;line; i++) { if(chess[i]==chess[line] || abs(chess[line]-chess[i]) == line-i) return false; } return true;} // 뽑아야 하는 줄을 line에 입력void QueenNum(int line){ if(line==N+1) { result++; return; } for(int i=1; i&lt;=N; i++) { chess[line] = i; if(isOkay(line)) QueenNum(line+1); }}int main(void) { scanf(&quot;%d&quot;,&amp;N); QueenNum(1); printf(&quot;%d&quot;,result);}Backtracking을 이용한 첫 번째 문제였다.chess판을 1차원 배열로 생각하였고, 대각선에 놓이는 것을 뺄셈을 이용해 해결하였다.","link":"/2020/03/20/2020-03-20-Baekjoon-9663/"},{"title":"VIM shortcuts - Linux with iPad","text":"아이패드의 베타버전 개발자 앱 iSH를 이용하여리눅스 프로그래밍을 할 수 있다는 사실을 배움. C 프로그래밍을 위하여 VI Editor를 사용하였고,아래와 같이 단축어를 정리함. 파일 실행: vi project.c파일 컴파일: gcc project.c -o project 하면 project 라는 이름으로 exe 파일이 생긴다exe 실행: ./project vi 로 처음 열면 명령모드 명령모드 단축어i 입력모드로 변경o 커서 다음줄에 빈줄 추가 + 입력모드 변경O 커서 이전줄에 빈줄 추가 + 입력모드 변경 :w 저장:wq 저장 후 종료:q! 저장하지 않고 종료:q 나가기 화살표로 커서 이동 u 한 단계 되돌리기 (컨트롤z) x 커서 위치 글자 삭제X 커서 앞 글자 삭제 (backspace) dd 커서 위치 줄 삭제 yy 커서 위치의 줄을 버퍼로 복사p 버퍼의 내용을 커서 다음 줄에 삽입P 버퍼의 내용을 커서 이전 줄에 삽입 r 글자 입력 시 해당위치 글자가 치환됨 /단어 그 단어가 있는 위치로 커서 이동n 다음 일치 항목N 이전 일치 항목 :%s/hello/goodbye/ig hello를 찾아서 goodbye로 변경i : 대소문자 구분 안함g : 줄 내 모두 변경","link":"/2020/03/25/2020-03-25-VI/"},{"title":"Linux Study (19.08.19 ~ 19.08.29)","text":"러시아 여행 도중, 시베리아 횡단열차에서 공부하고, 요약한 내용.유튜브 생활코딩의 리눅스 강좌를 시청하였음. Linux - file &amp; directory 1ls -al : 현재 디렉토리의 파일들을 보여줌. (list) 문자를 입력해 명령을 한다 &gt; GUI 방식이 아님. (CLI, Command Line Interface) 명령은 현재 머무르고 있는 디렉토리를 대상으로 내려진다 어떤 디렉토리에 머무르고 있는지 확인해야 함 pwd : 현재 있는 디렉토리 위치mkdir hello_linux : hello_linux 디렉토리를 만든다touch empty_file.txt : 빈 txt 파일을 만든다ls -l : 좀 더 자세히 파일들을 보여줌ls dir1 : dir1의 파일들을 보여줌명령어 뒤의 (-) 와 함께 붙는 것을 파라미터 라고 함 Linux - file &amp; directory 2cd hello : hello 디렉토리로 들어감. (change directory)tab 키를 통해 자동완성부모 디렉토리로 들어가는 방법: /Users 부터 다시 치기 (절대 경로) cd .. (상대 경로)..의 의미: 부모 디렉토리 rm file.txt : file 을 삭제함 (remove)-&gt; 디렉토리는 삭제가 되지 않는다디렉토리 삭제할 때에는 rm -r 으로 해야 함.-help: 명령어 도움말clear : 내용 지우기 Linux - -help &amp; manman: 매뉴얼을 보여줌. 전용 페이지 (man mkdir)화면에서 /sort : sort 단어 검색. n 키 누르면 페이지 변환q 누르면 화면 빠져 나옴-help: 화면 빠져나가지 않고 간단하게mkdir -p : 여러 단계 디렉토리 생성 (dir1/dir2/dir3/dir4…)숨김파일 앞에는 . 이 붙는다 Linux - Searchingex) create directory in linux 구글에 검색cp cp.txt dir1/cp.txt : cp.txt를 dir1 밑에 복사mv hello.txt dir1/hello.txt : hello.txt를 dir1로 이동이름 바꾸기: mv a.txt b.txt : a.txt를 b.txt로 이름 바꿈 Linux - 명령의 빈도수Linux - sudosudo (super user do) : 슈퍼 유저의 권한이 필요할 때 사용그 명령어만 슈퍼 유저의 권한으로 실행 Linux - file edit (nano)nano : 파일 편집기^ 는 control 키를 의미함nano hello.html : 파일 열어 편집Kut, Unkut 기능 활용 (복붙시에도)^W : 찾기 기능 Linux - package managerapt, yum 이 대표적인 package managersudo apt -get update: 최신 목록으로 updatesudo apt -cache search htop : htop 관련으로 검색(top: 작업관리자)sudo apt -get install htop : htop 앱 설치sudo apt -get upgrade : 앱 업그레이드sudo apt -get remove htop : htop 앱 삭제 Linux - file download: wgetwget (주소) : 다운로드 됨-help 이용해서 용법 확인할 것 Linux - Source download: gitgithub 사이트: 많은 오픈소스의 저장소오픈소스의 url 복사한 후, git clone (주소) react_src : react_src의 디렉토리 아래에 다운로드 됨 Linux - Why using CLI? 1 - GUI vs CLICLI가 훨씬 적은 에너지로 동작 가능GUI는 노동을 필요로 함. (기다려야 함)CLI는 자동화가 가능 Linux - Why using CLI? -sequence execution (semicolon)mkdir why ; cd why — ; 를 사용하면 차례차례 할 수 있음. (여러 개의 명령 한 번에 가능) Linux - Why using CLI? (pipeline)cat linux.txt : linux.txt의 내용을 화면에 출력grap lin linux.txt : linux.txt에서 lin 이 포함된 행을 찾아줌ls —help | grap sort : ls —help 를 입력해주는 역할 (앞의 출력을 뒤에 입력, 프로그램 연결)ex) ls —help | grap sort | grap fileps : 프로세스ps aux : 현재 실행되고 있는 프로그램 Linux - IO Redirection 1 : outputls -l &gt; result.txt : ls -l의 결과를 result.txt에 저장함( 1&gt; : 표준출력 )error는 표준출력이 아니기 때문에,rm rename.txt 2&gt; error.log 와 같이 redirection 가능 (에러의 redirection) Linux - IO Redirection 2 : inputcat 만 치면, 사용자가 입력하는 정보를 받는다ex) cat &lt; hello.txtcat hello.txt 와의 차이? 표준 입력으로 받냐 / 인자로 받냐 의 차이head : 앞부분만 출력해줌head -n1 linux.txt : linux.txt의 첫째 줄만 출력ex) head -n1 &lt; linux.txt &gt; one.txt Linux - IO Redirection 3 : appendls -al &gt;&gt; result.txt : 뒤에 추가가 됨. (append)ls -al &gt; /dev/null : 출력도 X, 파일 저장도 X Linux - Shell 1: introhardware ) kernel ) shellkernel: 하드웨어를 직접적으로 제어하는 코어shell: 사용자shell에 명령 입력 -&gt; 해석해서 kernel에게 전달 -&gt; kernel이 hardware 제어 -&gt; 처리해서 kernel에게 전달 -&gt; shell에게 전달 Linux - Shell 2: bash vs zshecho “hello” : 한 번 더 출력해줌echo $0 : shell이 뭔지 알려줌 (bash / zsh) Linux - Shell script 1 : intro.log : 제외한 부분이 공통 부분인 모든 파일을 의미함ex) cp *.log bak : a.log, b.log 와 같은 파일들을 bak에 복사 Linux - Shell script 2 : example!/bin/bash : 밑에 작성되는 코드들이 /bin/bash 를 통해 해석된다ex)12345nano backup if ! [ -d bak ] ; then mkdir bakficp *.log bakchmod +x backup : backup을 실행가능한 형태로 만들어줌. (파일 형태 맨 뒤에 x가 붙는다)./backup : backup 실행 (현재 디렉토리에 있는 파일일 때) Linux - Directory structure 1root ( / ) 밑에 있는 다양한 디렉토리. (bin, sbin, etc, var, tmp) Linux - Directory structure 2cd ~ : 현재 사용자의 홈 디렉토리로 이동프로그램 어딨는지 확인: whereis htop Linux - Process 1 : Computer structureCPU(Processor) / RAM(Memory) / SSD,HDD(Storage)Storage의 프로그램 -&gt; 읽어서 Memory에 적재 -&gt; Processor가 읽어서 동작, 데이터 처리 Linux - Process 2 : ps top htopps : 프로세서 목록 ( ps aux 하면 백그라운드까지 뜸 )grap, pipeline 이용해서 원하는 거 찾기sudo kill (PID) 하면 프로그램 정지 가능 Linux - File find 1 : locate, findlocate .log : log 확장자 파일을 모두 찾아줌locate는 디렉토리를 뒤지지 않고, 데이터베이스(mlocate)를 뒤진다.find : 직접 디렉토리를 뒤져서 찾음ex) find / -name .log : 이름으로 찾기 ( / : root, ~ : home, . : 현재 디렉토리 )find . -type f -name *.log : 타입 지정 ( f : file ) Linux - File find 2 : whereis, $PATHPATH에 특정 경로 ( bin 등 ) 가 저장되어 있어 어디에서든 ls를 입력해도 실행된다.echo $PATH 를 통해 확인 가능 Linux - background execute (Ctrl+Z, &amp;)Ctrl+Z : 프로그램을 백그라운드로 돌림fg : 백그라운드 프로그램을 포그라운드로jobs : 백그라운드 프로그램 확인fg %2 : jobs의 2에 해당되는 프로그램 실행kill %2 : 2를 삭제 ( 더 센 삭제 : kill -9 %2 )명령 맨 뒤에 &amp; 를 붙이면, 백그라운드에서 명령이 실행되며 다른 명령을 바로 할 수 있음.ex) ls -alR / &gt; result.txt 2&gt; error.log &amp; Linux - daemon 1 : introdaemon : 항상 켜져 있는 프로그램ex) server : client가 browser를 통해 요청 할 때 바로 응답해야 하기 때문에 항상 켜져 있어야 함. Linux - daemon 2 : service &amp; auto startex) sudo apt -get install apache2 : apache2 다운로드sudo service apache2 start : apache2 시작sudo service apache2 stop : apache2 멈춤( ps aux | grap apache2 로 확인 가능 )daemon 프로그램은 service를 이용하여 실행해줘야 함시작할 때 자동으로 시작하게 하고 싶으면, /etc/rc3.d/ 밑에 링크를 걸면 된다. (S:시작, K:시작안함) Linux - Time based job schedule cron 1 : usagecrontab -e : 적어준 대로 cron이 정기적 작업을 실행시켜줌분 시 일 달 요일 ( /1 : 1분마다, : 상관없음 )tail -f date.log : 맨 뒤 문장을 출력, 바뀔 때마다 새로고침 ( - f )2&gt;&amp;1 : error를 표준 출력으로 redirect 하여 같이 표시 Linux - Time based job schedule cron 2 : example","link":"/2020/03/23/2020-03-23-Linux-Study/"},{"title":"DFS와 BFS","text":"DFS(Depth-First Search, 깊이 우선 탐색)과 BFS(Breadth-First Search, 너비 우선 탐색)은 그래프 탐색 시 사용되는 알고리즘이다. 각각을 자세히 설명하기 전에, 간단한 모형으로 설명하자면 다음과 같다. 1. DFS (Depth-First Search, 깊이 우선 탐색)어떤 노드에서 같은 level의 다른 노드로 넘어가기 전에 해당 노드와 관련된 모든 방법을 탐색하는 방법이다. 즉, 넓게 탐색하기 전에 깊게 탐색 하는 방법이다. 다음과 같은 비유를 할 수 있다. “ 미로찾기를 할 때, 한 방향으로 갈 수 있을 때까지 계속 간다. 더 이상 갈 수 없을 때, 가장 가까운 갈림길로 돌아와서 다른 방향으로 다시 탐색을 시작한다. “ DFS는 다음과 같은 특징을 가진다. 모든 노드를 방문할 수 있는 방법이다. BFS보다 간편하다. BFS보다 검색 속도 자체는 느리다. (검색의 효율은 BFS보다 낮다) 재귀 호출의 알고리즘을 가진다. 2020.08.24 추가 : 직접 구현한 코드1234567891011121314void dfs(int V){ printf(&quot;%d &quot;, V); // visited V visit[V] = 1; // find next node for(int i = 1; i &lt;= N; i++){ if(map[V][i] == 1 &amp;&amp; visit[i] != 1){ // when V and i is connected but not visited yet, go to i dfs(i); } } // when no deeper node exist, return (recursion)} 2. BFS (Breadth-First Search, 너비 우선 탐색)어떤 노드에서 그 아래 level을 탐색하기 전에 해당 노드와 같은 level의 노드들을 먼저 탐색하는 방법이다. 즉, 깊게 탐색하기 전에 넓게 탐색하는 방법이다. BFS는 다음과 같은 특징을 가진다. 모든 노드를 방문할 필요가 없어, 검색 효율이 높다는 장점이 있다.(예: 지구 상의 모든 친구 관계를 그래프로 표현한 후, 그래프에서 A와 B 사이에 존재하는 경로를 찾는다. DFS를 사용하면 존재하는 모든 친구 관계를 모두 확인해야 할 지도 모른다. BFS를 사용하면 A와 가까운 관계부터 탐색하게 된다.) 재귀적으로 작동하지 않는다. 방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료 구조 큐(Queue)를 사용한다. 2020.08.24. 추가 : 직접 구현한 코드1234567891011121314151617181920212223void bfs(int V){ // use queue // visited V visit[V] = 1; q.push(V); // bfs until end of nodes while(!q.empty()){ // visit front node of q V = q.front(); q.pop(); printf(&quot;%d &quot;, V); for(int i = 1; i &lt;= N; i++){ // check other nodes connected with node V if(map[V][i] == 1 &amp;&amp; visit[i] != 1){ // if connected and not visited yet, push node in queue and check visited q.push(i); visit[i] = 1; } } }}","link":"/2020/03/20/2020-03-20-DFS-BFS/"},{"title":"Baekjoon 2580 (스도쿠)","text":"Baekjoon 2580, 백준 2580 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제 보기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;// 9*9 스도쿠 판을 이중배열로 만들고 0으로 초기화int sudoku[9][9] = { 0, };// 행, 열, 사각형에 각각 숫자가 있는지 확인. ex) 3번째 열에 5가 있으면 row[3][5]=true.// 기본값은 모두 false (0)bool row[9][10] = { 0, };bool col[9][10] = { 0, };bool square[9][10] = { 0, };// 3*3 사각형으로 쪼갤 때, 몇 번째 위치에 있는지 반환int SquareNum(int x, int y) { return (x/3)*3 + (y/3);}// 마지막에 스도쿠 출력하는 함수int printSudo() { for(int i=0; i&lt;9; i++){ for(int j=0; j&lt;9; j++){ printf(&quot;%d &quot;,sudoku[i][j]); } printf(&quot;\\n&quot;); }}// 스도쿠 푸는 함수 (백트래킹 사용). k가 채워넣은 칸 수void makeSudo(int k){ if(k==81) { printSudo(); exit(0); } // k번째 입력되는 값은 sudoku[x][y] int x = k/9, y = k%9; // 입력된 값이 0이 아니면 다음 번호로 넘어가면 됨 if(sudoku[x][y] != 0) makeSudo(k+1); // 입력된 값이 0일 때 else { for(int i=1; i&lt;=9; i++){ // row, col, square 값이 모두 false 일 때 if( row[x][i]==false &amp;&amp; col[y][i]==false &amp;&amp; square[SquareNum(x,y)][i]==false ){ // row, col, square 값 true로 설정 row[x][i] = col[y][i] = square[SquareNum(x,y)][i] = true; // sudoku[x][y] 에 i 대입 후 다음 단계(k+1)로 sudoku[x][y] = i; makeSudo(k+1); // 오류가 생긴 경우 백트래킹 sudoku[x][y] = 0; row[x][i] = col[y][i] = square[SquareNum(x,y)][i] = false; } } }}int main(){ // 스도쿠 입력 받기 for(int i=0; i&lt;9; i++){ for(int j=0; j&lt;9; j++){ scanf(&quot;%d&quot;, &amp;sudoku[i][j]); if(sudoku[i][j] != 0){ // 3개의 bool형 배열의 값을 true로 바꿔준다. row[i][sudoku[i][j]] = true; col[j][sudoku[i][j]] = true; square[SquareNum(i,j)][sudoku[i][j]] = true; } } } makeSudo(0); return 0;}exit(0) 부분을 return 0; 으로 두어,분명 스도쿠 답이 모두 맞는데 왜 틀렸지? 하고 1시간 삽질한 문제.","link":"/2020/04/04/2020-04-04-Baekjoon-2580/"},{"title":"Dynamic Programming - Knapsack Problem","text":"두 번째로 소개할 Dynamic Programming 알고리즘은 배낭 문제(Knapsack problem) 이다. Knapsack Problem(배낭문제)란, 주어진 가치와 무게를 가진 짐들을 배낭에 넣을 때, 주어진 무게의 최댓값을 넘지 않으면서 가치의 합이 최대가 되도록 짐을 넣는 방법을 찾는 문제이다.짐을 쪼갤 수 있는 경우는 분할가능 배낭문제(Fractional Knapsack Problem)이라 하고, 쪼갤 수 없는 경우는 0-1 배낭문제(0-1 Knapsack Problem) 이라 한다. 본 글에서는 Dynamic Programming을 이용하여 0-1 Knapsack Problem을 해결할 것이다. 문제 상황은 Baekjoon 12865를 참고하자. N개의 물건과, 최대 K의 무게를 담을 수 있는 배낭이 주어진다. 각 물건은 무게 W와 가치 V를 가진다. 우리는 가치의 최대가 되도록 물건들을 담아야 한다. 아이디어는 다음과 같다:1D[i][j] 의 2차원 배열을 선언하는데, 이는 i번째 보석까지 탐색, 무게가 j만큼 사용되었을 때 가치의 최댓값이다.W[i], V[i]를 i번 물건의 무게, 가치라고 하자.본 알고리즘에서는 i를 하나씩 늘려가며 D[i][j]를 계산할 것이다. 만약 i번째 보석을 가져간다면, D[i][j] = D[i-1][j-W[i]] + V[i] 이다. i번째 보석을 가져가지 않는다면, D[i][j] = D[i-1][j] 이다. 각 순간마다 위에서 제시한 D[i-1][j], D[i-1][j-W[i]]+V[i] 중 큰 경우를 선택하면 된다. 필자의 코드는 여기 에서 확인할 수 있다.","link":"/2020/04/11/2020-04-11-Dynamic-Programming-Knapsack-Problem/"},{"title":"Dynamic Programming - LCS problem","text":"우선, Dynamic Programming에 대해 알아보자. Dynamic Programming (동적계획법) 이란, 쉽게 말해 큰 문제를 작은 문제로 나누어 푸는 것을 말한다. 여기까지는 분할정복 (Divide and Conquer)와 개념이 일치한다. Dynamic Programming의 핵심 포인트는, 작은 문제들을 반복해서 풀지 않는다는 것이다. 이는 시간을 크게 절약할 수 있다. Dynamic Programming은 작은 문제들이 반복되서 나오고, 이들의 답이 바뀌지 않을 때 유용하게 사용된다. 필자가 현재까지 Baekjoon에서 동적계획법 문제를 풀면서 가장 지겹도록 풀었던 문제 유형은 ‘점화식’ 유형들이다. 피보나치 수열을 예로 들어보자. 우리는 앞에서 재귀호출을 이용하여 피보나치 수열의 값을 구한 바 있다. 하지만, 재귀호출을 이용하면 우리는 이미 3번째, 4번째 피보나치 수를 계산하기 위해 다시 재귀 구문을 돌려야 한다. 이는 시간 낭비이다. 피보나치 수를 담아놓는 배열을 만들어, 구한 값을 이 배열에 담아놓자. 배열에 담긴 수는 이미 이전에 구한 수이므로, 또 다시 계산할 필요 없이 가져다 쓰면 된다. 위와 같은 점화식 문제들은 점화식만 잘 세우면 쉽게 코딩할 수 있기 때문에, 수학 문제라고 부를 수 있다. 이 블로그에서 이번에 Dynamic Programming에 대해 다루려는 문제는 크게 두 개인데, 바로 LCS problem과 knapsack problem 이다. 이들은 특유의 Dynamic Programming 알고리즘을 모르면 매우 고생하게 된다. LCS(Longest Common Subsequence, 최장 공통 부분 수열) 문제는 두 수열이 주어지면, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다. 예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK이다. 이것과 구분해야 되는 것은 LCS(Longest Common Substring)이다. Subsequence는 부분 수열이고, Substring은 문자열이다. Subsequence는 연속하지 않아도 되며, Substring은 연속해야 한다는 차이가 있다. LCS 알고리즘은 두 수열을 2차원 표에 적으면서 시작된다. 위 예시는 두 수열 ACAYKP, CAPCAK의 LCS를 구하는 예시이다. 우선, 첫 줄은 모두 0을 적는다. 이후, 나머지 표의 칸은 다음의 규칙에 맞추어 채운다. 밑에서 말하는 두 문자는, 그 칸에 대응되는 각 수열의 문자를 의미한다. 두 문자가 같으면, 왼쪽 위 대각선의 값에 1을 더하여 적는다. 두 문자가 다르면, 윗 칸과 왼쪽 칸을 비교하여 더 큰 값을 적는다. 위와 같이 표를 완성하였다면, 구하고자 하는 LCS의 길이는 가장 오른쪽 아래의 값이다! 표를 완성시킨 규칙을 잘 생각해 보면, 왜 위와 같은 규칙으로 표를 채워 나가는지, 그리고 왜 마지막 값이 LCS의 길이가 되는지 알 수 있을 것이다. 이제, LCS가 되는 수열(문자열)을 구해보자. 위 표에서 구해낼 수 있다.위 표를 보게 되면, 각 숫자의 ‘영역’이 있음을 확인할 수 있다. 0의 영역, 1의 영역, 2의 영역, … 이 영역을 잘 유의하면서 아래 규칙을 따른다. 가장 오른쪽 아래 칸에서 시작한다. 왼쪽 칸, 혹은 위쪽 칸으로 이동할 수 있다. 단, 숫자가 같아야 한다. (같은 영역의 칸이어야 한다.) 더 이상 이동할 수 없다면, 왼쪽 위 대각선으로 한 칸 이동한다. 이 때, 이동하기 전 칸의 문자를 기록한다. 0의 영역에 도달할 때까지 위 작업을 반복하고, 기록한 문자들을 역으로 출력해낸다. 참고: 2번의 과정에서 기록되는 칸은 두 수열에서 (당연히) 같은 문자를 가르키는 칸이어야 한다! 필자는 LCS의 개수를 구하는 코드는 짰으며(Baekjoon 9251), 여기에서 확인할 수 있다. 사진출처","link":"/2020/04/11/2020-04-11-Dynamic-Programming-LCS-Problem/"},{"title":"Baekjoon 9251 (LCS)","text":"Baekjoon 9251, 백준 9251 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제 보기1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAX(x,y) ( (x)&gt;(y) ? (x) : (y) )char a[1001], b[1001]; // 입력받는 두 문자int dp[1001][1001] = {0,}; // 2*2 배열을 만든다.// dp[i][j]는 a의 i번째 글자까지와 b의 j번째 글자까지의 LCS를 의미함.int main(){ scanf(&quot;%s&quot;,a); scanf(&quot;%s&quot;,b); int a_len = strlen(a); int b_len = strlen(b); for(int i=1; i&lt;=a_len; i++){ for(int j=1; j&lt;=b_len; j++){ if(a[i-1]==b[j-1]) dp[i][j] = dp[i-1][j-1] + 1; else dp[i][j] = MAX(dp[i][j-1], dp[i-1][j]); } } printf(&quot;%d&quot;,dp[a_len][b_len]);}LCS algorithm을 이용하면 쉽게 풀리지만, 모른다면 꽤 복잡해 질 것 같은 문제.","link":"/2020/04/18/2020-04-18-Baekjoon-9251/"},{"title":"Baekjoon 12865 (평범한 배낭)","text":"Baekjoon 12865, 백준 12865 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제 보기12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#define MAX(x,y) ( (x)&gt;(y) ? (x) : (y) )//Knapsack Algorithm (배낭싸기 알고리즘)// W[i]: i번 보석의 무게// V[i]: i번 보석의 가치// D[i][j]: i번째 보석까지 탐색, 무게 j만큼 사용했을 때 가치 최댓값int N, K;int W[101], V[101], D[101][100000]={0,};int main(){ scanf(&quot;%d %d&quot;,&amp;N, &amp;K); for(int i=1; i&lt;=N; i++){ scanf(&quot;%d %d&quot;, &amp;W[i], &amp;V[i]); } // i번째 보석을 가져간 경우: // D[i][j] = D[i-1][j-W[i]] + V[i] // i번째 보석을 가져가지 않은 경우: // D[i][j] = D[i-1][j] for(int i=1; i&lt;=N; i++){ for(int j=0; j&lt;=K; j++){ D[i][j] = D[i-1][j]; if(j-W[i]&gt;=0){ D[i][j] = MAX(D[i][j], D[i-1][j-W[i]]+V[i]); } } } printf(&quot;%d&quot;,D[N][K]);}아주 유명한 Knapsack problem의 기본 형태 문제이다.2차원 배열을 설정하여 동적계획법(Dynamic Programming)을 사용하는 것이 흥미로웠다.","link":"/2020/04/18/2020-04-18-Baekjoon-12865/"},{"title":"Greedy Algorithm","text":"Greedy Algorithm (그리디 알고리즘, 탐욕 알고리즘) 은 문제를 작은 문제들로 나눈 후, 각 순간순간의 문제마다 최적의 결정을 택하는 알고리즘이다. 작은 문제들로 나누어 풀기 때문에, 일종의 DP (동적계획법) 문제의 예라고 생각할 수 있다. 작은 문제들에서 항상 최적의 결정을 한다고 해서, 결론적으로 그것이 최적의 결정이 된다는 것은 결코 보장할 수 없다. 따라서 개인적으로, 그리디 알고리즘을 이용하여 문제를 풀 때는 그 아이디어를 잘 정하는 것이 키 포인트라고 생각한다. 작은 문제들에서 항상 최적의 결정만을 택했을 때, 결론적으로도 그것이 최적의 결정이 되도록 풀이를 구상해야 한다. 그리디 알고리즘을 이용하는, 쉬운 문제와 어려운 문제를 하나씩 다루어 보려 한다. 가장 유명하면서 쉬운 문제는 ‘동전 문제’이다(Baekjoon 11407, 동전 0 문제). 주어진 단위의 동전들과 만들어야 하는 금액이 주어졌을 때, 필요한 동전 개수의 최솟값을 구하는 문제이다. 1원, 10원, 100원의 세 종류의 동전이 있고, 347원을 만들어야 한다고 생각하자. 해답이 100원 동전 3개, 10원 동전 4개, 1원 동전 7개를 사용한 14개라는 것은 분명하다. 이를 다음과 같이 생각한다. 347원에서, 최대한 100원짜리 동전을 사용한다. 최대 3개가 사용 가능하다. 이를 제외하면, 남은 47원에서는 10원짜리 동전을 최대한으로 사용한다. … 위와 같은 알고리즘을 적용한다. 이러한 알고리즘은 “동전의 단위가 서로 배수 관계에 있기 때문”에 사용 가능하다. ( 10 = 1 10, 100 = 10 10 ) 배수의 관계에 있지 않다면 위와 같이 그리디 알고리즘을 사용할 수 없다. 예를 들어 3원과 5원 동전이 주어진다면, 5원짜리 동전을 무작정 사용하다 원하는 금액을 아예 만들지도 못할 수 있기 때문이다. 이번에는 조금 어려운 예시를 생각해 보자. 꽤 널리 알려진 ‘회의실 배정 문제’이다(Baekjoon 1931, 회의실배정 문제). 시작하는 시간과 끝나는 시간이 정해진 회의들이 주어진다. 한 회의실에서 회의를 진행할 때, 겹치지 않도록 회의를 고를 때 회의의 최대 개수를 구해야 한다. 그리디 알고리즘을 이용한 간단한 아이디어로, 매 순간마다 가장 빠르게 시작하는 수업을 택하는 방법을 생각해 볼 수 있다. 그러나 그 경우에는 다음과 같을 때를 해결할 수 없다: 세 회의 (1, 10), (2, 8), (9,11)가 주어졌을 때, (2,8)과 (9,11)을 택하는 경우가 최댓값이지만 위 알고리즘에 따르면 (1,10)을 택하게 된다. 본 문제를 해결한 필자의 아이디어는 “회의가 끝난 시점마다 종료 시간이 가장 이른 회의를 선택” 하는 것이었다. 위와 같이 구상하여 그리디 알고리즘을 사용하면, 모든 경우에서 해답을 찾아낼 수 있다. (증명도 귀류법으로 가능하다.) 이와 같이 그리디 알고리즘을 사용하여 문제를 해결할 때는, 그 아이디어를 구상하는 것이 중요하다. Baekjoon 11407, 동전 0 문제Baekjoon 1931, 회의실배정 문제Baekjoon 1931, 회의실배정 필자의 코드","link":"/2020/04/25/2020-04-25-Greedy-Algorithm/"},{"title":"#define SWAP macro","text":"SWAP을 자주 사용하는 경우에는, 아래와 같이 임의의 type에 대한 SWAP 함수를 매크로로 지정해 놓으면 편하다.(특히, C 언어에서!) 123456#define SWAP(a,b,type) do{ \\ type temp; \\ temp=a; \\ a=b; \\ b=temp; \\}while(0) define 매크로에 여러 줄을 넣기 위해서는 do while 문을 활용해야 한다.위와 같은 형태로 SWAP 매크로를 작성하면, int 형인 a와 b의 값을 바꿔야 할 때 SWAP(a, b, int) 와 같이 바꿀 수 있다.","link":"/2020/04/27/2020-04-27-define-SWAP/"},{"title":"Baekjoon 1541 (잃어버린 괄호)","text":"Baekjoon 1541, 백준 1541 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;char input[51];int temp = 0, result = 0;int math = 1; // 양수이면 기본. 음수이면 앞에 뺄셈이 있는 상황int check = 0; // +가 입력되면 1, -가 입력되면 -1,종료 시 2int main(){ scanf(&quot;%s&quot;, input); for(int i=0; i&lt;51; i++){ if(check != 0){ (math &gt; 0) ? (result += temp) : (result -= temp); if(check==2) break; math *= check; check = 0; temp = 0; } if(input[i+1]==0){ temp = temp * 10 + input[i]-'0'; check = 2; } else if(input[i] == '+') check = 1; else if(input[i] == '-'){ if(math==(-1)) check = 1; else check = -1; } else temp = temp * 10 + input[i]-'0'; } printf(&quot;%d&quot;,result);}스터디 톡방에서 만 include하여 풀었다고 다들 자랑스러워 하여,본인도 최대한 만 이용하여 풀었던 문제 ㅎㅎmath, check 이라는 두 가지 변수를 직접 설정하여 나만의 아이디어로 해결하였다!","link":"/2020/05/03/2020-05-03-Baekjoon-1541/"},{"title":"Baekjoon 1931 (회의실배정)","text":"Baekjoon 1931, 백준 1931 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#define MAX_NUM 100000#define SWAP(a, b, type) do{\\ type temp;\\ temp = a; \\ a = b; \\ b = temp; \\} while(0)// Idea: 각 시점마다 종료 시간이 가장 이른 회의를 선택 (그리디 알고리즘)typedef struct{ unsigned int start; unsigned int end;} meeting;int N, heap_len = 0;meeting heap[MAX_NUM+1];// 끝 시간이 이르거나, 끝 시간이 같은데 시작 시간이 이르면// 우선도가 높다고 생각. x가 y보다 우선도가 높으면 check(x,y)=true;bool check(int x, int y){ if(heap[x].end &lt; heap[y].end || (heap[x].end==heap[y].end &amp;&amp; heap[x].start &lt; heap[y].start) ){ return true; } else return false;}// 힙 추가void add_heap(meeting* heap, meeting meeting_new){ if(heap_len == 0){ heap[1] = meeting_new; heap_len++; } else if(heap_len &gt; 0) { heap[++heap_len] = meeting_new; int x = heap_len; while(x&gt;1){ if(check(x, x/2)){ SWAP(heap[x], heap[x/2], meeting); x /= 2; } else break; } }}// 최상단 힙 제거meeting delete_heap(meeting* heap){ // 최상단 힙을 min에 넣고, 최상단 힙과 마지막 번호 힙 교환하기 // 힙 크기를 하나 줄이면 마지막 번호에 들어간 힙은 없어짐. meeting min = heap[1]; SWAP(heap[1], heap[heap_len], meeting); heap_len--; // 정렬 int parent = 1, child = 2; while(child &lt;= heap_len){ // 우선도 높은 자식 노드 찾기 if(check(child+1, child) &amp;&amp; (child&lt;heap_len)) child++; // 우선도 더 높은 자식 노드보다 부모 노드가 더 높으면 정지 if(check(parent,child)) break; // 그렇지 않으면, 부모와 자식 교환 SWAP(heap[parent],heap[child],meeting); parent = child; child *= 2; } return min;}int main(){ int current_time = 0; // 현재까지 선택된 마지막 회의의 시간 int count = 0; // 현재까지 선택된 회의 갯수 scanf(&quot;%d&quot;,&amp;N); // 회의 시간들 입력받기 for(int i=0; i&lt;N; i++){ meeting temp; scanf(&quot;%d %d&quot;,&amp;temp.start,&amp;temp.end); add_heap(heap,temp); } meeting current_meeting; while(heap_len&gt;0){ // 우선도 가장 높은 힙이 현재 선택된 회의와 시간이 겹치지 않는다면, 선택 if(heap[1].start &gt;= current_time){ current_meeting = delete_heap(heap); count++; current_time = current_meeting.end; } // 그렇지 않다면 그냥 힙 버림 else {; current_meeting = delete_heap(heap); } } printf(&quot;%d&quot;,count);} 각 시점마다 종료 시간이 가장 이른 회의를 선택하는 그리디 알고리즘을 이용해서 풀었다.Heap sort를 이용하여 시간 초과가 나지 않도록 하였다. Heap sort를 쉽게 구현할 수 있도록 도와준 지환에게 감사의 말을 전한다.","link":"/2020/05/03/2020-05-03-Baekjoon-1931/"},{"title":"Manual of Git","text":"정교민 교수님의 Programming Methodology 수업을 수강하던 도중, 수업 시간에 git의 사용법에 대해 다루었다. 정리의 필요성을 느껴, 아래와 같이 정리하였다. 참고 자료 git init : 이 폴더가 git의 관리 하에 들어감.git config —global user.name “이름” : 이름 설정git config —global user.email “메일” : 이메일주소 설정 타임캡슐의 비유를 사용. 커밋하는 내용들을 타임캡슐로 생각.타임캡슐에 넣고, 묻는다.git status : 이 파일들이 “만들어지거나, 수정되거나, 삭제된 사실” 들이 나타난다. untracked files: 없었다가 새로 생긴 파일들 git add 파일이름 : 그 이름의 파일을 타임캡슐에 넣는다. git add -A : status의 모든 사실들을 타임캡슐에 넣는다. git commit -m “메세지” : 타임캡슐을 묻는다. (커밋한다)git log : 캡슐들의 정보와 메세지가 뜬다. 이전의 캡슐로 되돌리기git reset 캡슐번호: 캡슐 이전의 상태로 돌아간다. 캡슐번호는 git log 의 앞 6글자로 하면 된다 git reset ff18a —soft : ff18a 시점으로 돌아가며, 이후에 한 모든 변경사항이 git commit을 하기 직전의 상태, 즉 타임캡슐에만 넣어진 상태가 됨. git reset ff18a —mixed : ff18a 시점으로 돌아가며, 이후에 한 모든 변경사항이 git add을 하기 직전의 상태가 됨. 타임캡슐에도 들어가 있지 않음. git reset ff18a —hard : ff18a 시점으로 돌아가며, 이후에 한 모든 변경사항이 아예 없어짐. 생략할 경우, 기본으로는 mixed가 실행된다. git revert 캡슐번호: 취소할 캡슐 번호를 넣으면, 그 캡슐이 반전된 캡슐이 하나 더 생겨서 묻힘. 결과적으로 상쇄되지만, git log 에서 확인 가능함. branch를 평행우주로 생각git branch 이름: 이름의 branch를 새로 생성한다. 기존의 상태를 모두 가져간다. git branch 만 치면, branch 이름들을 확인 가능 git branch -D 이름 : 해당 이름의 branch를 삭제한다. git checkout 이름: 이름의 branch로 이동한다. 새로 만든 branch를 기존 master에 합치자git merge 이름: 이름의 branch를 현재 branch에 합친다. master에 합치고 싶으면 git checkout master 쳐서 master로 이동해준 후, merge로 합친다. 다른 방법으로 수정된 두 branch를 합치는 경우 에러가 뜬다. git log —graph —all —decorate : 시각화된 log을 확인할 수 있다. 참고자료이해를 크게 돕는 사진들이 있으니 헷갈리면 들어가서 보자. 용어설명HEAD : 현재 branch(에 담긴 커밋 중 가장 마지막 커밋)를 가리키는 포인터Index: 바로 다음에 커밋할 것들. ( = Staging Area )Working Directory : 작업 공간. 테스트 환경? 저장 원리Working Directory —(git add)-&gt; Index —(git commit)-&gt; Git repository(HEAD)git commit은 Index(Staging Area)의 내용을 스냅샷으로 영구히 저장하도록 하고, 그 스냅샷을 가리키는 커밋 객체를 만든다. 그리고 master가 그 커밋 객체를 가리키도록 한다.branch를 checkout 하면, HEAD가 새로운 branch를 가리키도록 바꾸고, 새로운 커밋의 스냅샷을 Index에 넣는다. 그리고 Index의 내용을 Working Directory로 복사한다. reset의 원리 reset —soft 를 하면 HEAD를 이동시킨다. (마지막 단계의 git commit 만을 되돌림) reset —mixed 를 하면 이동된 HEAD가 가리키는 스냅샷으로 Index를 업데이트한다. reset —hard 를 하면 Working Directory까지 업데이트한다.","link":"/2020/05/10/2020-05-10-Git/"},{"title":"Baekjoon 1876 (스택 수열)","text":"Baekjoon 1876, 백준 1876 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;int main() { int n, i, j, num, temp = 0; stack&lt;int&gt; st; vector&lt;char&gt; vec; // save the result (+,-) vector&lt;int&gt; seq; cin &gt;&gt; n; // save the sequence in vector seq for (i = 0; i &lt; n; i++) { cin &gt;&gt; j; seq.push_back(j); } for (num = 1; num &lt;= n; num++) { st.push(num); vec.push_back('+'); if (!st.empty() &amp;&amp; st.top() == seq.at(temp)) { do { st.pop(); vec.push_back('-'); temp++; } while (!st.empty() &amp;&amp; st.top() == seq.at(temp)); } } if (!st.empty()) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; '\\n'; return 0; } for (i = 0; i &lt; vec.size(); i++) { cout &lt;&lt; vec.at(i) &lt;&lt; '\\n'; }}스택 단원의 마지막 문제.시간 상 C++의 &lt;stack&gt;을 이용하여 풀었기 때문에,크게 기억에 남는 것이 없는 단원이였다.다음 단원부터는 다른 STL 헤더 없이 직접 구현해야겠다고 다짐함.","link":"/2020/07/03/2020-07-03-Baekjoon-1876/"},{"title":"Baekjoon 1966 (프린터 큐)","text":"Baekjoon 1966, 백준 1966 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;using namespace std;int main() { int test_case, N, M; bool answer_printed = false; cin &gt;&gt; test_case; while(test_case--){ cin &gt;&gt; N &gt;&gt; M; // initialization int* arr = new int[1000000]; int start = 0, last = N; int count = 1; int max_imp = 0; for(int i=0; i&lt;N; i++) { cin &gt;&gt; arr[i]; if(arr[i] &gt; max_imp) max_imp = arr[i]; } // ordering while(last - start != 1){ // pop_and_push_it_back if(arr[start] != max_imp) { // moving M if(start == M) M = last; arr[last] = arr[start]; start++; last++; continue; } // pop max_importance else if(arr[start] == max_imp) { // answer choice if(start == M) { cout &lt;&lt; count &lt;&lt; '\\n'; answer_printed = true; break; } // not the answer choice else { count++; start++; // find the next max_imp max_imp = 0; for(int j = start; j &lt; last; j++) if(arr[j] &gt; max_imp) max_imp = arr[j]; continue; } } } // only one input if(!answer_printed) cout &lt;&lt; count &lt;&lt; '\\n'; answer_printed = false; delete[] arr; }}Queue를 응용하는 문제!요런 유형의 문제는, 문제를 보고 “Queue를 사용해야겠다!”를 빨리 떠올리는 것이 관건인 것 같다(비록 현재는 단원 명에 표시되어 있지만..)","link":"/2020/07/10/2020-07-10-Baekjoon-1966/"},{"title":"Baekjoon 18258 (큐 2)","text":"Baekjoon 18258, 백준 18258 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;#define size 20000001int* arr = new int[size];int last = 0;int start = 0;void switch_string(string s){ if(s == &quot;push&quot;){ int num; cin &gt;&gt; num; arr[last] = num; last++; } else if(s == &quot;pop&quot;) { if(last - start == 0) cout &lt;&lt; -1 &lt;&lt; '\\n'; else { cout &lt;&lt; arr[start] &lt;&lt; '\\n'; start++; } } else if(s == &quot;size&quot;){ cout &lt;&lt; last - start &lt;&lt; '\\n'; } else if(s == &quot;empty&quot;){ if(last - start == 0) cout &lt;&lt; 1 &lt;&lt; '\\n'; else cout &lt;&lt; 0 &lt;&lt; '\\n'; } else if(s == &quot;front&quot;){ if(last - start == 0) cout &lt;&lt; -1 &lt;&lt; '\\n'; else cout &lt;&lt; arr[start] &lt;&lt; '\\n'; } else if(s == &quot;back&quot;){ if(last - start == 0) cout &lt;&lt; -1 &lt;&lt; '\\n'; else cout &lt;&lt; arr[last - 1] &lt;&lt; '\\n'; }}int main() { ios::sync_with_stdio(false); cin.tie(NULL); int N; cin &gt;&gt; N; while(N--){ string s; cin &gt;&gt; s; switch_string(s); } delete[] arr;}두 번째 스터디가 어느 새 첫 번째 스터디의 진도를 따라잡았다..저번의 다짐대로 큐, 덱 단원은 STL 사용하지 않고 배열로 생 구현 했다.위 문제는 큐를 구현한 것.본인은 배열에서 start와 last라는 두 변수를 사용하여 구현하였다.","link":"/2020/07/10/2020-07-10-Baekjoon-18258/"},{"title":"Baekjoon 10866 (덱)","text":"Baekjoon 10866, 백준 10866 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int* arr = new int[100010];int start = 5000;int last = 5001;void deque_func(string s) { int num = 0; if(s == &quot;push_front&quot;) { cin &gt;&gt; num; arr[start] = num; start--; } else if(s == &quot;push_back&quot;) { cin &gt;&gt; num; arr[last] = num; last++; } else if(s == &quot;pop_front&quot;) { if(last - start == 1) cout &lt;&lt; -1 &lt;&lt; '\\n'; else { cout &lt;&lt; arr[start + 1] &lt;&lt; '\\n'; start++; } } else if(s == &quot;pop_back&quot;) { if(last - start == 1) cout &lt;&lt; -1 &lt;&lt; '\\n'; else { cout &lt;&lt; arr[last - 1] &lt;&lt; '\\n'; last--; } } else if(s == &quot;size&quot;) { cout &lt;&lt; last - start - 1 &lt;&lt; '\\n'; } else if(s == &quot;empty&quot;) { if(last - start == 1) cout &lt;&lt; 1 &lt;&lt; '\\n'; else cout &lt;&lt; 0 &lt;&lt; '\\n'; } else if(s == &quot;front&quot;){ if(last - start == 1) cout &lt;&lt; -1 &lt;&lt; '\\n'; else cout &lt;&lt; arr[start + 1] &lt;&lt; '\\n'; } else if(s == &quot;back&quot;){ if(last - start == 1) cout &lt;&lt; -1 &lt;&lt; '\\n'; else cout &lt;&lt; arr[last - 1] &lt;&lt; '\\n'; }}int main() { int N; cin &gt;&gt; N; while(N--){ string input_s; cin &gt;&gt; input_s; deque_func(input_s); } delete[] arr;}앞의 Queue와 마찬가지로 STL을 사용하지 않고 배열을 이용하여 생 구현했다.Queue와 같이 start와 last 변수를 사용하였는데,Deque의 경우에는 앞쪽으로도 데이터가 입력될 수 있어서 start과 last 값을 중앙(5000 부근)으로 두었다.","link":"/2020/07/15/2020-07-15-Baekjoon-10866/"},{"title":"Baekjoon 5430 (AC)","text":"Baekjoon 5430, 백준 5430 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { int T, n; string p, input_array; cin &gt;&gt; T; while(T--){ //test case start cin &gt;&gt; p; cin &gt;&gt; n; cin &gt;&gt; input_array; int* arr = new int[400010]; int arr_count = 1; int start = 0; int last = n + 1; bool is_error = false; bool is_reverse = false; // input array int k = 1; while(input_array[k] != '\\0') { int x = 0; while(input_array[k] &gt;= '0' &amp;&amp; input_array[k] &lt;= '9') { x *= 10; x += int(input_array[k] - '0'); k++; } if( x != 0 ){ arr[arr_count] = x; arr_count++; } k++; } // do actions for(int j = 0; j &lt; p.length(); j++) { if(p[j] == 'R'){ // check if it is reverse or not is_reverse = !is_reverse; } else if(p[j] == 'D'){ // delete first number or last number // if array is empty if(last - start == 1) { is_error = true; break; } // if array is not empty: else { if(is_reverse) last--; else if(!is_reverse) start++; } } } if(is_error) cout &lt;&lt; &quot;error&quot; &lt;&lt; '\\n'; else { cout &lt;&lt; &quot;[&quot;; if(!is_reverse){ for(int i = start + 1; i &lt; last - 1; i++) cout &lt;&lt; arr[i] &lt;&lt; &quot;,&quot;; if(last - start != 1) cout &lt;&lt; arr[last-1]; cout &lt;&lt; &quot;]&quot; &lt;&lt; '\\n'; } else if(is_reverse){ for(int i = last - 1; i &gt; start + 1; i--) cout &lt;&lt; arr[i] &lt;&lt; &quot;,&quot;; if(last - start != 1) cout &lt;&lt; arr[start + 1]; cout &lt;&lt; &quot;]&quot; &lt;&lt; '\\n'; } } is_error = false; p = &quot;&quot;; }}생각보다 예외 처리할 게 많았던.. 생각보다 더러웠던.. 문제였다결국 7번의 런타임 에러를 해결하지 못하고 알고리즘을 갈아엎었다어차피 기존의 알고리즘으로는 시간초과가 나기 때문 ㅠㅠ 두 가지 배운 점 뒤집는 행위를 O(n)이 아닌 O(1)로 해야 했다.고로 뒤집는 행위를 그냥 하나의 boolean 값 변경으로 생각하고, 앞에서 빼는 행위를 boolean 값에 따라 앞/뒤에서 빼면 됐다.즉, 이 문제가 Deque 형태의 문제였던 것.. 을 2시간 후에야 이해했다 C++로 “[10,2,30,4]” 와 같은 형태의 input을 받고 인식하는 것은생각보다 굉장히 더러웠다.직접적으로 comma를 구분하여 받는 getline 등을 이용하는 방법도 있지만굉장히 복잡하고 외울(써먹을) 자신도 없었다 의 scanf을 이용하여 좀 더 범용성 좋게 받을 수도 있었다단, 이 경우에는 Enter가 buffer에 남아있는 등의 문제를 좀 손봐주어야 한단다필자는 그냥 통째로 string으로 입력받고, 이후 한칸씩 뜯어가며 변환하는 방법을 택했다이 경우에는, 두 자리 이상의 숫자를 따로 처리해 주어야 한다","link":"/2020/07/15/2020-07-15-Baekjoon-5430/"},{"title":"Baekjoon 11401 (이항계수 3)","text":"Baekjoon 11401, 백준 11401 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;long long int multiply_split(long long int a, long long int b, long long int c) { // a^b = ? (mod c) if(b == 0) return 1; if(b%2 == 1) return ((a%c) * (multiply_split(a, b/2, c)) % c * (multiply_split(a, b/2, c) % c)) % c; else return ((multiply_split(a, b/2, c) % c) * (multiply_split(a, b/2, c) % c)) % c;}int main() { long long int N, K; cin &gt;&gt; N &gt;&gt; K; long long int DIVIDER = 1000000007; vector&lt;long long int&gt; index_factorial; index_factorial.push_back(1); // 0! = 1 long long int val = 1; for(long long int i = 1; i &lt;= N; i++){ val = (val * i) % DIVIDER; index_factorial.push_back(val); } long long int temp1 = (index_factorial[K] * index_factorial[N-K]) % DIVIDER; long long int temp2 = multiply_split(temp1, DIVIDER-2, DIVIDER) % DIVIDER; long long int temp3 = (index_factorial[N] * temp2) % DIVIDER; cout &lt;&lt; temp3 &lt;&lt; '\\n';}“페르마의 소정리”를 이용하는 문제였다. (너무 오랜만이 아닌가..)a^(p-1) = 1 (mod p) 이며, 따라서 a^(p-2) = a^(-1) (mod p) 의 아이디어를 사용한다.거듭제곱은 분할정복으로 처리.1부터 N까지의 팩토리얼 값들이 저장된 index를 아예 O(N)으로 만들고, 갖다 쓰는 것이 아이디어.","link":"/2020/07/22/2020-07-22-Baekjoon-11401/"},{"title":"Baekjoon 1629 (곱셈)","text":"Baekjoon 1629, 백준 1629 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기123456789101112131415#include &lt;iostream&gt;using namespace std;long long multiply_split(long long a, long long b, long long c) { // a^b = ? (mod c) if(b == 0) return 1; if(b%2 == 1) return ((a%c) * (multiply_split(a, b/2, c)) % c * (multiply_split(a, b/2, c) % c)) % c; else return ((multiply_split(a, b/2, c) % c) * (multiply_split(a, b/2, c) % c)) % c;}int main() { long long A, B, C; cin &gt;&gt; A &gt;&gt; B &gt;&gt; C; cout &lt;&lt; multiply_split(A, B, C) &lt;&lt; '\\n';}문제 보고 바로 분할정복이 (다행히) 떠오른 케이스.a^b = ? (mod c) 를 구하는 문제인데, b를 홀 짝으로 나누어 절반씩 분할정복하면 된다.생각보다 % c 를 곳곳에 써주어야 해서 쓸데없이 많이 틀렸던 문제.","link":"/2020/07/22/2020-07-22-Baekjoon-1629/"},{"title":"Baekjoon 2749 (피보나치 수 3)","text":"Baekjoon 2749, 백준 2749 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int N = 2;vector&lt;vector&lt;long long&gt;&gt; multiply_matrix(vector&lt;vector&lt;long long&gt;&gt; &amp;v1, vector&lt;vector&lt;long long&gt;&gt; &amp;v2) { // calculate v1 * v2 vector&lt;vector&lt;long long&gt;&gt; ans; for(int i = 0; i &lt; N; i++){ vector&lt;long long&gt; temp; for(int j = 0; j &lt; N; j++){ long long int val = 0; for(int k = 0; k &lt; N; k++){ val += ((v1[i][k] % 1000000) * (v2[k][j] % 1000000)) % 1000000; } val %= 1000000; temp.push_back(val); } ans.push_back(temp); } return ans;}vector&lt;vector&lt;long long&gt;&gt; pow_matrix(vector&lt;vector&lt;long long&gt;&gt; &amp;v, long long int B){ if(B == 1) { for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; N; j++){ v[i][j] %= 1000000; } } return v; } else if(B % 2 == 0) { vector&lt;vector&lt;long long&gt;&gt; temp1 = pow_matrix(v, B/2); vector&lt;vector&lt;long long&gt;&gt; temp2 = multiply_matrix(temp1, temp1); return temp2; } else { vector&lt;vector&lt;long long&gt;&gt; temp1 = pow_matrix(v, B/2); vector&lt;vector&lt;long long&gt;&gt; temp2 = multiply_matrix(temp1, temp1); vector&lt;vector&lt;long long&gt;&gt; temp3 = multiply_matrix(v, temp2); return temp3; }}int main() { long long int n; cin &gt;&gt; n; // input array [[1,1],[1,0]] vector&lt;vector&lt;long long&gt;&gt; arr; vector&lt;long long&gt; temp; temp.push_back(1); temp.push_back(1); arr.push_back(temp); temp.pop_back(); temp.push_back(0); arr.push_back(temp); // multiply if(n &lt;= 1) { cout &lt;&lt; n &lt;&lt; '\\n'; return 0; } vector&lt;vector&lt;long long&gt;&gt; ans; ans = pow_matrix(arr, n-1); // print cout &lt;&lt; ans[0][0] &lt;&lt; '\\n';}피보나치 수를 [ [1, 1] , [1, 0] ] 의 2 * 2 행렬의 거듭제곱으로 구할 수 있음을 이용하였다!행렬은 기본적으로 vector","link":"/2020/07/22/2020-07-29-Baekjoon-2749/"},{"title":"Baekjoon 2261 (가장 가까운 두 점)","text":"Baekjoon 2261, 백준 2261 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct Point { int x, y;};int distance(Point&amp; p, Point&amp; q) { return (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);}bool compare_x(Point&amp; p, Point&amp; q){ return (p.x &lt; q.x);}bool compare_y(Point&amp; p, Point&amp; q){ return (p.y &lt; q.y);}int findMin(vector&lt;Point&gt;::iterator it, int n){ // when n=2 or n=3 if(n==2) return distance(it[0], it[1]); if(n==3) return min( {distance(it[0], it[1]), distance(it[1],it[2]), distance(it[2],it[0])}); // else // set the middle line and divide-and-conquer // 3 cases: left side / right side / including the line int line = (it[n/2 - 1].x + it[n/2].x) / 2; // middle line int minDistance = min(findMin(it, n/2), findMin(it + n/2, n - n/2)); // left side &amp; right side // including the line vector&lt;Point&gt; middle; middle.reserve(n); // push_back points which distances from line is lower than minDistance // only consider these points for(int i = 0; i &lt; n; i++){ int temp = line -it[i].x; if( temp * temp &lt; minDistance) middle.push_back(it[i]); } // sort by y-value sort(middle.begin(), middle.end(), compare_y); // keypoint: if the difference of y-value gets larger than minDistance, you don't need to consider the left points int size = middle.size(); for(int i = 0; i &lt; size - 1; i++){ for(int j = i + 1; j &lt; size &amp;&amp; (middle[j].y - middle[i].y) * (middle[j].y - middle[i].y) &lt; minDistance; j++) { minDistance = min(minDistance, distance(middle[i], middle[j])); } } return minDistance;}int main() { // input n int n; scanf(&quot;%d&quot;,&amp;n); // make Point vector and get input vector&lt;Point&gt; vec(n); for(vector&lt;Point&gt;::iterator it = vec.begin(); it != vec.end(); it++) { scanf(&quot;%d %d&quot;, &amp;it-&gt;x, &amp;it-&gt;y); } // sort by x-value sort(vec.begin(), vec.end(), compare_x); // print printf(&quot;%d\\n&quot;, findMin(vec.begin(), n));}굉장히 아이디어가 어렵다고 들어, 시작할 때 알고리즘을 참고하였다.알고리즘의 이해는 이 게시글을 참고하였으며,시간 절약을 위해 코드의 전반적인 틀은 이 사이트를 참고하였다.","link":"/2020/08/04/2020-08-04-Baekjoon-2261/"},{"title":"Baekjoon 6549 (히스토그램에서 가장 큰 직사각형)","text":"Baekjoon 6549, 백준 6549 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stack&gt;using namespace std;int n;long long int arr[100002];int main() { while(true) { scanf(&quot;%d&quot;,&amp;n); // ending program if(n == 0) break; // initialization for(int i = 0; i &lt; 100002; i++){ arr[i] = 0; } // input histogram for(int i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;,&amp;arr[i]); } // solution using &lt;stack&gt; stack&lt;int&gt; s; long long int ans = 0; for (int i = 0; i &lt; n; i++) { // first step : fill the stack until the last one while(!s.empty() &amp;&amp; arr[s.top()] &gt; arr[i]) { long long int height = arr[s.top()]; s.pop(); int width = i; if (!s.empty()) { width = (i - s.top() - 1); } if (ans &lt; width*height) { ans = width*height; } } s.push(i); } // second step : when first step finished but the stack is not empty while(!s.empty()) { long long int height = arr[s.top()]; s.pop(); long long int width = n; if (!s.empty()) { width = n-s.top()-1; } if (ans &lt; width*height) { ans = width*height; } } printf(&quot;%lld\\n&quot;,ans); }}직접 풀어보겠다고 하다가 제대로 고생한 문제.시간 초과 2회, 메모리 초과 8회, 틀렸습니다 2회를 거치고 맞은 전설적인 문제다.알고리즘이 시간복잡도를 넘어감을 깨닫고 갈아엎은것만 세 번..분할정복을 사용하기 위해서는 최솟값을 O(N)이 아닌 O(logN)으로 찾는 알고리즘이 필요한데아직 배우지 않아 포기하였다. (삽질했다는 뜻)결국 스택을 이용하여 다시 풀었다.스택을 이용하는 알고리즘은 이 게시글을 참고하였다.","link":"/2020/08/04/2020-08-04-Baekjoon-6549/"},{"title":"The Master Method","text":"분할정복에 대하여 공부하던 도중, 점화식 형태로 시간복잡도 식이 나타날 때이 시간복잡도를 계산할 수 있는 공식을 알게 되었다. 마스터 정리, The Master Method구하고자 하는 경우의 시간복잡도 T(n)이 다음과 같이 표현된다고 하자. T(n) \\, = \\, O(1) \\qquad \\qquad \\qquad \\quad if \\; n \\, = \\, 1\\qquad \\; \\, = \\, a \\, T(n/b) \\, + \\, f(n) \\qquad otherwise조건: $ a \\, \\geq \\, 1, \\, b \\, \\geq \\, 1 $ , $f(n)$은 점근적으로 양수 함수값을 가지는 함수 다음과 같은 경우에 대해 시간복잡도 계산이 가능하다! 어떤 상수 $ \\epsilon \\, &gt; \\, 0 \\, $에 대해 $ f(n) \\in O(n^{\\log_b a-\\epsilon}) $ 이면, $ T(n) \\in O(n^{\\log_b a}) $ 이다. 만약 $ f(n) \\in O(n^{\\log_b a}) $ 이면, $ T(n) \\in O(n^{\\log_b a} \\, \\log n) $ 이다. 만약 어떤 상수 $ \\epsilon \\, &gt; \\, 0 $ 에 대해 $ f(n) \\in \\Omega (n^{\\log_b a+\\epsilon}) $ 이고, $ c \\, &lt; \\, 1 $ 과 충분히 큰 $n$에 대해 $af({n \\over b}) \\leq cf(n) $ 이 성립하면, $ T(n) \\in O(f(n)) $ 이다.","link":"/2020/08/10/2020-08-10-Master-Method/"},{"title":"Binary Search, Paramametric Search","text":"이분 탐색 (Binary Search)이분 탐색은 이름 그대로 탐색 알고리즘의 종류이다.포인트는, “필요 없는 부분은 쳐다보지 않아” 시간을 줄인다. 주요 조건으로는, 정렬이 되어있어야 한다. 보통 정보들은 정렬이 되어 있지 않기 때문에, 입력을 받고 정렬을 해주어야 하는데, 이 경우 정렬 알고리즘으로 O(logN)이 소요된다.(필자는 주로 &lt;algorithm&gt;의 sort 를 사용함) 따라서, 하나씩 다 확인해 보는 기존의 탐색 알고리즘 O(N)을 O(logN)으로 줄이면,전체 O(logN)으로 탐색을 할 수 있다. 알고리즘의 핵심은, “정렬 기준과 중앙 기준값”을 잘 설정해 주는 것이다. 보통의 이분 탐색 문제에서는 정말 중앙(middle = left + right / 2)을 고르면 된다. 1 2 3 4 5 6 에서 5를 탐색하는 알고리즘을 짜자. (정렬되어있음)기존 1 ~ 6 중 중앙인 3을 선택한다.찾고자 하는 5 는 3 보다 크기 때문에, 탐색 범위를 4 ~ 6 으로 좁힌다.우리는 범위 1 ~ 3 을 생각할 필요가 없다! (시간복잡도 감소) 단계가 총 $log_2(N)$ 개 이므로, O(logN)의 시간복잡도로 탐색이 가능하다. 파라매트릭 서치 (Parametric Search)이분 탐색과 매우 유사한 파라매트릭 서치 (Parametric Search) 도 함께 알아보자.이는 이분 탐색을 응용하여 최솟값이나 최댓값을 구하는 알고리즘이다. 이분 탐색의 알고리즘과 같이 범위를 기준 중앙값에 따라 logN으로 좁혀 간다.단, 이분탐색은 주로 작다/크다 를 확인하는 반면, 파라매트릭 서치에서는 주로 가능하다/불가능하다 를 확인한다. ( &lt;- 파라매트릭 서치의 핵심 )가능한 것들만을 모은다면, 그 중 최소/최대 값이 가능한 최소/최대 값이 되는 것이다. 이분탐색과 파라매트릭 서치 문제에서는어떠한 방식으로 정렬을 하고,어떠한 방식으로 기준 중앙값을 놓고,그 기준 중앙값과 찾고자 하는 경우를 어떻게 비교해 가며 범위를 좁혀나갈 것인지가핵심 포인트라고 생각한다.","link":"/2020/08/12/2020-08-12-Binary-Search/"},{"title":"Baekjoon 1920 (수 찾기)","text":"Baekjoon 1920, 백준 1920 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int N, M;void Binary_Search(int* arr, int target) { // arr should be sorted int left = 0, right = N - 1; while(left &lt;= right) { int middle = (left + right) / 2; if(arr[middle] &gt; target) { right = middle - 1; continue; } else if(arr[middle] &lt; target) { left = middle + 1; continue; } else if(arr[middle] == target) { printf(&quot;1\\n&quot;); return; } } // target doesn't exist in arr printf(&quot;0\\n&quot;);}int main() { // get inputs scanf(&quot;%d&quot;,&amp;N); int* arr = new int[N]; for(int i = 0; i &lt; N; i++){ scanf(&quot;%d&quot;,&amp;arr[i]); } scanf(&quot;%d&quot;,&amp;M); int* brr = new int[M]; for(int i = 0; i &lt; M; i++){ scanf(&quot;%d&quot;,&amp;brr[i]); } // sort array sort(arr, arr+N); // Binary Search for(int i = 0; i &lt; M; i++){ Binary_Search(arr, brr[i]); } delete[] arr; delete[] brr;}가장 기본적인 이분 탐색 문제!","link":"/2020/08/15/2020-08-15-Baekjoon-1920/"},{"title":"Baekjoon 10816 (숫자 카드 2)","text":"Baekjoon 10816, 백준 10816 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int N, M;int Upper_Bound(int* arr, int target) { int upper_bound = -1; int left = 0, right = N-1; while(left &lt;= right) { int middle = (left + right) / 2; if(arr[middle] &gt; target) { right = middle - 1; continue; } else if(arr[middle] &lt; target) { left = middle + 1; continue; } else if(arr[middle] == target) { upper_bound = middle; left = middle + 1; continue; } } return upper_bound;}int Lower_Bound(int* arr, int target) { int lower_bound = -1; int left = 0, right = N-1; while(left &lt;= right) { int middle = (left + right) / 2; if(arr[middle] &gt; target) { right = middle - 1; continue; } else if(arr[middle] &lt; target) { left = middle + 1; continue; } else if(arr[middle] == target) { lower_bound = middle; right = middle - 1; continue; } } return lower_bound;}int main() { // get inputs scanf(&quot;%d&quot;,&amp;N); int* arr = new int[N]; for(int i = 0; i &lt; N; i++){ scanf(&quot;%d&quot;,&amp;arr[i]); } scanf(&quot;%d&quot;,&amp;M); int* brr = new int[M]; for(int i = 0; i &lt; M; i++){ scanf(&quot;%d&quot;,&amp;brr[i]); } // sort array sort(arr, arr+N); // Binary Search for(int i = 0; i &lt; M; i++){ int upper = Upper_Bound(arr, brr[i]); int lower = Lower_Bound(arr, brr[i]); if(upper == -1) printf(&quot;0 &quot;); // brr[i] doesn't exist in arr else printf(&quot;%d &quot;, upper - lower + 1); } delete[] arr; delete[] brr;}이분 탐색을 응용하는 문제!특정 숫자의 개수를 확인하는 방법이다. 정렬을 한 후, 그 숫자 중 가장 작은 index(lower_bound)와 큰 index(upper_bound)를 구하여upper_bound - lower_bound + 1 로 개수를 구하는 아이디어.","link":"/2020/08/15/2020-08-15-Baekjoon-10816/"},{"title":"Baekjoon 12015 (가장 긴 증가하는 부분 수열2)","text":"Baekjoon 12015, 백준 12015 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main() { // put inputs int N; scanf(&quot;%d&quot;,&amp;N); int* arr = new int[N]; for(int i = 0; i &lt; N; i++){ scanf(&quot;%d&quot;,&amp;arr[i]); } // use LIS vector vector&lt;int&gt; LIS; LIS.push_back(0); int len = 0; for(int i = 0; i &lt; N; i++){ // if next arr number is bigger than the biggest value in LIS if(arr[i] &gt; LIS.back()){ // push back(update) LIS.push_back(arr[i]); len++; } // if not: switch this value in the alright place else { // find the lower bound and switch: Binary Search int left = 0, right = LIS.size(), middle; while(left &lt; right) { middle = (left + right) / 2; if(LIS[middle] &lt; arr[i]) left = middle + 1; else right = middle; } LIS[right] = arr[i]; } } printf(&quot;%d\\n&quot;,len);}의외로 이분 탐색으로 풀 수 있는 문제 2번. 굉장히 알고리즘이 어려워, 스스로 생각하지는 못했다.인터넷에 다양한 알고리즘들이 올라와 있었는데, 그 중 가장 와닿는 방법으로 문제를 해결하였다. 새로운 LIS vector를 만들어, 조건에 따라 값을 vector의 적절한 위치에 넣는데,넣는 과정에서 이분 탐색을 사용하는 것이 매우 인상적이었다.","link":"/2020/08/18/2020-08-18-Baekjoon-12015/"},{"title":"Baekjoon 1300 (K번째 수)","text":"Baekjoon 1300, 백준 1300 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;long long int N;int k;int main() { scanf(&quot;%d&quot;,&amp;N); scanf(&quot;%d&quot;,&amp;k); long long int count = 0; long long int left = 1, right = N * N; long long int middle, answer; while(left &lt;= right) { count = 0; middle = (left + right) / 2; // count how many numbers are lower than middle for(long long int i = 1; i &lt;= N; i++){ count += min(N, middle/i); } if(count &lt; k){ left = middle + 1; } else if(count &gt;= k) { // the answer should be the minimum value answer = middle; right = middle - 1; } } printf(&quot;%lld\\n&quot;,answer);의외로 이분 탐색으로 풀 수 있는 문제 1번. B[k], 즉 k번째로 작은 숫자를 찾기 위해서는 어떠한 작은 숫자의 개수를 count하면 된다. (k개 이상이 되는 순간을 찾으면 된다) 이 과정에서 이분 탐색을 사용하여 해결하였다.","link":"/2020/08/18/2020-08-18-Baekjoon-1300/"},{"title":"Baekjoon 1654 (랜선 자르기)","text":"Baekjoon 1654, 백준 1654 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int K, N;int main() { // get inputs scanf(&quot;%d %d&quot;, &amp;K, &amp;N); long long int* arr = new long long int[K]; for(int i = 0; i &lt; K; i++){ scanf(&quot;%lld&quot;,&amp;arr[i]); } // sort input array sort(arr, arr+K); // Binary Search long long int left, right, middle, answer = 0; left = 1, right = arr[K-1]; while(left &lt;= right) { long long int count = 0; middle = (left + right) / 2; for(int i = 0; i &lt; K; i++){ count += (arr[i]/middle); } if(count &lt; N) right = middle - 1; else if(count &gt;= N) { if(middle &gt; answer) answer = middle; left = middle + 1; } } printf(&quot;%lld\\n&quot;, answer); delete[] arr;}이분 탐색을 응용하는 파라매트릭 서치(Parametric Search)의 가장 기본적인 문제!","link":"/2020/08/18/2020-08-18-Baekjoon-1654/"},{"title":"Baekjoon 2110 (공유기 설치)","text":"Baekjoon 2110, 백준 2110 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std; int N, C;int main() { // get inputs scanf(&quot;%d %d&quot;, &amp;N, &amp;C); long long int* arr = new long long int[N]; for(int i = 0; i &lt; N; i++){ scanf(&quot;%lld&quot;,&amp;arr[i]); } // sort input array sort(arr, arr+N); // Binary Search long long int left, right, middle, answer = 0; int temp, next, count; left = 1, right = arr[N-1] - arr[0]; while(left &lt;= right) { middle = (left + right) / 2; temp = 0, next = 1, count = 1; // check if this case is possible while(next &lt; N){ if(arr[next] - arr[temp] &lt; middle) { // shouldn't place next++; } else if(arr[next] - arr[temp] &gt;= middle) { // place temp = next; next++; count++; } } if(count &gt;= C) { // okay, but should check more answer = middle; left = middle + 1; } else if(count &lt; C){ // need to place more right = middle - 1; } } printf(&quot;%lld\\n&quot;, answer); delete[] arr;}이분탐색을 응용한 Parametric Search 의 응용 문제.어떠한 방식으로 이분 탐색을 진행할 것인지가 핵심이었다.","link":"/2020/08/18/2020-08-18-Baekjoon-2110/"},{"title":"Baekjoon 11286 (절댓값 힙)","text":"Baekjoon 11286, 백준 11286 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;int main() { // use priority_queue priority_queue&lt;pair&lt;int, int&gt;&gt; pq; // first: -abs(number), second: 1 or -1 =&gt; original number: first * second // why? default is greater&lt;int&gt; : big values come first int N, num; scanf(&quot;%d&quot;, &amp;N); for(int i = 0; i &lt; N; i++) { scanf(&quot;%d&quot;, &amp;num); if(num == 0) { if(pq.empty()) { printf(&quot;0\\n&quot;); } else { // queue is not empty printf(&quot;%d\\n&quot;, pq.top().first * pq.top().second); pq.pop(); } } else { if(num &lt; 0) pq.push({num, 1}); else pq.push({-num, -1}); } }}직접 배열로 절댓값 힙을 구현한 결과, 시간 초과와 마주하였다.(너무 많은 if문이 그 요인이라고 판단된다) 따라서, 우선순위 큐 (priority_queue) 를 사용하여 문제를 해결하였다.큐에 pair&lt;int, int&gt;를 넣어 하나를 절댓값, 하나를 부호로 사용하였다! 실제 값을 출력해 주어야 하기 때문에, 그 정보를 잃어서는 안된다.본 경우에선 두 int 값을 곱하면 (first * second) 실제 값을 얻을 수 있었다.","link":"/2020/08/25/2020-08-25-Baekjoon-11286/"},{"title":"Baekjoon 1655 (가운데를 말해요)","text":"Baekjoon 1655, 백준 1655 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;int main() { int N; // make two priority queues: max and min // max_pq is less&lt;int&gt;, min_pq is greater&lt;int&gt; // every numbers in min_pq are bigger than every numbers in max_pq // every time, max_pq.size() should be same or 1 bigger than min_pq.size() priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; max_pq; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; min_pq; scanf(&quot;%d&quot;,&amp;N); while(N--) { // get input int num; scanf(&quot;%d&quot;, &amp;num); // push num if(max_pq.size() == min_pq.size()) { max_pq.push(num); } else min_pq.push(num); // sort if(!min_pq.empty() &amp;&amp; max_pq.top() &gt; min_pq.top()) { // swap the two top values int min_temp = min_pq.top(); int max_temp = max_pq.top(); min_pq.pop(); max_pq.pop(); min_pq.push(max_temp); max_pq.push(min_temp); } // print middle value: top of max_pq printf(&quot;%d\\n&quot;, max_pq.top()); }}Priority Queue 하나로는 해결할 수 없었다.&lt;queue&gt;의 경우에는 정렬이 잘 되어 있다 한들, 직접 index로 참조할 수 있는 방법이 없기 때문이다.( top 과 back 만 값을 읽어올 수 있다. 중간 값 못 읽어온다 ) 직접 배열로 Heap을 만들어서도 해결할 수 없다.Heap의 경우 배열 자체가 정확히 오름차순 정렬이 된 것이 아니기 때문이다.( 예로, heap[3] &gt; heap[4] 를 보장할 수 없다 ) 본 문제는 Priority Queue 두 개를 사용하는 것이 일반적인 풀이였다.min_pq, max_pq 의 두 개의 Queue를 사용하여가운데 값이 max_pq의 top이 되도록 하였다! 필자는 두 개의 Queue를 사용하라는 힌트를 듣고 아하! 하고 바로 해결하였다.굉장히 간단하면서도 인상적인 알고리즘이었다.","link":"/2020/08/25/2020-08-25-Baekjoon-1655/"},{"title":"Baekjoon 1927 (최소 힙)","text":"Baekjoon 1927, 백준 1927 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define SWAP(a,b,type) do{ \\ type temp; \\ temp=a; \\ a=b; \\ b=temp; \\}while(0)using namespace std;// make heaplong long int arr[100002] = {0,};int size = 0;// input numbervoid push_heap(long long int x){ // put number in the back size++; arr[size] = x; // sort the heap int child = size, parent = child/2; while(parent &gt;= 1) { if(arr[child] &lt; arr[parent]){ SWAP(arr[child], arr[parent], long long int); child /= 2; parent = child/2; } else break; }}// pop min numbervoid pop_heap(){ if(size == 0) { printf(&quot;0\\n&quot;); return; } long long int min_num = arr[1]; arr[1] = arr[size]; arr[size] = 0; size--; // copy the last value to the top, and delete // sort heap int parent = 1; while(parent * 2 &lt;= size) { // compare the parent node with two childs // you should have two childs if(arr[parent] &gt; min(arr[parent*2], arr[parent*2 +1]) &amp;&amp; arr[parent*2+1] != 0 ) { // swap with the smaller child if(arr[parent*2] &lt; arr[parent*2+1]) { SWAP(arr[parent], arr[parent*2], long long int); parent = parent * 2; } else { SWAP(arr[parent], arr[parent*2+1], long long int); parent = parent * 2 + 1; } } // if you have only one child else if(arr[parent] &gt; arr[parent*2] &amp;&amp; arr[parent*2+1] == 0 ) { SWAP(arr[parent], arr[parent*2], long long int); parent = parent * 2; } else break; } // print min number printf(&quot;%lld\\n&quot;,min_num);}int main() { int N; scanf(&quot;%d&quot;,&amp;N); long long int brr[N]; for(int i = 0; i &lt; N; i++){ scanf(&quot;%lld&quot;,&amp;brr[i]); if(brr[i]==0) pop_heap(); else push_heap(brr[i]); }}최소 Heap을 배열을 이용하여 직접 구현하여 해결한 우선순위-큐 문제.","link":"/2020/08/25/2020-08-25-Baekjoon-1927/"},{"title":"Baekjoon 11066 (파일 합치기)","text":"Baekjoon 11066, 백준 11066 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;using namespace std;int arr[501];int sum[501]; // sum[i] = arr[1] + ... + arr[i]int dp[501][501]; // dp[i][j] : min value for combining arr[i] to arr[j]int main() { // Solution by Dynamic Programming // K &lt;= 500, so O(N^3) is okay (500^3 ~ 10^8) int T, K; scanf(&quot;%d&quot;,&amp;T); while(T--){ scanf(&quot;%d&quot;,&amp;K); for(int i = 1; i &lt;= K; i++){ scanf(&quot;%d&quot;,&amp;arr[i]); sum[i] = sum[i-1] + arr[i]; } // dp[i][i] = 0, dp[i][i+1] = 0 ( values added by sum ) // dp[i][j] = minimum of dp[i][k] + dp[k+1][j] + arr[i] + ... + arr[j] // = minimum of dp[i][k] + dp[k+1][j] + sum[j] - sum[i-1] // get the value dp[i][i+d] for(int d = 1; d &lt; K; d++){ for(int i = 1; i+d &lt;= K; i++){ dp[i][i+d] = INT_MAX; for(int temp = i; temp &lt; i + d; temp++){ dp[i][i+d] = min(dp[i][i+d], dp[i][temp] + dp[temp+1][i+d] + sum[i+d] - sum[i-1]); } } } printf(&quot;%d\\n&quot;, dp[1][K]); }}dp 배열을 알맞게 2차원 배열로 두고,조건에 맞게 새로 update, overwrite 하는 기본적인 동적계획법 문제였다. K가 500 까지였는데, 500이 굉장히 힌트가 되는 숫자이다.$500^3$ 이 약 $10^8$과 비슷하며, $10^8$ 개의 연산이 약 1초가 걸리는 것을 생각하자. $ N \\leq 500 $ 의 힌트는, 시간복잡도가 $O(N^3)$ 까지 가능하다는 힌트를 준 것이다.즉, 위의 방식의 동적계획법의 타당성을 어느 정도 얻는다.","link":"/2020/09/01/2020-09-01-Baekjoon-11066/"},{"title":"Baekjoon 2293 (동전 1)","text":"Baekjoon 2293, 백준 2293 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main() { int n, k; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); int* coins = new int[n]; for(int i = 0; i &lt; n; i++){ scanf(&quot;%d&quot;,&amp;coins[i]); } // Solution by Dynamic Programming int dp[10001] = {0,}; dp[0] = 1; // initialization // overwrite array dp while increasing coin types for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt;= k; j++) { if(coins[i] &lt;= j) // use dp[0]=1 dp[j] += dp[j-coins[i]]; } } printf(&quot;%d\\n&quot;, dp[k]); delete[] coins;}오랜만에 동적 계획법 (Dynamic Programming) 문제를 접하게 되었다.dp[i] 를 i 원을 만들 수 있는 방법의 수로 놓고, 동전 종류를 한 개씩 늘려가면서 추가되는 방법들을 덮어쓰는(overwrite) 방식으로 해결하였다. 동적 계획법 문제의 경우에는 dp 배열을 생각보다 굉장히 단순히 설정하고,어떻게 그 배열의 값들을 update 해줄까가 문제의 핵심이 되는 것 같다.","link":"/2020/09/01/2020-09-01-Baekjoon-2293/"},{"title":"Baekjoon 10942 (팰린드롬?)","text":"Baekjoon 10942, 백준 10942 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int arr[2002];// dp[S][E]: check if arr[S] to arr[E] is pelindrome// dp = -1 : not visited, 0 : not pelindrome, 1 : pelindromeint dp[2002][2002];void func(int S, int E){ int s = S, e = E; while(s &lt;= e &amp;&amp; s &gt;= S &amp;&amp; e &lt;= E){ // one number : pelindrome if( s == e ) { dp[s][e] = 1; s--; e++; continue; } // adjacent number : should be same else if( e - s == 1 ){ if(arr[s] == arr[e]) { dp[s][e] = 1; s--; e++; continue; } else { dp[s][e] = 0; s--; e++; continue; } } // if we already visited dp[s][e], break else if(dp[s][e] != -1) break; // if we don't know dp[s+1][e-1] either else if(dp[s+1][e-1] == -1){ s++; e--; continue; } // if arr[S+1] to arr[E-1] is pelindrome and arr[S]==arr[E], arr[S] to arr[E] is pelindrome else if( dp[s+1][e-1] == 1 &amp;&amp; arr[s] == arr[e]) { dp[s][e] = 1; s--; e++; continue; } // else: not pelindrome else { dp[s][e] = 0; s--; e++; continue; } } // print if(dp[S][E] == 1) printf(&quot;1\\n&quot;); else if(dp[S][E] == 0) printf(&quot;0\\n&quot;);}int main() { // input int N, M; scanf(&quot;%d&quot;,&amp;N); for(int i = 1; i &lt;= N; i++){ scanf(&quot;%d&quot;,&amp;arr[i]); } scanf(&quot;%d&quot;,&amp;M); // solution memset(dp, -1, sizeof(dp)); // original value of dp is all -1 while(M--){ int S, E; scanf(&quot;%d %d&quot;, &amp;S, &amp;E); func(S, E); }}마찬가지로 dp 배열의 -1 값을 통해 방문 여부를 따졌다.이번에는 memset(dp, -1, sizeof(dp))를 이용하여 dp의 초기값을 -1로 설정해 보았다.memset 을 이용하기 위해서는 #include &lt;cstring&gt; 을 해야 한다는 점을 잊어서는 안 된다. dp[i][j] 를 ‘ i 부터 j 까지가 팰린드롬인가? ‘ 를 확인하는 배열로 두고,팰린드롬의 귀납적 성질 ( 양끝 값이 같고, 그 사이가 팰린드롬이면 전체도 팰린드롬이다 ) 을 이용하여 해결한전형적인 동적계획법 문제였다.","link":"/2020/09/03/2020-09-03-Baekjoon-10942/"},{"title":"Baekjoon 1520 (내리막 길)","text":"Baekjoon 1520, 백준 1520 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;using namespace std;int M, N;int map[502][502] = {0,};int dp[502][502] = {0,}; // number of cases from map[i][j] to endint func(int i, int j){ // starts from map[i][j] // Dynamic Programming: if already value exists, use it if(dp[i][j] != -1){ // dp[i][j] = -1 : not visited return dp[i][j]; } else { dp[i][j] = 0; if(map[i+1][j] &lt; map[i][j] &amp;&amp; i+1 &lt;= M) { // move to map[i+1][j] dp[i][j] += func(i+1, j); } if(map[i-1][j] &lt; map[i][j] &amp;&amp; i-1 &gt;= 1){ // move to map[i-1][j] dp[i][j] += func(i-1, j); } if(map[i][j+1] &lt; map[i][j] &amp;&amp; j+1 &lt;= N){ // move to map[i][j+1] dp[i][j] += func(i, j+1); } if(map[i][j-1] &lt; map[i][j] &amp;&amp; j-1 &gt;= 0){ // move to map[i][j-1] dp[i][j] += func(i, j-1); } } return dp[i][j];}int main() { scanf(&quot;%d %d&quot;, &amp;M, &amp;N); for(int i = 1; i &lt;= M; i++){ for(int j = 1; j &lt;= N; j++){ scanf(&quot;%d&quot;, &amp;map[i][j]); dp[i][j] = -1; } } // start from map[1][1] // find every cases dp[M][N] = 1; int answer = func(1,1); printf(&quot;%d\\n&quot;, answer);}동적계획법 문제로, 새로운 아이디어가 접목되었다.dp 배열의 값 설정을 통해 “방문 여부”를 따지는 아이디어이다.실제로 방문 여부를 따지지 않고 코드를 짜면, 시간 초과가 발생하였다. 본 코드에서는 처음 dp 배열을 -1 로 초기화하였고, 이를 “방문하지 않았다”는 것의 여부로 사용하였다.즉 dp != -1 이라면 이미 한 번 방문한 적이 있는 칸이라는 것이다. 특별한 조치를 하지 않는다면 전역 변수로 선언한 dp 배열은 0으로 초기화가 될 것이며,이는 “아직 값을 계산하지 않아서 0” 인 것과, “계산을 해 보았는데 방법의 수가 0”인 것을 구별할 수 없다. 따라서 -1 을 사용하여 이를 구별하고, 시간을 줄여 준다.","link":"/2020/09/03/2020-09-03-Baekjoon-1520/"},{"title":"Baekjoon 1260 (DFS와 BFS)","text":"Baekjoon 1260, 백준 1260 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int map[1002][1002];int visit[1002];int N, M, V;queue&lt;int&gt; q;void dfs(int V){ printf(&quot;%d &quot;, V); // visited V visit[V] = 1; // find next node for(int i = 1; i &lt;= N; i++){ if(map[V][i] == 1 &amp;&amp; visit[i] != 1){ // when V and i is connected but not visited yet, go to i dfs(i); } } // when no deeper node exist, return (recursion)}void bfs(int V){ // use queue // visited V visit[V] = 1; q.push(V); // bfs until end of nodes while(!q.empty()){ // visit front node of q V = q.front(); q.pop(); printf(&quot;%d &quot;, V); for(int i = 1; i &lt;= N; i++){ // check other nodes connected with node V if(map[V][i] == 1 &amp;&amp; visit[i] != 1){ // if connected and not visited yet, push node in queue and check visited q.push(i); visit[i] = 1; } } }}int main() { // put inputs scanf(&quot;%d %d %d&quot;, &amp;N, &amp;M, &amp;V); // initialization memset(visit, 0, sizeof(visit)); memset(map, 0, sizeof(map)); // connection for(int i = 0; i &lt; M; i++){ int input1, input2; scanf(&quot;%d %d&quot;, &amp;input1, &amp;input2); // connect input1 and input2 map[input1][input2] = 1; map[input2][input1] = 1; } // dfs dfs(V); printf(&quot;\\n&quot;); // initialization memset(visit, 0, sizeof(visit)); // bfs bfs(V); printf(&quot;\\n&quot;);}가장 기본적인 DFS, BFS 구현 문제. 일반적으로 DFS는 stack 혹은 재귀를 이용하여 구현, BFS는 queue를 이용하여 구현한다.visit 배열을 이용하여 한 번도 방문하지 않은 node들만 검사해야 한다. 양방향 connection이라면 map에 저장할 때 두 방향 다 넣어주어야 하는 것 조심!","link":"/2020/09/08/2020-09-08-Baekjoon-1260/"},{"title":"Baekjoon 2667 (단자번호 붙이기)","text":"Baekjoon 2667, 백준 2667 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int map[27][27];int visit[27][27];int N, cnt = 0;vector&lt;int&gt; v;void dfs(int x, int y){ // visited V visit[x][y] = 1; cnt++; // find next node if(visit[x+1][y] != 1 &amp;&amp; map[x+1][y] == 1 &amp;&amp; x+1 &lt; N) { dfs(x+1, y); } if(visit[x][y+1] != 1 &amp;&amp; map[x][y+1] == 1 &amp;&amp; y+1 &lt; N) { dfs(x, y+1); } if(visit[x-1][y] != 1 &amp;&amp; map[x-1][y] == 1 &amp;&amp; x-1 &gt;= 0) { dfs(x-1, y); } if(visit[x][y-1] != 1 &amp;&amp; map[x][y-1] == 1 &amp;&amp; y-1 &gt;= 0) { dfs(x, y-1); } // when no deeper node exist, return (recursion)}int main() { // put inputs scanf(&quot;%d&quot;, &amp;N); for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; N; j++){ scanf(&quot;%1d&quot;, &amp;map[i][j]); } } // initialization memset(visit, 0, sizeof(visit)); // dfs for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; N; j++){ if(map[i][j] == 1 &amp;&amp; visit[i][j] != 1) { dfs(i, j); v.push_back(cnt); cnt = 0; } } } // print answer sort(v.begin(), v.end()); printf(&quot;%d\\n&quot;, v.size()); for(auto iter = v.begin(); iter != v.end(); iter++) { printf(&quot;%d\\n&quot;, *iter); }}2차원 배열에서 그래프 탐색을 이용하여 푸는 문제이다.DFS, BFS 아무거나 사용해도 상관없다.","link":"/2020/09/08/2020-09-08-Baekjoon-2667/"},{"title":"Baekjoon 2178 (미로 탐색)","text":"Baekjoon 2178, 백준 2178 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int map[102][102];int visit[102][102];// to check 4 directions by 'for' loopint direction[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1}};int N, M;typedef struct Coord { int x; int y; int dist;};queue&lt;Coord&gt; q;void bfs(){ // use queue // start from (0,0) visit[0][0] = 1; q.push( Coord{0,0,1} ); // bfs until arrival while(!q.empty()){ // visit front node of q Coord temp = q.front(); // if arrived final destination if(temp.x == M-1 &amp;&amp; temp.y == N-1){ printf(&quot;%d\\n&quot;, temp.dist); break; } q.pop(); // check 4 directions for(int i = 0; i &lt; 4; i++){ int next_x = temp.x + direction[i][0]; int next_y = temp.y + direction[i][1]; if(map[next_x][next_y] == 1 &amp;&amp; next_x &gt;= 0 &amp;&amp; next_x &lt; M &amp;&amp; next_y &gt;= 0 &amp;&amp; next_y &lt; N &amp;&amp; visit[next_x][next_y] != 1) { // if valid, push node in queue and check 'visited' visit[next_x][next_y] = 1; q.push( Coord{next_x, next_y, temp.dist + 1} ); } } }}int main() { // put inputs scanf(&quot;%d %d&quot;, &amp;N, &amp;M); // initialization memset(visit, 0, sizeof(visit)); memset(map, 0, sizeof(map)); for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; M; j++){ scanf(&quot;%1d&quot;, &amp;map[j][i]); } } // bfs (solution) bfs();}BFS는 최단 거리를 찾을 때 유용하게 사용한다.(너비 우선 탐색이므로, 가장 빨리 찾아진 solution이 가장 얕은, 즉 최단의 경우이다) 따라서, 미로 탐색에는 BFS를 사용한다. 한 지점에 도달했을 때 다음의 네 방향으로 BFS를 뻗어나갈 때direction[4][2]의 배열을 사용하여 for문으로 유용하게 처리할 수 있었다. (노가다 줄이기) 각 노드를 Coord 라는 구조체로 정의하고 이로 Queue를 만들어 BFS를 진행하였는데,이 Coord에는 좌표 정보와 함께 “지금까지 걸린 거리”의 dist 가 있는 것이 포인트이다. BFS를 진행하면서, dist를 업데이트 해 주며 Queue에 push 하여Queue에 담긴 모든 노드들이, 얼마의 거리만에 온 노드들인지 확인할 수 있다.","link":"/2020/09/10/2020-09-10-Baekjoon-2178/"},{"title":"Baekjoon 1753 (최단 경로)","text":"Baekjoon 1753, 백준 1753 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;#define INF 999999999int V, E, K;int dist[20002]; // dist[i] : minimum distance going to node i, gets updatedvector&lt; pair&lt;int,int&gt; &gt; map[20002]; // connected node information : {to,value}void Dijkstra() { // Dijkstra Algorithm using priority_queue priority_queue&lt; pair&lt;int,int&gt; &gt; pq; pq.push( make_pair(0,K) ); dist[K] = 0; while(!pq.empty()) { int current_node = pq.top().second; int cost = (-1) * pq.top().first; // to use priority_queue as minimum heap pq.pop(); // update values of dist for(int i = 0; i &lt; map[current_node].size(); i++){ int test_node = map[current_node][i].first; int new_cost = cost + map[current_node][i].second; int before_cost = dist[test_node]; // if new_cost &lt; before_cost, update if(new_cost &lt; before_cost) { dist[test_node] = new_cost; pq.push( make_pair(-1 * new_cost,test_node) ); } } }}int main() { // put inputs &amp; initialization scanf(&quot;%d %d&quot;, &amp;V, &amp;E); scanf(&quot;%d&quot;, &amp;K); while(E--){ int from, to, value ; scanf(&quot;%d %d %d&quot;, &amp;from, &amp;to, &amp;value); map[from].push_back(make_pair(to,value)); } for(int i = 1; i &lt;= V; i++) dist[i] = INF; // solution by Dijkstra Algorithm Dijkstra(); // print for(int i = 1; i &lt;= V; i++){ if(dist[i] != INF) printf(&quot;%d\\n&quot;, dist[i]); else printf(&quot;INF\\n&quot;); }} 기본적인 다익스트라 알고리즘 (Dijkstra Algorithm) 의 구현이다.시간복잡도를 줄이기 위해 우선순위큐(priority queue)를 사용하였으며, 우선순위큐를 최소 힙으로 사용하기 위해 첫 번째에 -1을 곱해 주었다. 다익스트라 알고리즘에 대한 이론은 여기에서 확인할 수 있다.","link":"/2020/09/13/2020-09-13-Baekjoon-1753/"},{"title":"Baekjoon 2206 (벽 부수고 이동하기)","text":"Baekjoon 2206, 백준 2206 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int map[1002][1002];int visit[1002][1002]; // 0: not visited, 1: usedWall = false, -1: usedWall = true// to check 4 directions by 'for' loopint direction[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1}};int N, M;typedef struct Coord { int i; int j; bool usedWall; int dist;};queue&lt;Coord&gt; q;bool canArrive = false;void bfs(){ // use queue // start from (0,0) visit[0][0] = 1; q.push( Coord{0,0,false,1} ); // bfs until arrival while(!q.empty()){ // visit front node of q Coord temp = q.front(); // if arrived final destination if(temp.i == N-1 &amp;&amp; temp.j == M-1){ canArrive = true; printf(&quot;%d\\n&quot;, temp.dist); break; } q.pop(); // better case exist (not using breakWall) : delete if(temp.usedWall &amp;&amp; visit[temp.i][temp.j] == 1) continue; // check 4 directions for(int i = 0; i &lt; 4; i++){ int next_i = temp.i + direction[i][0]; int next_j = temp.j + direction[i][1]; if(next_i &gt;= 0 &amp;&amp; next_i &lt; N &amp;&amp; next_j &gt;= 0 &amp;&amp; next_j &lt; M) { // not breaking wall if(map[next_i][next_j] == 0) { // if valid, push node in queue and check 'visited' // not used breakWall if(!temp.usedWall &amp;&amp; visit[next_i][next_j] != 1) { visit[next_i][next_j] = visit[temp.i][temp.j]; q.push( Coord{next_i, next_j, temp.usedWall, temp.dist + 1} ); } // used breakWall else if(temp.usedWall &amp;&amp; visit[next_i][next_j] == 0) { visit[next_i][next_j] = visit[temp.i][temp.j]; q.push( Coord{next_i, next_j, temp.usedWall, temp.dist + 1} ); } } // breaking wall if(map[next_i][next_j] == 1 &amp;&amp; !temp.usedWall &amp;&amp; visit[next_i][next_j] == 0) { visit[next_i][next_j] = -1; q.push( Coord{next_i, next_j, true, temp.dist + 1} ); } } } }}int main() { // put inputs scanf(&quot;%d %d&quot;, &amp;N, &amp;M); // initialization memset(visit, 0, sizeof(visit)); memset(map, 0, sizeof(map)); for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; M; j++){ scanf(&quot;%1d&quot;, &amp;map[i][j]); } } // bfs (solution) bfs(); if(!canArrive) printf(&quot;-1\\n&quot;);}기존에 비해 고려할 것이 추가되었던 BFS 미로찾기 문제였다. 우선, 각 노드에 도착했을 때 기존에 ‘벽 부수기’를 썼는지, 쓰지 않았는지를 구별해야 했다.벽 부수기를 쓰고 더 먼저 도착한 노드와, 벽 부수기를 쓰지 않고 더 늦게 도착한 노드가본 문제에서는 모두 고려 대상이기 때문이다. 필자는 visit 함수에 변화를 주어, 기존 0(방문X) / 1(방문) 에서 -1 을 추가하여 각 노드를 세 가지 상태로 두었다. 이를 위해 기존 i 좌표, j 좌표, dist (거리) 의 세 가지 변수가 담기는 Coord에 bool 형태의 usedWall 을 추가하여, ‘벽 부수기’의 사용 여부를 가렸다. 이후에는 침착하게 경우 나누면서 BFS 진행하면 된다.","link":"/2020/09/10/2020-09-10-Baekjoon-2206/"},{"title":"Dijkstra Algorithm","text":"첫 번째로 다루어 볼 SSP( Single Source Shortest Path, 단일 출발지 최단 경로 ) 알고리즘은 다익스트라 알고리즘 ( Dijkstra Algorithm ) 이다. 다익스트라 알고리즘은,음의 가중치가 없는 그래프 에서한 노드에서 다른 모든 노드들까지의 최단 거리 를 구하는 알고리즘이다.(다양한 최단 경로 알고리즘이 있는 만큼, 규칙과 이유를 정확하게 알고 있어야 한다!) 기본적인 원리는 Greedy Algorithm 이다.출발점으로부터의 최단거리를 ‘확실히’ 알고 있는 점들의 집합을 S 라고 두자. 매 단계마다 S의 집합에 포함된 정점들만을 이용하여 갈 수 있는 최단거리의 배열 dist를 업데이트 하고,( dist[i] : i번 노드까지의 최단 거리 ) 이를 이용하여 S 에 한 개씩 정점을 추가한다.노드의 개수가 총 V개라면, V 번의 단계를 거치면 모든 점들의 최단 거리를 구할 수 있다! 따라서, 위와 같은 방법으로 반드시 최단 거리를 찾을 수 있다. 다익스트라 알고리즘을 조금 더 자세히 파헤쳐 보자. dist 배열을 초기화한다. 기본값은 ‘도달하지 못한다’의 무한대 이므로, 적당히 INF = 999999999 정도로 초기화 시켜준다. 출발점을 S에 넣고, S로부터 “한 번만에” 갈 수 있는 모든 점들의 dist를 업데이트한다.출발점과 직접 연결되어 있으면 dist 값이 업데이트될 것이며, 그렇지 않다면 INF로 남아있을 것이다. dist의 값들 중 가장 크기가 작은 점을 뽑아, S에 넣는다.이후, S에 방금 추가한 점으로부터 “한 번만에” 갈 수 있는 모든 점들의 dist를 업데이트한다.이 때, 기존에 노드의 dist 값이 정해져 있다면 더 작은 경우에만 업데이트 해주면 된다. dist의 배열 중 가장 작은 값의 노드를 S에 넣고, 위 과정을 반복하면 된다. ( 참고 : S 집합은 설명을 위해 사용되는 것 뿐이며, 실제 코드 구현에선 하지 않는다 ) 다익스트라 알고리즘의 정당성(Greedy Algorithm의 정당성)을 조금 더 자세히 생각해 보자. S가 주어져 있을 때, S 외부의 한 점 Vi에 대하여 Vi까지의 최단거리는 S의 점들만을 거치거나 S 외부의 점들을 거치는 두 가지 경우 중 하나이다.만약 Vi의 dist 값이 최소여서 Vi를 S에 추가하려 하는데, 현재 dist에 저장된 값보다 S 밖의 점을 거치는 것이 사실 최단 경로였다고 가정해 보자.이 경우, Vi 까지의 경로 중 거치는 S 밖의 점 까지의 거리가 반드시 Vi 까지의 거리보다 작다. 따라서, Vi의 dist 값이 최소라는 가정에 모순이다. 마지막으로, 다익스트라 알고리즘의 시간 복잡도에 대해 생각해 보자. (점 V개, 간선 E개) 위 알고리즘에서는 두 가지 작업이 진행된다. 각 정점마다 인접한 간선들을 모두 조사하여, dist 값을 업데이트 하는 과정. dist 중 최소의 값을 찾아 S에 넣어주는 과정. 기본적으로 과정 1 에서는 $O(E)$, 과정 2에서는 $O(V)$의 시간복잡도가 걸려 총 $O(EV)$의 시간복잡도가 소요된다. 여기서, 우선 순위 큐 (Priority_Queue)를 활용하면 과정 2의 시간복잡도를 $O(log V)$으로 줄일 수 있다.힙 구조를 이용하면, 최소값을 찾는 탐색 과정을 log 의 단위로 해낼 수 있기 때문이다. 따라서, 우선 순위 큐를 이용하여 구현한 다익스트라 알고리즘의 시간복잡도는 $O(ElogV)$ 이다. 필자가 직접 구현한 다익스트라 알고리즘의 코드는 Baekjoon 1753 (최단경로) 에서 확인 가능하다. 참고 : INF 끼리 계산이 되지 않도록 주의해야 한다. ( INF 이면 return을 바로 해버린다거나, 건너뛴다거나 등 )실제로 무한대면 문제가 없지만, 코드 상에서 INF는 그저 큰 값에 불과하므로 INF 끼리 연산하면 문제가 발생할 수도 있다.","link":"/2020/09/13/2020-09-13-Dijkstra/"},{"title":"Bellman-Ford Algorithm","text":"두 번째 SSP (Single Source Shortest Path) 알고리즘은 벨만 포드 알고리즘 (Bellman-Ford Algorithm) 이다. 다익스트라 알고리즘과 비교했을 때 가장 큰 특징은, 음의 가중치를 가지는 간선이 있어도 사용할 수 있다는 점이다.주의할 점은, 음의 가중치를 가지는 순환고리가 있다면 최단 거리가 존재하지 않는다는 것이다.예를 들어, A -&gt; B 가 가중치 -5, B -&gt; A 가 가중치 +2 라면, A 와 B 를 계속 왕복할수록 가중치가 무한히 작아질 수 있다.벨만 포드 알고리즘은 음의 가중치가 포함된 그래프에서의 최단 경로를 구하는 것은 물론이고,위의 예시와 같이 음의 순환고리가 있는지 없는지, 최단경로가 존재하는지 그렇지 않은지 판단할 수도 있다.이를 벨만 포드 알고리즘의 정확성이라고 한다. 하나의 단점으로는, (당연히) 다익스트라 알고리즘보다 시간복잡도가 크다. 벨만 포드 알고리즘에서는, “모든 정점에 대해” “모든 간선을” Relax 한다.( 시간복잡도는 위에서 알 수 있듯이 $O(EV)$ 이다 )이와 같이 비효율적인 이유는, 벨만 포드 알고리즘의 정확성과 관련이 있다. 우선, 알고리즘의 단계를 천천히 살펴 보자. 다익스트라 알고리즘과 비슷하게 dist 배열을 사용하며, (dist[i] : 노드 i 까지의 최단거리) 단계마다 이 dist 배열을 갱신해 줄 것이다.Relax 단계는, 어떠한 정점에서 출발하여 모든 간선을 차례차례 확인해 보고, 만약 기존의 dist 배열의 값보다 작다면 갱신해 주는 단계이다.확인하는 간선의 순서, Relax의 기준이 되는 정점의 순서는 중요하지 않다. Relax 과정의 횟수가 중요하다. 따라서, 필자는 다음과 같이 알고리즘을 구현하였다:&quot; 확인하는 간선의 순서를 고정시켜 두고, 모든 간선의 Relaxation 과정을 총 N번 진행한다 &quot; 만약 음의 순환고리가 없다면, N번의 Relaxation 과정 후면 모든 점들의 최단 거리가 정해진다.즉, N번의 Relaxation 후에는 다시 Relaxation을 진행하더라도 변화가 없다.하지만, 만약 음의 순환고리가 있다면 결코 모든 점들의 최단 거리가 정해질 수 없기 때문에 N+1번째 Relaxation에서도 변화가 생긴다.따라서, 우리는 이 변화 유무를 통해 음의 순환고리의 유무를 확인할 수 있다!! 즉, N번의 Relaxation을 한 후, 한 번 더 Relaxation을 진행하여 변화가 있다면 음의 순환고리가 있고, 변화가 없다면 음의 순환고리가 없는 것 이라고 결론지을 수 있다. 위와 같이 벨만 포드 알고리즘으로는 음의 순환고리의 유무와, 음의 순환고리가 없다면 한 점으로부터 모든 점들의 최단 경로들을 구할 수 있다. 필자가 직접 구현한 코드는Baekjoon 11657 (타임머신)을 참고하라.","link":"/2020/09/15/2020-09-15-Bellman-Ford/"},{"title":"Baekjoon 11657 (타임머신)","text":"Baekjoon 11657, 백준 11657 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;vector&gt;#define INF 999999999using namespace std;typedef struct Road { int from; int to; int value;};int N, M;bool isChanged = false;vector&lt;Road&gt; map; // {from,to,value}long long int dist[502]; // dist[i] : minimum distance to node i, updatedvoid Relaxation() { // relax EVERY ROADS for(int i = 0; i &lt; map.size(); i++){ int from_node = map[i].from; int to_node = map[i].to; int value = map[i].value; // update if(dist[from_node] == INF) continue; if(dist[to_node] &gt; dist[from_node] + value) { dist[to_node] = dist[from_node] + value; isChanged = true; } }}void BellmanFord() { // Bellman-Ford Algorithm dist[1] = 0; // initialization // Relaxation: N-1 times for(int i = 1; i &lt;= N-1; i++){ // relax EVERY ROADS every time Relaxation(); } // check if there is negative-cycle // if dist changes after N-1 times of Relaxation, it means that there is a negative-cycle isChanged = false; Relaxation(); if(isChanged) { printf(&quot;-1\\n&quot;); return; } else { for(int i = 2; i &lt;= N; i++){ if(dist[i] == INF) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;, dist[i]); } }}int main() { // put inputs scanf(&quot;%d %d&quot;, &amp;N, &amp;M); while(M--){ int A, B, C; scanf(&quot;%d %d %d&quot;, &amp;A, &amp;B, &amp;C); map.push_back( {A,B,C} ); } for(int i = 2; i &lt;= N; i++){ dist[i] = INF; } // Solution by Bellman-Ford Algorithm BellmanFord();}가장 기본적인 벨만 포드 알고리즘 (Bellman-Ford Algorithm) 문제이다. 벨만 포드 알고리즘의 이론은 여기를 참고하라.","link":"/2020/09/15/2020-09-15-Baekjoon-11657/"},{"title":"Baekjoon 11404 (플로이드)","text":"Baekjoon 11404, 백준 11404 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INF 999999999using namespace std;int n, m;int dp[102][102]; // initial: dp[from][to] = valuevoid Floyd_Warshall() { // consider passing node 'temp' for(int temp = 1; temp &lt;= n; temp++){ for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++){ if(dp[i][temp] != INF &amp;&amp; dp[temp][j] != INF){ dp[i][j] = min(dp[i][j], dp[i][temp] + dp[temp][j]); } } } }}int main() { // put inputs &amp; initalization scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%d&quot;, &amp;m); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++){ dp[i][j] = INF; } } while(m--){ int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); if(dp[a][b] &gt; c) dp[a][b] = c; } // Solution by Floyd-Warshall Algorithm Floyd_Warshall(); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++){ if(dp[i][j] == INF || i == j) printf(&quot;0 &quot;); else printf(&quot;%d &quot;, dp[i][j]); } printf(&quot;\\n&quot;); }}플로이드 워셜 알고리즘 (Floyd-Warshall Algorithm) 의 기본적인 구현이다! 알고리즘에 대한 이론은 여기에서 확인할 수 있다.","link":"/2020/09/20/2020-09-20-Baekjoon-11404/"},{"title":"Floyd-Warshall Algorithm","text":"ASP는 모든 정점이 출발점이 되어, 모든 정점에 대한 최단 거리를 구하는 것이다. 기존에 배운 두 가지 SSP (Dijkstra, Bellman-Ford) 를 정점의 개수만큼 진행하여도 답을 얻을 수 있지만, 굉장히 많은 연산이 소요된다.따라서, ASP 문제를 해결하기 위해서는 새로운 알고리즘을 이용해야 한다. 이번에 알아볼 ASP (All Pairs Shortest Path) 는 플로이드 워셜 알고리즘 (Floyd-Warshall Algorithm) 이다. 플로이드 워셜 알고리즘은 음의 가중치인 간선이 없어야 한다.기본적인 아이디어는 Dynammic Programming 이고, 최단 거리의 정보를 담는 2차원 배열을 놓고 모든 경우를 대입해 보면 된다. 조금 더 자세히 살펴보자.2차원 배열 dp에 대해, dp[from][to] = value 가 되도록 하겠다. 처음에는 INF (도달할 수 없음) 으로 초기화해 준다.이후, 점 i 에서 점 j 로 갈 때 점 temp 를 거치는 경우! 와 같이 세분화하여 3중 for 문을 돌린다.( 즉, 시간복잡도는 $O(V^3)$ 이다. ) 가장 바깥쪽 temp, 그 안쪽이 i, 가장 안쪽이 j 에 대한 for문이다. (중요!!) 각 경우에 대하여, 기존 dp에 저장되어 있던 값과 새로 temp를 거치는 값을 비교하여 새 값이 더 작다면 갱신해 주면 된다. 필자가 직접 구현한 코드는 Baekjoon 11404 (플로이드) 에서 확인할 수 있다.","link":"/2020/09/20/2020-09-20-Floyd-Warshall/"},{"title":"Baekjoon 10217 (KCM Travel)","text":"Baekjoon 10217, 백준 10217 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;tuple&gt;#include &lt;queue&gt;#define INF 999999999using namespace std;typedef tuple&lt;int,int,int&gt; TUPLE;int N, M;int dp[102][10002]; // dp[i][j]: time going to i with cost jint main() { int T, K; scanf(&quot;%d&quot;, &amp;T); while(T--){ bool isAns = false; scanf(&quot;%d %d %d&quot;, &amp;N, &amp;M, &amp;K); // initialization for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= M; j++){ dp[i][j] = INF; } } vector&lt;TUPLE&gt; map[103]; // map[from].{ to, value, time } while(K--){ int from, to, value, time; scanf(&quot;%d %d %d %d&quot;, &amp;from, &amp;to, &amp;value, &amp;time); map[from].push_back( make_tuple(to,value,time) ); } // auto-ordered by time priority_queue&lt;TUPLE,vector&lt;TUPLE&gt;,greater&lt;TUPLE&gt;&gt; pq; // {time, to, value} pq.push({0,1,0}); // start while(!pq.empty()){ // consider top of pq TUPLE temp = pq.top(); int time_temp = get&lt;0&gt;(temp); int to_temp = get&lt;1&gt;(temp); int value_temp = get&lt;2&gt;(temp); pq.pop(); // if arrived N if(to_temp == N){ // arrived N within cost M, and minimum time (automatically ordered pq) isAns = true; printf(&quot;%d\\n&quot;, time_temp); break; } // A better case is already saved in dp : skip if(dp[to_temp][value_temp] &lt; time_temp) continue; // looking for next node for(int i = 0; i &lt; map[to_temp].size(); i++){ TUPLE next = map[to_temp].at(i); int to_next = get&lt;0&gt;(next); int value_next = get&lt;1&gt;(next); int time_next = get&lt;2&gt;(next); // if cost gets over M : skip if(value_temp + value_next &gt; M) continue; // if going to 'next' is a better case than the one originally saved in dp if(dp[to_next][value_temp + value_next] &gt; time_temp + time_next) { // change dp and push to pq dp[to_next][value_temp + value_next] = time_temp + time_next; pq.push(make_tuple(time_temp + time_next, to_next, value_temp + value_next)); } } } // no way to go N if(!isAns) printf(&quot;Poor KCM\\n&quot;); }}다익스트라 알고리즘 (Dijkstra Algorithm) 을 사용하는 문제였다. 한 간선에서 고려할 정보가 시간, 가격의 두 가지가 되었고, 제한이 걸려 있는 문제이다.정보들을 담기 위해 &lt;map&gt;과, 오랜만에 &lt;tuple&gt;을 사용하였다. 제한 가격을 넘어서는 순간, 그 요소를 skip 하는 방법으로 해결하였다.","link":"/2020/09/25/2020-09-25-Baekjoon-10217/"},{"title":"Baekjoon 1956 (운동)","text":"Baekjoon 1956, 백준 1956 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INF 999999999using namespace std;int V, E;int dp[402][402];void Floyd_Warshall() { // consider passing node 'temp' for(int temp = 1; temp &lt;= V; temp++){ for(int i = 1; i &lt;= V; i++){ for(int j = 1; j &lt;= V; j++){ if(dp[i][temp] != INF &amp;&amp; dp[temp][j] != INF){ dp[i][j] = min(dp[i][j], dp[i][temp] + dp[temp][j]); } } } }}int main() { // get inputs &amp; initialization scanf(&quot;%d %d&quot;, &amp;V, &amp;E); for(int i = 1; i &lt;= V; i++){ for(int j = 1; j &lt;= V; j++){ if(i == j) dp[i][j] = 0; else dp[i][j] = INF; } } while(E--){ int from, to, value; scanf(&quot;%d %d %d&quot;, &amp;from, &amp;to, &amp;value); if(dp[from][to] &gt; value) dp[from][to] = value; } Floyd_Warshall(); int ans = INF; for(int i = 1; i &lt;= V; i++){ for(int j = 1; j &lt;= V; j++){ if(i != j) ans = min(ans, dp[i][j] + dp[j][i]); } } if(ans == INF) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;, ans);} 어떠한 최단 경로 알고리즘을 쓸까 고민하던 중, ASP 중 하나인 플로이드 워셜 알고리즘 ( Floyd-Warshall Algorithm) 을 사용하여 문제를 해결하였다. 평범하게 플로이드 워셜을 모든 출발점과 도착점에 대해 진행해준 후, dp[start][end] + dp[end][start] 의 최솟값을 찾아주면 끝이었다.","link":"/2020/09/25/2020-09-25-Baekjoon-1956/"},{"title":"How to write Posts(MarkDown)","text":"위치 찾기블로그 GitHub의 _posts 파일 안에 블로그 포스트들이 담깁니다.2020-09-07-제목-제목.markdown 형태의 파일들로 저장한 후, git push 해주면 됩니다. 서두 적기 (제목, 설명, 카테고리, 날짜)MarkDown 파일의 서두는 다음과 같은 양식을 따릅니다.12345678---layout: posttitle: &quot;제목 적기&quot;description: 게시물 설명 적기 (제목 아래에 적힘)date: 2020-09-07 04:00:30 +0900 형식으로 적기categories: [ 카테고리1 ]tags: [ 태그1, 태그2 ]--- MarkDown 문법기본적인 문법은 위키백과를 통해 확인할 수 있습니다.자주 쓰는 문법에는 다음과 같은 것들이 있습니다. 줄바꿈: 문장 끝에 Space 두 번 제목: # - 큰 제목, ## - 중간 제목, ### - 작은 제목 이탤릭체: 문구 볼드체: 문구 밑줄: &lt;u&gt; 문구 &lt;/u&gt; 색깔 넣기: &lt;span style=&quot;color:red&quot;&gt; 내용 &lt;/span&gt; 위와 같이 다양한 html 양식 활용 가능ex. (강제로) 한 줄 띄어쓰기: &lt;br&gt;&nbsp; &nbsp; &nbsp; (강제로) 한 칸 띄어쓰기: &amp;nbsp; 코드 적기블록 코드의 경우, 코드를 기준으로 역따옴표를 세 번 위 아래로 적어주면 됩니다.앞의 역따옴표 세 번 뒤에 언어명(ex. c++)을 적어줍니다.한 줄 코드의 경우, 코드를 기준으로 역따옴표를 한 번씩 적어줍니다. 하이퍼링크 걸기문장 안에는 [ 문구 ][별명] 과 같은 식으로 붙여주고,MarkDown 문서의 맨 뒤에 [별명]: URL주소 와 같은 식으로 넣어줍니다.ex: 아래의 Imgur 사이트의 경우,123[필자의 Imgur 사이트][Imgur]------[Imgur]: https://imgur.com/user/YeonsangShin 사진 넣기사진의 경우 필자는 Imgur 사이트에 사진을 올리고, 사진 URL을 얻는 방식으로 업로드합니다.필자의 Imgur 사이트URL을 만들었다면, 다음과 같은 방식으로 사진을 넣어줄 수 있습니다.1![사진별명](URL.jpg)중앙 정렬, 크기 조정 등을 하려면 HTML 문법으로 처리해 주어야 합니다.1&lt;img src=&quot;URL.jpg&quot; width=&quot;가로길이&quot; height=&quot;세로길이&quot;&gt;만약 중앙정렬을 해주고 싶다면, 앞 뒤로 &lt;center&gt;와 &lt;/center&gt;를 붙여주면 됩니다.1&lt;center&gt;&lt;img src=&quot;URL.jpg&quot; width=&quot;가로길이&quot; height=&quot;세로길이&quot;&gt;&lt;/center&gt;2022.08.06 Update현재 &lt;center&gt; tag를 HTML에서 지원을 중단하여, 실제로 deploy 한 블로그에서 중앙정렬이 되지 않는다. &lt;img&gt; 부분을 앞뒤로 &lt;p align=&quot;style&quot;&gt; 의 형태로 감싸는 방법도 지원되지 않는다. 새로운 방법은 다음과 같다. 1&lt;img src='Image 주소' alt='캡션' style=&quot;display: block; margin: 0 auto&quot;&gt; &lt;/img&gt; 표 넣기다음과 같이 작성합니다.1234|제목|내용|설명||:---|:---:|---:||내용|내용|내용||내용|내용|내용|실제로 다음과 같이 표현됩니다. 제목 내용 설명 내용 내용 내용 내용 내용 내용 참고: 중앙정렬:---: 좌측정렬:--- 우측정렬---:cf) 블로그 테마 문제로 표를 만들면 다닥다닥 못생기게 붙어서 나온다 ㅠㅠ현재까지의 임시 해결책은 (중앙정렬의 경우) 1행의 각 요소 앞뒤로 &amp;nbsp;&amp;nbsp;를 붙여주어 강제로 간격을 벌리는 것이다,,,후2021.01.14: 블로그 이전으로 이제 안해도 된다! 수식 입력현재 MathJax를 이용하여 본 블로그에 LaTeX를 사용할 수 있도록 설정해 놓은 상태입니다. post의 markdown 파일 상단에 use_math: true 를 추가하고, 수식 앞 뒤로 달러 표시 한 개씩: 문단 내, 수식 앞 뒤로 달러 표시 두 개씩: 다음 줄에 (가운데정렬) 수식 뒤에 \\tag{} 하면 자동 수식번호 와 같이 TeX를 이용하여 수식을 입력할 수 있습니다. 2021.01.31 Updatehexo로 넘어오면서, post의 상단에 아무것도 입력하지 않아도 됩니다. 2022.08.12 UpdateLatex과 Markdown의 충돌로 인해, 다음의 작업을 1회 해주어야 합니다.node_modules/kramed/lib/rules/inline.js 에서 앞쪽 var inline = { ... } 부분에서, 다음의 코드를 집어넣고 기존의 escape과 em을 지워줍니다. 12escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/,em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, Latex에서 _가 아래 첨자로 사용되지만, Markdown에서 _도 bold나 italic 등에 사용되기 때문에 발생하는 문제입니다. 참고: 자주 사용하는 TeX 문법 \\, 한 칸 띄어쓰기 \\; 두 칸 띄어쓰기 \\quad 네 칸 띄어쓰기 \\qquad 여덟 칸 띄어쓰기 \\geq &gt;= \\leq &lt;= 태그 만들기 /tags 아래에 TagName.md 의 markdown 파일을 만든다. 다음의 형식(예시)을 따라 markdown 파일을 완성한다. 123456---layout: blogbytagtitle: Tag_sortingtag: sortingpermalink: /tags/sorting--- 카테고리 만들기 /category 아래에 CategoryName.md 의 markdown 파일을 만든다. 다음의 형식(예시)을 따라 markdown 파일을 완성한다.123456---layout: categorytitle: Algorithm Theorycategory: Algorithmpermalink: '/category/algorithm'---","link":"/2020/09/30/2020-09-30-Manual/"},{"title":"[ON SOPT] Server 1st Seminar","text":"1주차 세미나 사전준비 NodeJS 설치 VSCode 설치 (+ Extensions) GIT 가입 Overview Server란? 네트워크를 통해 Client가 요구하는 “서비스 자원의 제공자”실제로, 이번 세미나를 통해 비즈니스 로직 설계 데이터베이스 설계 HTTP와 HTTPS AWS 배포 를 배워 본다! JavaScript JavaScript의 특징 스크립트 언어 ( = 인터프리터 언어) 코드를 한 줄씩 번역하고 실행 타입을 명시하지 않음 프로토타입(prototype) 기반의 객체 지향 언어 변수 선언 var let const 범위 &nbsp;&nbsp;Function Scope&nbsp;&nbsp; &nbsp;&nbsp;Block Scope&nbsp;&nbsp; &nbsp;&nbsp;Block Scope&nbsp;&nbsp; 변수 재선언|O|X|X|변수 값 재할당|O|O|X|초기화 값 필요|X||O HoistingJavaScript는 var 변수와 함수를 아래에서 선언 &amp; 초기화 해도, 선언 부분만 최상단으로 끌어올려 해석한다.코드의 가독성과 유지보수를 위해 Hoisting이 일어나지 않도록 하는 것이 좋다.간단한 해결 방법 let과 const를 사용한다. (사실상 const만 사용하라는 정우형의 말이 있었다 ㅎㅎ) 함수, 변수를 가급적 코드 상단부에서 선언한다. Data Type (Primitive) Number모든 숫자 타입은 이거다! 64비트 실수형 String문자열 자료형‘ 와 “ 동일하게 취급한다.참고) ES6부터 역따옴표(백틱)를 지원한다.ex. (백틱) 이렇게 ${변수1} 섞어서 ${변수2} 써도 된다 (백틱) Booleantrue / false Null존재하지 않는 값, 비어 있는 값다른 언어의 ‘null pointer’와 좀 다르다 Undefined값이 할당되지 않은 상태 (변수는 선언했지만) Symbol유일한 식별자를 만들고 싶을 때 사용 Object (객체)Property와 Method의 집합으로, { } 태그로 감싸져 있다.위의 primitive 타입을 제외한 나머지는 모두 object 타입이다.다음과 같은 틀을 따른다1234567자료형 객체이름 = { key: value, key: value, method: function() { // function }};실제 예시:12345678const animal = { animalType: &quot;cat&quot;, animalName: &quot;Nayo&quot;, animalFriends: ['Munji', 'Blue'], meow: function(){ console.log( `${this.animalName}: 야옹`); },} ArrayJavaScript 에서는 Array도 객체이며, 다양한 data type이 함께 들어갈 수 있다.[ ] 키워드로 감싸 표현한다. JSON (JavaScript Object Notation)객체 표현식으로, key: value의 쌍(pair)으로 이루어진다.데이터는 쉼표(,)로 나열, 배열은 대괄호([ ])로 표현, 객체는 중괄호({ })로 표현객체이름.key 나 객체이름['key'] 와 같이 접근 가능하다.클라와 통신할 때 주로 이용한다.ex.12345{ &quot;name&quot;: &quot;신연상&quot;, &quot;age&quot;: 21, &quot;friends&quot;: [&quot;송유민&quot;, &quot;이주영&quot;, &quot;차수영&quot;, &quot;최호승&quot;, &quot;한동민&quot;]} Function 함수 선언식: Hoisting 영향을 받는다!123function add(x, y) { return x + y;} 함수 표현식: Hoisting 영향을 받지 않는다!123var add = function(x, y) { return x + y;} 화살표 함수123var add = (x, y) =&gt; x + y;var square = x =&gt; x * x;var person = (name, age) =&gt; ({ name: name, age: age}); function logic이 한 줄인 경우 return 생략 가능하고,매개변수가 하나라면 ( ) 생략 가능 자바스크립트의 함수는 일급객체 이다. 변수 or 데이터 구조에 담을 수 있고, 다른 함수의 파라미터로 전달할 수 있고, 반환값으로 사용할 수 있다.","link":"/2020/10/10/2020-10-10-Server-1st/"},{"title":"[ON SOPT] Server 2nd Seminar","text":"NodeJS NodeJS란?NodeJS는 서버도 아니고, 프레임워크도 아니고, 프로그래밍 언어도 아니다프로그래밍 언어로 JavaScript를 사용하고,Web Browser가 JavaScript를 해석한다.NodeJS는 크롬 V8 엔진으로 빌드된 JavaScript를 실행할 수 있는 런타임 환경이다. NodeJS의 특징Non-blocking I/O Blocking 호출된 함수가 자신의 작업이 끝날 때까지 제어권을 가짐. 호출한 함수는 대기하며, 그 동안 프로그램 처리 진행 X Non-Blocking 호출한 함수가 바로 다음 호출한 함수에게 제어권을 줌. 다음 작업 바로 수행할 수 있음. 결과론적으로 다음과 같이 작업이 이루어진다. Single Thread 프로세스운영 체제에서 할당하는 작업의 단위프로세스 간 자원(메모리) 공유 X 쓰레드프로세스 내에서 실행되는 흐름의 단위쓰레드들은 부모 프로세스의 자원 공유 가능! Node 실행 → 프로세스 한 개 생성 → 쓰레드 여러 개 생성그러나 NodeJS는 Single Thread이기 때문에 제어 가능한 쓰레드는 한 개Q. Single Thread보다 Multi Thread가 더 좋지 않나요?A. 쓰레드를 카페의 바리스타로 비유한 다음 예시로 확인하자. Event Driven이벤트가 발생할 때 미리 지정해 놓은 작업을 수행Node는 이벤트 리스너(Event Listener)에 콜백 함수를 지정해서 동작한다. (부가적인 설명)JavaScript 엔진은 Memory Heap, CallStack 의 두 가지 주요 구성 요소로 이루어졌다. Memory Heap (메모리 힙)변수와 객체에 대한 모든 메모리 할당이 여기서 발생. CallStack (호출 스택)코드가 실행되면 호출 스택이 쌓인다.프로그램에서 우리가 어딨는지를 기록하는 데이터 구조! CallStack의 사이즈를 초과한다면 Stack Overflow가 발생한다. (무한루프 등등) JavaScript는 Single Thread이므로, 호출 스택이 하나다. (즉, 한 번에 하나의 일만 처리할 수 있음)→ 하나의 함수가 엄청 느리면?? 비동기 콜백(Asynchronous CallBack)을 이용!! Asynchronous CallBack (비동기 콜백) 콜백 큐(Callback Queue) 이벤트가 발생하면 백그라운드에서 콜백으로 콜백 함수들을 보냄 이벤트루프가 콜스택에 콜백 함수들을 전달 콜백 큐의 콜백 함수들은 콜 스택이 비워지기를 기다림 이벤트 루프(Event Loop) 콜백 큐의 콜백함수들을 콜 스택에 전달 단, 콜 스택이 비어있을 때만 전달 백그라운드(BackGround) 타이머나 이벤트 리스너들이 대기하는 곳 여러 작업 동시에 실행 가능 비동기 흐름 제어 Blocking ↔ Non-Blocking, Sync ↔ Async 구분하기 Blocking ↔ Non-Blocking : 호출되는 함수가 바로 리턴하느냐 마느냐Blocking: 바로 리턴 XNon-Blocking: 바로 리턴 Sync ↔ Async : 호출되는 함수의 작업 완료 여부를 누가 신경쓰느냐Sync: 호출하는 함수가 (계속 확인하며) 신경 씀Async: 호출되는 함수가 신경 씀 JavaScript는 기본적으로 동기적(Synchronous) 으로 실행된다.하지만 Node는 대부분 비동기적(Asynchronous) 으로 작동한다.그럼, 다음의 문제 상황에 직면한다. JavaScript에서 비동기적으로 실행하고 싶은 코드가 있다면..?Callback Function콜백함수란? 1. 다른 함수의 인자로써 이용되는 함수 2. 어떤 이벤트에 의해 호출되어지는 함수 예시)1234567fun = function(a, b, callback_func){ callback_func(a+b, a-b);}fun(5, 10, function(res1, res2) { console.log(res1); console.log(res2);});쉽게 말해, 이벤트가 끝나면 다시 전화를 준다!이걸 이용해서 어떻게 비동기 처리를 해결할 수 있을까?다음의 예시를 살펴보자. 123456789function getData() { var tableData; $.get('https://domain.com/products/1', function(response) { tableData = response; }); return tableData;}console.log(getData()); // undefined 예상한 대로라면, response를 받고 tableData에 넣고, tableData가 출력되어야 하지만 undefined가 출력된다.그 이유는, get이 비동기 방식으로 작동하여 tableData에 response를 넣기 전에 return tableData;를 실행했기 때문이다.다음과 같이 콜백함수를 사용하면, 이를 해결할 수 있다. 123456789function getData(callbackFunc) { $.get('https://domain.com/products/1', function(response) { callbackFunc(response); // 서버에서 받은 데이터 response를 callbackFunc() 함수에 넘겨줌 });}getData(function(tableData) { console.log(tableData); // $.get()의 response 값이 tableData에 전달됨}); 이러면, 데이터가 들어와야만 콜백 함수로 넘어가기 때문에, 데이터가 올바르게 출력된다.setTimeout은 다음 예시와 같이 콜백함수로 처리 가능하다. 12345678910111213function first(callback){ setTimeout(function() { console.log(1); callback(); }, 500);}function second() { console.log(2);}first(function() { second();}); 이러한 경우에는, 5초 뒤에 1 나오고 그 뒤에 2 나온다.이와 같이 콜백함수를 이용하는 경우에는, Callback Hell에 빠질 수 있다는 문제가 있다.(콜백함수가 서로 물리고 물려, 가독성 떨어지고 로직 바꾸기도 어렵다)따라서, 아래의 방법들을 주로 이용한다. PromisePromise는 다음의 3가지 상태를 가진다. Pending : 최초로 생성, 비동기 작업 수행중.. Fullfilled : 비동기 작업이 성공적으로 완료됨 Rejected : 비동기 작업이 실패함기본적으로 promise는 다음의 형태를 띈다. 123const func = new Promise(function (resolve, reject) { // 내용}); 비동기 작업을 성공하면, resolve를 호출한다. (Fullfilled 상태가 됨)이 경우, then()을 통해 결과를 전달한다. 비동기 작업이 실패하면, reject를 호출한다. (Rejected 상태가 됨)이 경우, catch()를 통해 (보통은 error가) 전달한다. 예시) 12345678910111213141516const func = new Promise(function (resolve, reject) { const age = 19; if(age &gt; 20) { resolve(age); } else { reject(new Error('나이가 너무 어려요')); }});func .then(function(resolvedData) { console.log(resolvedData); }) .catch(function(err) { console.log(err); }); cf) 여러 개의 promise를 .then()을 연달아 사용할 수 있다 (Promise Chaining) Async함수 앞에 async 키워드를 붙혀주면, 암묵적으로 promise를 반환 한다. 예시) 다음의 두 함수는 정확히 같은 역할을 한다.1234567891011function getData() { return new Promise((resolve, reject) =&gt; { const data = 'data'; // 오래 걸림 resolve(data) })}const data = getData();data.then( (value) =&gt; { console.log(value);});12345678async function getData() { const data = 'data'; // 오래 걸림 return data;}const data = getData();data.then( (value) =&gt; { console.log(value);});await은 promise를 기다리며 (성공 or 실패), async로 정의된 함수 앞에만 사용 가능하다. 예시)1234567891011async function getData() { const data = 'data'; // 오래 걸림 return data;}async function main() { const data = await getData(); console.log(data);}main(); Module 모듈이란?코드를 여러 개의 파일로 분리하는 방법! Exports를 사용하여 분리하는 예시 12345678910111213// animal.js의 가장 하단부module.exports = { func1, func2, animal,}// main.js의 가장 상단부const animalModule = require('./animal');// animal.js의 함수들을 main.js에서 사용 가능animalModule.func1();animalModule.animal.bark(); File System Module파일 시스템에 접근하는 내장 모듈로, 파일 생성, 삭제, 읽기, 쓰기, 폴더 생성 및 삭제 가능 12345678910111213//동기적 write &amp; readconst fs = require('fs');fs.writeFileSync('filename.txt', data);const read_data = fs.readFileSync('filename.txt');// 비동기적 write &amp; readconst fs = require('fs');fs.writeFile('filename.txt', data, () =&gt; { console.log('wrote file');});fs.readFile('filename.txt', (err, data) =&gt; { console.log(`read file with ${data}`);}); Crypto다양한 방식의 암호화를 도와주는 모듈단방향 암호화 방식으로, 복호화 할 수 없다 (주로 해시 기법)123const crypto = require('crypto');const password = '1234';const fin = crypto.createHash('sha512').update(password).digest('base64'); createHash(algorithm &lt;string&gt;)사용할 해시 알고리즘을 넣어줌. 주로 sha512 사용 update( &lt;string&gt; )변환할 문자열 넣어줌. digest(encoding)인코딩할 알고리즘을 넣어줌. base64가 결과가 짧아 많이 이용함 PBKDF2 (Password-Based Key Derivation Function)가장 많이 사용되는 Key Derivation Function으로, salt를 적용한 후 반복 횟수를 임의로 선택한다.crypto.pbkdf2는 다음과 같은 형태로 사용한다. 1crypto.pbkdf2(password, salt, iterations, keylen, digest, callback); 실제로 적용한 예시는 아래와 같다. 123456789const crypto = require('crypto');crypto.randomBytes(64, (err, buf) =&gt; { const salt = buf.toString('base64'); console.log(`salt : ${salt}`); crypto.pbkdf2('비밀번호', salt, 100000, 64, 'sha512', (err, key) =&gt; { console.log(`password: ${key.toString('base64')}`); });});","link":"/2020/10/17/2020-10-17-Server-2nd/"},{"title":"[ON SOPT] Server 3rd Seminar","text":"3주차 세미나 사전준비 Postman 설치 AWS 회원가입 HTTP HTTP란?HTTP (Hyper Text Transfer Protocol) 웹에서 클라와 서버가 데이터를 주고 받을 수 있는 프로토콜 (규칙) 웹에서 이 규칙에 맞춰 정보를 교환한다 정보를 전달하는 방법1. URL: param 혹은 query 를 통해 연결2. Header: 부가적인 정보 (토큰, 쿠키) 전송3. Body: JSON 등의 형식으로 이루어진 데이터 cf) Request에서 param, query의 차이점param: 주소의 변수를 담는다. (ex: localhost:3000/news/13)query: 주소 바깥의 ‘?’ 이후의 변수를 담는다. (ex: localhost:3000/news?category=society) HTTP Method HTTP Status CodeHTTP 응답의 상태를 알려주는 코드로, HTTP 요청이 성공적으로 완료되었는지 알려준다 Express Express 입문Express : 웹/앱을 위한 NodeJS 프레임워크로, npm을 통해 수많은 패키지에 접근 가능 프로젝트 만들기: VSCode 실행하고,npm install -g express express-generator 이 때, -g는 global(전역 설치) 옵션으로 컴퓨터 당 한 번만 해주면 되는듯 하다 이후 최상단 폴더에서 express {프로젝트 이름} 해주면 된다. 프로젝트 시작: 프로젝트로 이동한 후 npm start 첫 번째 실행이라면 이전에 npm install을 해주어야 한다. 팁: Nodemon은 파일이 수정되면 자동으로 서버를 restart해 주어 편리하다!! npm install -g nodemon 해서 설치하고, nodemon start로 서버 시작해준다. 프로젝트 구조: bin/www : app.js 파일을 가져와 http 객체와 연결한다. 또한, 포트 번호 바꿀 수 있음. node_modules : 모듈들이 설치되는 곳. 엄청 무거움. 건들 일 거의 없다. 팁: 프로젝트를 git에 올릴때 보통 .gitignore 파일에 요놈을 추가해준다. public : 이미지, CSS, JS파일 저장 (웬만하면 건들 일 없다) Routes : 라우팅을 위한 폴더 리소스 별로 라우팅을 구현한다. views : Jade, ejs, nunjucks와 같은 템플릿 엔진들을 모아둔다. app.js : 프로젝트의 중심이자 미들웨어 관리가 이루어진다. 라우팅의 시작점! package.json : 프로젝트 정보 정의하고, 의존하는 패키지 정보를 명시 MiddleWare, 미들웨어미들웨어 : 서버가 요청-응답과정을 하는 동안 중간의 동작을 해주는 함수request가 올 때마다 미들웨어를 거쳐 response를 보낸다. Routing라우팅 : URI 및 특정 HTTP 요청 메소드인 특정 엔드포인트에 대한 클라 요청에 앱이 응답하는 방법을 결정하는 것.예) URL에 news.daum.net/society, news.daum.net/politics와 같이 목적에 따라 구분하는 것 기본적으로는 다음과 같은 양식을 따른다. 123router.METHOD('path', (req, res) =&gt; { /* logic */}); METHOD: HTTP 요청 메소드 (GET, POST, DELETE, PUT) path: 서버에 접근할 경로 req: request로 전달 받은 객체의 데이터 req.headers, req.file, req.query, req.params, req.body 사용 가능 res: response로 전달할 데이터 세미나에서 다룬 Express를 이용한 routing 방법은 다음과 같다:우선, routes 파일에 (카테고리를 나누는 느낌으로) 이와 같이 폴더와, 각 폴더 밑에 index.js를 만들어준다. routes/ranking/index.js 에는 위에서 언급한 것과 같이 메소드들을 적어준다.router.get('/popular', (req,res) =&gt; { res.status(200).send(&quot;인기많은순 뉴스&quot;); } ); 가장 바깥의 routes/index.js에는 express의 router() 객체를 router 변수에 할당하고,const express = require('express');const router = express.Router(); 각 세부 폴더에 다음과 같이 적어준다.router.use('/ranking', require('./ranking')); 그러면, 내가 localhost:3000/ranking/popular 로 들어가면 “인기많은순 뉴스”를 볼 수 있다. 이처럼, /ranking 으로 시작하는 리소스들은 ./ranking/index.js에서 나누어 관리할 수 있으며, 이러한 편리한 라우팅이 가능하다는 것이 Express의 장점이다. 이렇게 라우터를 세팅하면, routes/index.js 에서 마지막에 module.exports = router;로 export해 주어 app.js에서 var indexRouter = require('./routes/index'); 와 app.use('/', indexRouter); 해주면 된다.즉, export된 객체를 app.js에서 미들웨어로 등록하는 것이다. 라우팅과 미들웨어가 정상 작동하는지 확인할 때 Postman을 사용한다!팁: Collection 기능 이용하기 &lt;&lt; 실습 팁 &gt;&gt; key-value 쌍의 경우 값이 같으면 value 값은 생략 가능하다! 비 구조화 할당을 이용하여 req.body의 값을 추출할 수 있다. 예) const { name, part, age } = req.body; 이는 const name = req.body.name; ..... 와 같다. AWS EC2 EC2(Elastic Cloud Compute) 안전하고 크기 조정이 가능한 컴퓨팅을 클라우드에서 제공하는 웹 서비스 EC2 사용 순서 EC2 인스턴스 생성 (Cloud Computer 대여) EIP 연결 (컴퓨터의 IP를 만들어서 연결) SSH 접속 (ssh를 이용하여 빌린 컴퓨터에 접속) 서버 환경 구축 (빌린 컴퓨터에 node 깔아서 돌리기) Key Pair란?EC2 서버에 접근하려면 개인키와 공개키로 구성된 키페어가 필요한데, 공개키는 AWS에 업로드되어 가상 서버에서 보관하고 개인키는 자신이 소유한다.EC2에 접속할 때마다 키페어를 이용하여 접근한다!보안이 취약한 곳에 올리면 절대 안된다!! EIP(Elastic IP)란?EC2가 재시작될 때마다 Public IP가 변경되기 때문에, 이를 고정된 IP로 연결해주는 것EIP가 혼자 돌아가면 과금되기 때문에, 항상 연결해 주어야 한다!!즉, EC2 중단하기 전에 반드시 EIP를 release 해주어야 함. (실제로 안했더니 1주일에 0.02$ 정도 나갔다) EC2 접속 방법 Terminal에서 key pair가 있는 위치로 이동 chmod 400 {pemKeyName}.pem sudo ssh -i '{pemKeyName}.pem' ubuntu@{EIP} PM2 (NodeJS Process Manager)프로세스를 모니터링하는 프로그램( 노드는 시간 지나면 지 혼자 죽을 수도 있어서, 모니터링이 필요 )설치: sudo npm install -g pm2실행: 프로젝트 최상위 폴더에서 pm2 start ./bin/www다양한 명령어들: pm2 start ./bin/www --name {server_name} : 서버 이름 붙여주기 pm2 list : 프로세스 리스트 확인 pm2 restart {name 또는 id} : 프로세스 재시작 pm2 monit : 프로세스 모니터링 pm2 stop {name 또는 id} : 프로세스 중지 pm2 logs : 로그 보기","link":"/2020/10/31/2020-10-31-Server-3rd/"},{"title":"[ON SOPT] Server 4th Seminar","text":"4주차 세미나 사전준비 RDS 세팅 MySQL workbench 설치 Database 데이터베이스서버는 데이터베이스에 접근하여 데이터들을 Read/Write 한다. 데이터베이스 관련성을 가지며 중복이 없는 데이터의 집합 데이터베이스를 관리하는 시스템을 DBMS(Database Management System) 이라 함. Relational Database(관계형 데이터 베이스): key-value 관계를 테이블화 한 것 데이터 베이스 용어 정리Primary Key(기본키) : 다른 데이터와 구별할 수 있는 식별자 한 테이블에는 하나 혹은 그 이상의 primary key가 있어야 함 Not Null, Unique Index : 데이터 색인 기능 관계형 데이터 베이스에서 검색 속도를 높이기 위한 도구 Unique, 특정 데이터 대표 주로 기본키로 사용됨 Foreign key(외래키) : 한 테이블의 column 중 다른 테이블의 row를 식별할 수 있는 key Relation 관계1 : 1 관계말 그대로 1:1로 매핑되는 관계 (예: 이름 - 주민번호) 1 : N 관계한쪽 개체가 관계를 맞은 개체 쪽의 여러 개체를 가질 수 있는 관계 (예: 이름 - 이메일)테이블 한 개로 담기에는 중복되는 정보가 너무 많아, 테이블을 나누어 준다. M : N 관계양쪽 개체가 서로 1:N 관계로 보고 있는 관계 (예: 이름 - 스터디)이러한 경우에는 테이블을 잘 나누어 주어야 한다 → 정규화 정규화관계형 데이터 베이스를 논리적이고 직관적으로 만드는 과정 목적 불필요한 데이터 제거 논리적인 데이터 저장 이상현상 방지 삽입 이상 : 새 데이터를 삽입할 때 불필요한 데이터도 함께 넣어줘야 되는 문제 갱신 이상 : 중복 튜플인데 일부만 변경되는 문제 (데이터 모순) 삭제 이상 : 튜플을 삭제했는데 중요 데이터가지 함께 삭제되는 데이터 손실 문제 &lt; 1차 정규화 &gt;조건: 각 row 마다 column이 값을 하나씩만 가져야 함 (즉, 컬럼이 원자값을 가져야 함)쉬운 설명: 모든 Domain에 값이 한 개씩만 반복되는 group이 없음 기본키(PK)로 각 데이터가 식별 가능해야함 &lt; 2차 정규화 &gt;조건: 부분 함수적 종속이 없이, 모든 컬럼이 완전 함수적 종속을 만족함함수적 종속: X에 의해 Y가 결정되면, Y는 X에 대해 함수적 종속이다이 때 X를 결정자, Y를 종속자라고 한다부분 함수적 종속: {X1, X2} → Y 에서, X2 만으로도 Y가 결정되는 경우완전 함수적 종속: {X1, X2} → Y 에서, X1과 X2가 모두 있어야 Y가 결정되는 경우 &lt; 3차 정규화 &gt;조건: 2차 정규화가 되어 있고, 이행적 함수 종속이 없어야 함쉬운 설명: 기본 키가 아닌 속성들은 기본 키에만 의존해야 함 &lt; 역 정규화 &gt;시스템의 퍼포먼스를 위해 정규화에 위배되는 행위를 하는 것 Sequelize ORM (Object Relational Mapping) Sequelize ORM이란?NodeJS에서 JS의 객체와 DB의 관계를 매핑해주는 라이브러리!SQL을 사용하지 않고 JS로 DB에 접근한다 Sequelize Project처음: npm install sequelize-cli sequelize mysql2로 모듈 3개 깔아주고, sequelize init 해주면 sequelize project가 생성된다. config/config.json : DB의 정보를 담는 공간 models/index.js : DB의 테이블을 정의하는 곳 (MySQL의 Table에 대응) Migrations : 테이블 컬럼을 추가/제거할 때 이 파일을 통해 실제 DB에 반영 (세미나에서 사용x) Seeders : 시드 데이터를 생성하는 곳 (테스트 환경) (세미나에서 사용x) MySQL Workbench의 RDS에서 Edit Connection - Hostname, Username, Password 확인, 이들을 config/config.json에 잘 적어준다. 예: console로 DB 연결을 확인하는 코드 (App.js에 추가)123456789const { sequelize } = require('./models');sequelize.sync({ alter: false }).then( () =&gt; { console.log('데이터베이스 연결 성공');}).catch( (error) =&gt; { console.error(error);})추가설명: sequelize.sync({}) 에서 모델 동기화가 시작된다! 테이블이 존재하지 않는 경우 생성함. sequelize.sync({force: true}) : 테이블이 이미 존재하면 삭제하고 생성 sequelize.sync({alter: true}) : DB의 테이블 현재 상태(컬럼, DataType)를 확인하고 필요한 변경을 수행하여 모델과 일치시킴 Sequelize로 Model 정의하기 기본적으로는 다음과 같이 sequelize.define()를 이용하여 정의한다.1sequelize.define('모델이름', { /* 스키마 */ }, { /* 스키마 옵션 */ });스키마 표기법은 다음과 같다: 모델의 옵션에는 다음과 같은 것들이 있다: FreezeTableName: true이면 모델명과 DB 테이블 이름을 동일하게 설정해줌. (Sequelize는 기본적으로 모델이름 - 단수, 테이블이름 - 복수 로 설정) timestamps: 기본값 true, 자동으로 createdAt, updatedAt 컬럼 만들어줌. tableName: 실제 DB의 테이블 이름 설정해줌. paranoid: true로 설정하면 deletedAt라는 컬럼이 생기고, row를 삭제했을 때 실제 데이터는 삭제되지 않고 deletedAt에 지운 시간이 기록됨. 이러면 Select 할 때 집계 X underscored: true이면 기본값 CamelCase에서 snake_case 로 바뀜. Models/user.js의 예시:123456789101112131415161718module.exports = (sequelize, DataTypes) =&gt; { return sequelize.define('User', { // 모델의 Column 정의 email: { type: DataTypes.STRING(30), unique: true, allowNull: false, }, userName: { type: DataTypes.STRING(200), allowNull: false, }, }, { // 모델의 Option 정의 freezeTableName: true, timestamps: false, });};위의 예시와 같이 User Model을 만들면, Models/index.js에서 다음과 같이 Sequelize 객체에 연결할 수 있다. 123456789cosnt db = {};/* sequelize, Sequelize, env, config 설정 */db.sequelize = sequelize;db.Sequelize = Sequelize;db.User = require('./user')(sequelize, Sequelize);module.exports = db; Sequelize QuerySequelize 쿼리를 이용하여 CRUD 작업을 해보자! 예시들 (Sequelize query에서 const { User } = require('models/index.js 상대경로'); 해줘야 함) Create SQLINSERT INTO users (name, age, address) VALUES ('신연상', 21, '강남구'); Sequelize query 123456// Model.create({ 정보 });const user = await User.create( { userName: '신연상', age: 21, address: '강남구',}); findOne SQLselect * from users LIMIT 1;select * from users WHERE name = '신연상'; Sequelize query 12345678const user = await User.readOne({ });// Model.findOne({ /* 읽을 로우 */ });const user = await User.findOne({ where: { name: '신연상', },}); findAll SQLselect * from users;select name, address from users where address = '강남구';select age, name from users where age &gt; 21; Sequelize query 1234567891011121314151617const user = await User.findAll({ });// Model.findAll({ attributes, where });const users = await User.findAll( { attributes: ['name', 'address'], where: { address: '강남구' }});const { Op } = require('sequelize');const users = await User.findAll( { attributes: ['age', 'name'], where: { age: { [Op.gt]: 21}, }}); Update SQLupdate users set name = '바뀔이름' where id = 2; Sequelize query 123456// Model.update({ /* 수정할 내용 */ }, { /* 어떤 로우를 수정 */ });const user = await User.update({ name: '바꿀 이름' }, { where: { id: 2 }}); Destroy SQLdelete from users where id = 2; Sequelize query 123456// Model.destroy({ /* 삭제할 로우 */ })const user = await User.destroy( { where: { id: 2 }}); 참고사항들: Sequelize는 자체적으로 promise를 반환하기 때문에 async/await 사용 가능 Sequelize 객체 내부의 Op 객체를 불러와 특수한 연산 사용 가능! ex: Op.gt(초과) Op.gte(이상) Op.lt(미만) Op.lte(이하) Op.ne(같지않음) Op.or(또는) Op.in(배열 요소 중 하나) Op.notIn(배열 요소와 모두 다름)","link":"/2020/11/07/2020-11-07-Server-4th/"},{"title":"[ON SOPT] Server 6th Seminar","text":"JWT 인증(Authentication)API 요청에 대해 사용 가능한 사용자인지 확인하는 절차!즉, 클라이언트가 주장하는 사용자와 같은 사용자인지를 확인하는 절차이다. HTTP의 특징HTTP는 다음의 특징들을 가진다. 비 연결성(Connection less)클라이언트와 서버가 한 번 연결을 맺고, 클라이언트의 요청에 대해 서버가 응답을 하면 맺었던 연결을 끊는다 무 상태(state less)(위의) 비 연결성으로 인해 서버는 클라를 식별할 수가 없음. 즉, 한 동작을 할 때마다 매번 인증을 해야 하는 문제점이 발생.따라서, 다음의 방법들로 HTTP는 상태를 기억한다. 쿠키(Cookie)key-value의 쌍으로 구성된, 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일로,HTTP에서 클라이언트의 상태를 PC에 저장한 후 필요 시 사용한다.문제점: 클라이언트 로컬에 저장되기 때문에 정보변질/스나이핑의 위험이 있음 세션일정 시간 동안 같은 사용자로부터 들어오는 모든 요구를 하나의 상태로 보고,그 상태를 일정하게 유지시키는 기술문제점: 서버의 세션 저장소를 사용하므로 추가 저장 공간 필요하고, 세션 저장소에 장애가 발생하면 인증에 문제가 생김. JWT(Json Web Token) 클라이언트의 세션 상태를 저장하지 않고, 필요한 정보를 토큰 body에 저장해서 클라이언트가 이를 증명서처럼 사용 JWT란?JWT는 Header.Payload.Verify_Signature 으로 구성된다. Header: 서명에 사용된 알고리즘의 정보 - JWT 토큰 유형, 해시 알고리즘 등 Payload: 토큰의 정보를 작성 (클레임) - 클라에 대한 정보 Signature: 토큰이 중간에 변경되지 않았음을 검증 - Header의 알고리즘과 Secret Key로 Header와 Payload를 담음 JWT는 다음의 특징들을 가진다. 자가수용적: JWT 자체적으로 필요한 모든 정보를 포함함 보안성: 정보가 담긴 데이터 (JSON객체)를 암호화함 확장성: 인증 저장소가(sessionDB) 필요하지 않음 JWT의 작동법다음과 같은 방법으로 작동한다. 클라이언트가 유저에 대한 정보 (email, pw 등)를 서버에게 보냄. 서버가 DB를 이용하여 정보의 유효성을 확인. 유저 정보 중 일부를 JWT Payload에 넣고 토큰 발행 클라이언트에게 토큰 발급 발급받은 토큰을 이용하여 서버에 요청 할 때마다 Request Header에 포함하여 자원을 access할 수 있는 유저인지 식별 후 자원 제공 예시: 토큰 발급12345678// include jwtconst jwt = require('../modules/jwt');// 로그인 로직const user = await userService.signin(email, password, salt);// 토큰 발급const { accessToken, refreshToken } = await jwt.sign(user); RefreshTokenAccessToken이 만료되었을 때 새로 발급해주는 열쇠로, AccessToken과 함께 클라이언트에게 발급한다.RefreshToken은 주로 DB에 저장하고, AccessToken보다 더 안전한 곳에 보관해야 함.AccessToken은 만료 기간을 짧게 줄 수록 안전함 (1시간)RefreshToken은 이보다는 길게 설정 (2주) 예시: 토큰 인증 (JWT 미들웨어) authUtil 미들웨어 로직에서 decoded된 user의 객체를 req.decoded에 접근하여 할당 next()를 호출하여 다음 미들웨어로 이동 이전 미들웨어에서 할당된 req.decoded에서 id를 가져옴 1234567891011121314// routes/users/index.js 에서 미들웨어 importconst authUtils = require('../../middlewares/authUtil');// router에 미들웨어 등록 (signin, signup 빼고!)router.get('/profile', authUtils.checkToken, userController.getProfile); // authUtils.checkToken 안에서 할 거 하고 req.decoded에 user 할당, next() 호출var token = req.headers.jwt;const user = await jwt.verify(token);req.decoded = user;next();// userController 에서 req.decoded로 접근해서 정보 가져옴const { id } = req.decoded; JWT의 장단점장점 별도의 인증 저장소 필요없음 쿠키 사용할 필요없음 (취약점X) 트래픽에 대한 부담 낮음 URL 파라미터와 헤더로 사용 내장된 만료 REST 서비스로 제공 가능 단점 자가수용적: 토큰 자체에 정보를 담고 있으니, 양날의 검이 될 수 있음 토큰 길이: 정보가 많아질수록 토큰 길이가 늘어나 네트워크 부하를 줄 수 있음 payload 인코딩: payload를 탈취하여 디코딩하면 데이터를 볼 수 있으므로(BASE64) payload에 민감한 정보는 넣지 말아야 함 expired: 토큰을 탈취 당하면 제어가 불가능해짐(임의 삭제 불가능). 따라서 accessToken의 만료 시간을 짧게 설정해야 함. (근데, 너무 짧으면 만료될 때마다 HTTP 요청 횟수가 많아짐) REST API URI와 URLURI(Uniform Resource Identifier, 통합 자원 식별자)인터넷에 있는 자원을 나타내는 유일한 주소 URL(Uniform Resource Locator, 유일 자원 시기)네트워크 상에서 자원이 어디있는지 알려주기 위한 규약 → URI는 URL을 포함한 개념!ex) https://site.com/post?id=123 : URI 이지만, URL은 아니다 REST API란?REST 아키텍처의 제약 조건을 준수하는 애플리케이션 프로그래밍 인터페이스(REpresentatinal State Transfer API) REST 구성: 자원 (RESOURCE) : URI 행위 (Verb) : HTTP METHOD 표현 (Representations) REST API의 6가지 제약 조건 Uniform InterfaceURI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행 Stateless세션 정보, 쿠키 정보 저장 관리 X → 들어오는 요청 처리만 하면 되니까, 단순히 구현 가능 CacheableHTTP를 그대로 사용하기 때문에 웹에서 사용하는 기존 인프라를 그대로 활용 가능즉, HTTP의 캐시 기능 적용 가능 Self-descriptivenessREST API 메시지만 보고도 쉽게 이해할 수 있는 자체 표현 구조 Client-Server 구조REST 서버 - API 제공 / 클라 - 사용자 인증, 컨텍스트 직접 관리클라와 서버에서 개발해야할 내용이 명확해지고, 서로 간 의존성 줄어듦 계층형 구조다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 게층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간 매체를 사용할 수 있음. REST API 디자인 가이드(핵심)1. URI는 정보의 자원을 표현해야 함리소스 명은 동사보다는 명사를 사용한다ex) GET /members 2. 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현함ex) POST /members/1, DELETE /members/1 REST API 주의사항 슬래시 구분자(/)는 계층 관계를 나타내는데 사용ex) http://site.com/animal/mammals/whales URI 마지막 문자로 슬래시를 포함하지 않는다. 하이폰(-)는 URI 가독성을 높이는데 사용ex) http://site.com/sopt-server-team 밑줄(_)는 URI에 사용하지 않는다. URI 경로에는 소문자가 적합하다. 파일 확장자는 URI에 포함시키지 않는다. (Accept Header 이용)ex) GET/ /sopt/server HTTP/ 1.1 Host:site.com Accept: image/jpg REST 리소스 간의 연관관계가 있는 경우, (일반적으로 소유 has 의 관계)/리소스명/리소스ID/관계 있는 다른 리소스명ex) GET/ /users/{userid}/devices관계 명이 애매하거나 구체적 표현이 필요할 때는,ex) GET/ /users/{userid}/likes/devices 자원을 표현하는 Collection과 DocumentDocument은 한 객체를 의미하며, Collection은 객체들의 집합도큐먼트를 단수, 컬렉션을 복수로 표현하면 이해하기 좋다! API 명세서 API (Application Programming Interface) 란?서버 애플리케이션의 기능을 사용하기 위한 방법/수단!즉, 클라가 서버의 API를 사용하기 위해 참고하는 사용설명서 구성 요소 API 이름 HTTP METHOD Content Type 요청 헤더/바디 응답 바디","link":"/2020/11/21/2020-11-21-Server-6th/"},{"title":"[ON SOPT] Server 5th Seminar","text":"5주차 세미나 사전준비 AWS S3 세팅 프로젝트 계층 분리 Router : 특정 엔드포인트에 대한 클라의 요청에 앱이 응답하는 방법을 결정 Controller : 요청을 받고 Service 계층에서 받은 데이터를 응답 Model : 모델의 스키마 정의 및 데이터 접근 Service : 데이터 로직 핸들링 &amp; 가공 Router 에서 Controller - Express에 적용: 각각을 하나의 폴더로 만들기 (controller 폴더와 service 폴더 생성) 기존 세미나의 routes/users/index.js의 내용을 controller/userController.js로 옮긴다! 예시: controller/userController.js12345678910/* util, responseMessage, statusCode, User 등 필요한 것들 상대경로로 가져오기 */module.exports = { signup : async (req, res) =&gt; { // 구현 }, signin : async (req, res) =&gt; { // 구현 },} routes/users/index.js 에는 다음과 같이 받아준다. routes/users/index.js1234const userController = require('../../controller/userController');router.post('/signup', userController.signup);router.post('/signin', userController.signin); 사용하지 않는 모듈들을 제거해 주면, 더 깔끔하다!! 비슷한 방법으로 Controller 에서 Service 로 계층 분리 할 수 있다! Workbench 사용법 테이블 설정에서, 테이블 속성 / 제약 조건들 설정하기 테이블 설정 하단의 Foreign Keys 를 통해 외래키 설정 가능cf. On Update / On Delete 부분 추가설명개체를 변경/삭제할 때 다른 개체가 변경/삭제할 개체를 참조하고 있을 경우, RESTRICT : 변경/삭제가 취소 (제한) CASCADE : 함께 변경/삭제 NOACTION : 변경/삭제할 개체만 변경/삭제되고 참조하고 있는 개체는 변동 X SET NULL : 참조하고 있는 값은 NULL로 세팅 ERD(Entity-Relationship Diagram) 보기 :상단의 Database 탭 - Reverse Engineer - Continue들 누르기 (Schema 선택하기) Sequelize Associations AssociationSequelize에서 관계를 정의할 때 지원하는 sequelize model의 sub classhasOne, belongsTo, belongsToMany, hasMany 가 있다. 1 : 1예시:12345db.User = require('./user')(sequelize, Sequelize);db.Profile = require('./profile')(sequelize, Sequelize);db.User.hasOne(db.Profile);db.Profile.belongsTo(db.User); 참고: 실습에서는 이 작업들을 models/index.js 에서 해줌 hasOne과 belongsTo가 반대로 되지 않도록 주의!!(belongsTo를 사용하는 모델에 외래키가 생성된다) 1 : M 예시:123456db.User = require('./user')(sequelize, Sequelize);db.Post = require('./post')(sequelize, Sequelize);// db.User.hasMany(db.Post);db.User.hasMany(db.Post, { foreignKey: { name: 'UserId', allowNull: false } , onDelete: 'cascade' });db.Post.belongsTo(db.User); 외래키 이름을 지정해주지 않으면 기본적으로 hasMany를 사용하는 테이블 이름 + Id 로 설정된다! On Delete의 기본값은 set Null, On Update의 기본값은 cascade 이다 M : N 예시:1234567891011121314151617181920212223242526272829303132333435363738/* M : N 관계를 위해 through 테이블을 연결해야 한다 */const { User, Post } = require('../models');module.exports = (sequelize, DataTypes) =&gt; { return sequelize.define('Like', { // 모델의 Attributes(Column) 정의 PostId: { type: DataTypes.INTEGER, reference: { model: Post, key: 'id', } }, UserId: { type: DataTypes.INTEGER, reference: { model: User, key: 'id', } }, }, { freezeTableName: true, timetables: true })}/* 이후는 위의 예시들처럼 association 정의 */db.User = require('/user')(sequelize, Sequelize)db.Post = require('/user')(sequelize, Sequelize)db.Like = require('/like')(sequelize, Sequelize)/* 1 : N User : Post */db.User.hasMany(db.Post, { onDelete: 'cascade' });db.Post.belongsTo(db.User);/* M : N User : Post =&gt; Like */db.User.belongsToMany(db.Post, { through: 'Like', as: 'Liked' });db.Post.belongsToMany(db.User, { through: 'Like', as: 'Liker' }); On Delete의 기본값은 cascade, On Update의 기본값은 cascade 이다 위의 예시의 경우 User Model은 Post Model과 두 번의 Association을 가진다! 따라서, User Model이 봤을 때 Post Model의 이름이 중복되지 않도록, as: 옵션으로 Model 이름을 바꾸어준다 JOINJOIN이란, 테이블간 공통된 컬럼(조건)으로 테이블을 합쳐 표현하는 것이다(이 글에서의 예시: User Model의 id 값으로 Post Model의 UserId 외래키를 연관지어 테이블을 합친다)include옵션을 이용하여 JOIN 할 수 있고, attributes를 통해 필요한 컬럼만 담아서 깔끔하게 조회할 수 있다. 예시:1234567891011const post = await Post.findAll( { attributes: ['title', 'contents'], include: [{ model: User, attributes: ['id', 'userName', 'email'], }, { model: User, as: 'Liker', attributes: { exclude: ['password', 'salt', 'id', 'email']} }]}); exclude 옵션은 쓴 컬럼들을 제외하고 read하는 옵션이다 모델이 여러 개인 경우에는 as 옵션으로 모델 별명을 만들어, 불러올 때 정확히 불러오자 실습 postController.js에서 사용한 쿼리 예시이다postController.js123456// 1. user를 Read하는 쿼리const user = await User.findOne({ where: { id: userId }});// 2. post를 Create하는 쿼리const post = await Post.create({ title, contents });// 3. 방금 생성한 Post에 외래키를 추가해주는 Update 쿼리 (Sequelize에서 제공하는 Special Method)await user.addPost(post); S3 + Multer MulterNodeJS에서 파일 업로드를 위해 사용되는 multipart/form-data를 다루기 위한 NodeJS Middleware npm install multer로 설치할 수 있다 multer.single(fieldname) : fieldname으로 파일 하나 받아서 req.file에 저장 multer.array(fieldname, maxCount) : fieldname으로 파일 여러 개 받아서 req.files에 저장 예시:123456789router.post('/single', upload.single('image'), async (req, res) =&gt; { // console.log(req.file); const image = req.file.location; res.send( { imageUrl: image, file: req.file, body: req.body });}); Postman 으로 쏴줄 때는 Body에서 form-data를 선택하여 쏴준다. AWS S3S3(Simple Storage Service): AWS에서 제공하는 클라우드 스토리지 서비스 프리티어 기준 용량 5GB, 월 당 업로드(PUT) 5000, 다운로드(GET) 20000회 가능 npm install multer-s3 aws-sdk로 두 개 설치해준다. config/s3.json에 accesskeyId, secretAccessKey, region 적어서 bucket으로의 접근 권한을 얻는다. 예시:123456789101112131415161718192021222324252627282930313233/* modules/multer.js 파일 */const multer = require('multer');const multerS3 = require('multer-s3');const aws = require('aws-sdk');aws.config.loadFromPath(__dirname + '/../config/s3.json');const s3 = new aws.S3();const upload = multer({ storage: multerS3({ s3, bucket: '&lt;bucket name&gt;', acl: 'public-read', key: function(req, file, cb) { // 이름 설정 cb(null, 'images/origin/' + Date.now() + '.' + file.originalname.split('.').pop()); } })});module.exports = upload;/* routes/multer/index.js 파일 */const upload = require('../../modules/multer');router.post('/single', upload.single('image'), async (req, res) =&gt; { // 본문 생략 ( 위 참조 )});/* config/s3.json 파일 */{ &quot;accessKeyId&quot;: &quot;&lt;S3 엑세스 키 아이디&gt;&quot;, &quot;secretAccessKey&quot;: &quot;&lt;S3 시크릿 엑세스 키 아이디&gt;&quot;, &quot;region&quot;: &quot;ap-northeast-2&quot;} config 폴더는 항상 .gitignore 파일에 명시하여 GitHub에 올라가지 않도록 한다!","link":"/2020/11/14/2020-11-14-Server-5th/"},{"title":"Hexo Blog Manual","text":"Commit Message Type [FEAT] : 새로운 기능 [BUG] : 버그 수정 [UPDATE] : 업데이트 [DOCS] : 문서 [TEST] : 테스트 [ETC] : 기타 Hexo 명령어 hexo server : 서버 실행 (http://localhost:4000) hexo new page about : /source/about 폴더에 index.md 파일이 생긴다. 페이지 생성 hexo new post 포스트명 : /source/_posts 폴더에 md 파일이 생긴다. 게시물 작성 hexo new draft 포스트명 : /source/_drafts 폴더에 md 파일이 생긴다. 초안 작성 /source/_drafts 폴더의 md들은 서버 배포해도 블로그에 표시되지 않는다. 포스팅이 끝나면 직접 _posts 로 옮겨주거나 hexo publish [layout] [파일명] 으로 옮겨줄 수 있다. (layout 생략하면 기본적으로 post) 로컬에서 draft를 테스트하고 싶다면 hexo server --draft 를 이용한다. hexo generate : 정적 리소스 생성 hexo deploy : 서버 배포 hexo deploy --generate 로 위의 두 과정을 동시에 할 수 있음 배포 정상적으로 됐는데 업데이트가 되지 않으면, hexo clean을 해준 후 다시 위의 코드 실행 기타 사항들( 기존의 Manual 게시물(Jekyll Blog)에서 추가된 사항들 ) Read More 버튼 생성: md 파일 중간에 &lt;!-- more --&gt; 적기 cover와 thumbnail: md 파일 상단에 cover: Pic URL, thumbnail: Pic URL 로 적으면 된다 md 파일 상단에 toc: true를 추가해 주면, markdown의 H1 ~ H6 에 맞게 CATALOGUE를 자동으로 생성해 준다! 2022.04.03 추가: noindex: true를 추가하면, noindex meta tag이 추가되어 구글 검색 결과에 나타나지 않는다. Hexo Tag PluginsBlock Quote 인자가 없는 일반 인용 123{% blockquote %}This is a quote{% endblockquote %} This is a quote 책 인용 123{% blockquote [Author], [BookName] %}This is a book quote{% endblockquote %} This is a book quote AuthorBookName 사이트 인용 123{% blockquote [Author] [URL] [SiteName] %}This is a site quote{% endblockquote %} This is a site quote AuthorSiteName Code Block123{% codeblock [title] [lang:language] [url] [link text] [options] %}codes{% endcodeblock %} Option들은 여기 에서 참고 Backtick Code Block위의 Code Block과 마찬가지로, language 뒤에 title, url, link text 를 추가할 수 있다! Youtube 비디오 추가1{% youtube [VideoId] %} 플레이리스트 추가1{% youtube [PlaylistId] 'playlist' %} Include Posts1{% post_link [post title] '[custom text]'%} Spoiler123{% spoiler &quot;제목 문구&quot; %}본문 내용{% endspoiler %}","link":"/2021/01/14/2021-01-14-Hexo-Blog-Manual/"},{"title":"CLion Manual","text":"아래 예시는 이 폴더 를 기준으로 함. 파일의 CMakeLists.txt라는 파일이 있는데,컴파일 하고자 하는 파일이 바뀔 때마다 이 파일을 바꿔주어야 함 12345678cmake_minimum_required(VERSION 3.16)project(프로젝트이름)// project(Baekjoon)set(CMAKE_CXX_STANDARD 14)add_executable(프로젝트이름 컴파일하려는파일이름)// add_executable(Baekjoon Baekjoon_9186.cpp) 위의 add_executable 안에 컴파일 하려는 이름을 넣어주면 된다. 2021.01.29. 추가:GitHub에서 cmake-build-debug 나, CMakeLists.txt 등 CLion에서 C++ 파일을 빌드하는데 필요한 폴더/파일들을 untrack 하도록 하였다.새로운 환경이라면, 세팅을 해 놓은 뒤 필요한 cpp 파일만 pull 받는 것이 합리적! (대충 git pull 로 전체를 pull 해와도 실행이 안 된다는 뜻)","link":"/2021/01/24/2021-01-24-CLion-Manual/"},{"title":"Baekjoon 9184 (신나는 함수 실행)","text":"Baekjoon 9184, 백준 9184 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int dp[21][21][21];int dpFunc(int a, int b, int c) { if(a &lt;= 0 || b &lt;= 0 || c &lt;= 0) return 1; else if(a &gt; 20 || b &gt; 20 || c &gt; 20) { return dpFunc(20, 20, 20); } else { // Already calculated once if(dp[a][b][c] != -1) { return dp[a][b][c]; } // Not calculated yet: calculate else { int temp; if(a &lt; b &amp;&amp; b &lt; c) temp = dpFunc(a, b, c - 1) + dpFunc(a, b - 1, c - 1) - dpFunc(a, b - 1, c); else temp = dpFunc(a-1, b, c) + dpFunc(a-1, b-1, c) + dpFunc(a-1, b, c-1) - dpFunc(a-1, b-1, c-1); dp[a][b][c] = temp; return temp; } }}int main() { // Initialization int a, b, c, ans; memset(dp, -1, sizeof(dp)); // if no value, dp = -1 // Solution (DP) while(true) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if(a == -1 &amp;&amp; b == -1 &amp;&amp; c == -1) break; else { ans = dpFunc(a, b, c); cout &lt;&lt; &quot;w(&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;, &quot; &lt;&lt; c &lt;&lt; &quot;) = &quot; &lt;&lt; ans &lt;&lt; endl; } }} 알고리즘을 공부해 두면 개발, 코테 등등 언젠가 도움이 된다는 말을 많이 듣기도 했고, 사실상 당장 급하게 할 것도 없다고 판단되어 2021.01.29. 일자로 알고리즘 공부를 다시 재개하게 되었다. 백준의 ‘단계별로 풀어보기’를 복습하면서 추가된 문제들을 해결할 예정이다! 현재 목표는 빠르게 백준의 “DFS와 BFS”까지 달려서 끝내고, 프로그래머스의 문제들 (대부분의 코테가 이 포멧으로 진행된다 해서,,) + CodeForces 기출문제로 넘어가는 것이다. 코테를 연습 삼아 보거나, CodeForces 티어를 따는 것도 목표 중에 있다. 좀 큰 목표로는 2021년 1학기 안에 보라색 티어를 가는 것!","link":"/2021/01/29/2021-01-29-Baekjoon-9184/"},{"title":"알고리즘 문제해결전략 Start","text":"당분간 Baekjoon 복습을 하면서, “알고리즘 문제해결전략” 이라는 책을 공부할 예정이다! 참고: APSS는 본 책을 의미하는 Algorithmic Problem Solving Strategies 의 약자이다. 한 단원씩 쪼개어 블로그에 포스팅 할 예정이다.단원이 길어지면 더 쪼개겠지만.. 암튼 화이팅해라(이번에 참가한 블로그 포스팅 스터디인 돈포켓포 8기 에 큰 활약을 할 예정 ㅎㅎ )","link":"/2021/02/01/2021-02-01-APSS-Start/"},{"title":"SEO 관련 문제 해결 과정들","text":"SEO (Search Engine Optimization) 문제 해결을 위한 글입니다. 2021.02.02.hexo-generator-seo-friendly-sitemap 을 이용하여 sitemap.xml 과 rss2.xml 을 자동 생성/갱신하고, 이를 Google Search Console에 올려둠.블로그 Sitemap 확인 2021.02.03.구글에 검색을 하면 본 블로그가 뜬다는 것을 확인함 site 옵션 사용 (site:yxxshin.github.io) 특정 검색어 입력 (Baekjoon 9184 등) 그러나, 다음의 문제들이 발견됨 발생한 SEO 문제들일부 검색 결과의 블로그 제목 뒤에 Baekjoon 9184 (신나는 함수 실행)이 붙어서 나옴 해결해야 할 문제 1순위. 그러나 왜 나타나는지, 나타나는 기준이 뭔지 5시간 뒤졌는데 찾지 못함. [02/03 23:00] 일단 빡쳐서 Baekjoon 9184 글을 내려버림. 원래 있는 글 제목이였음. [02/03 23:40] Baekjoon Cover와 Thumbnail이 Rendering 될 때 &lt;img alt = &quot;Baekjoon 9184 (신나는 함수 실행)&quot;&gt; 으로 들어가는 것을 확인함. 여기서 발생한 문제일까? (저 게시물을 쓸 때 처음으로 Thumbnail, Cover 만들어 넣음) 예전 게시물들 중에서도 이 문제가 발생하므로, 만약 이게 맞다면 RECENTS의 Thumbnail에서 발생한 문제 그럼 뜨고 안뜨고의 기준은? Sitemap.xml의 구글봇 업데이트 날짜 기준인가? [02/04 19:00] 찾아보니까 아님 섞여있음. 안 뜨는 게시물들이 평균 02/01 20:10 경에 업로드 되었다(저장된 페이지의 날짜)는 점이 억지로 찾아낸 공통점인데 말도 안 된다. 뭔 차이가 있는걸까. 그나저나 다음 업데이트는 도대체 언제 되는것인가 [02/03 02:00] Sitemap.xml 파일의 자동 갱신/업로드는 매우 잘 이루어지고 있었음. 다만 이 결과가 구글 검색창에 반영되기까지는 최소 하루 정도의 시간이 필요한 것 같음 (Google Bot이 다녀와야 하기 때문 - robots.txt 관련) [02/04 17:00] 블로그 기본 주소의 이름이 다음과 같이 뜨는 것을 발견. Baekjoon 문제 풀이의 미리보기에서 1 2 3 4 .. 의 숫자가 보이는 경우가 존재 내가 봐도 눌러서 들어오고 싶지 않다는 느낌이 든다. 고쳐야 하는 문제. [02/03 01:20] 숫자가 필자 코드의 줄 번호 임을 확인함. 어떤 기준으로 뜨고 안뜨는지는 모르겠음. [02/04 16:00] 우선 모든 Baekjoon 글의 앞 부분에 공통적으로 두 줄의 문장을 추가함. (미리보기 개선 + “백준 0000”으로 검색했을 때에도 내 블로그를 띄우기 위함). Deploy는 해 놓았지만 아직 구글 서버에 적용은 되지 않은 상황 2021.02.04.Google Search Console에서 정상적인 통계를 내기 위해서는 아직 조금 더 기다려야 하는 것 같다. 도대체 언제까지 ㅋㅋ 하 2021.02.05.02/05일에 Google에 새로 반영이 된 것을 확인하였다!! 믿고 있었다구 그리고 사실, 별 뭐 건드리지도 않았던 것 같은데 최근에 등록된 게시물들은 모두 정상적으로 뜬다. 개인적으로는 버그였나 싶다.. 바꾼 게 사실상 하나도 없기 때문이다.물론 개발을 하다 보면 상식 밖의 일들이 밥 먹듯이 일어나지만 …덕분에 굳이 알 필요가 있을까? 싶었던 SEO의 자세한 원리를 뜯어볼 수 있었다. 하지만 아직 고칠 사항들은 남아있다! 검색 문제이름도 뭐라 해야 될지 모르겠다. 나도 까먹을 것 같아서 정리하고 있다.글로 정리할까 말까 고민을 굉장히 많이 했는데 정리하는 것은 탁월한 판단이었다.. 우선, 한글 “백준”의 키워드로도 유입 되도록 하기 위해 모든 Baekjoon 글의 앞 부분에 공통적으로 문장을 추가하였고, 이것이 잘 뜨는 것을 확인하였다. 여기서 끝났으면 참 좋았을 텐데, “백준”으로는 뜨지 않고 “baekjoon”으로만 뜨는 애들이 있다. 보면, 기존의 모습과 똑같이 깨져 있고 타고 가보면 02/01에 저장된 상태로 구글에 적용되어 있다.얘넨 역시나 한글로 치면 죽어도 안 뜬다. 생각하는 경우의 수는 다음과 같다 아직 Google Bot이 적용하지 못함 (더 기다려야 함) 계속하여 바뀌는 이전 게시물들의 Sitemap 버그 (인식이 안 됨) 두 경우 다 현재 발생하고 있는 ‘무작위성’과 잘 어울리기 때문에..사실 이와 비슷한 가장 충격적인 사실은 블로그 제목이 Baekjoon 9184로 뜬다는 점이다 얘는 01/31일자의 저장된 페이지를 보여준다.이 뒤로 블로그 주소 자체는 건든 게 없으니, sitemap도 바뀐게 없어 업데이트가 되고 있지 않는 듯 하다.해결책으로는, Sitemap 초기화를 시켜주는 방법인데.. 사실 이게 초기화가 되는지도 모르겠다. Sitemap 파일을 내려도 크롤링은 이미 들어갔으니 말이다. Google Search Console 통계드디어! 거의 일주일 만에 Google Search Console에서 확인을 할 수 있게 되었다.확인해 보니, 57개가 유효하고 19개가 제외되었다고 한다. 도대체 왜? 우선은 다음과 같이 개별 URL에 대하여 재크롤링 요청을 하였다. Google 공식 문서 에서도 소수의 문서는 재크롤링 요청, 다수의 문서는 sitemap 업데이트를 통해 하라고 했다. 19개 정도면 거뜬히 노가다 할 수 있다. 필요한 문서들은 모두 재크롤링 요청을 보내놓았다.[02/05 19:00] 사실, 업데이트를 하는 것이 중요한 게 아니라 “어떤 검색 결과”를 타고 왔냐가 중요한 것 같다. 어떻게 이 구글 검색창에 뜨느냐에 따라 옛날에 저장된 페이지가 뜨기도, 최신 버전의 페이지가 뜨기도 한다 (미리보기로) 이 측면에서 생각하면 한방 싹 초기화를 시키는 게 깔끔하긴 한데.. 이게 오늘 밤의 목표가 될 것 같다 백준 사이트 이기기지옥의 9184번 문제와의 사투를 벌이는 과정에서 내가 크롤링 요청을 너무 많이 보냈나보다. 필터 없이 검색해도 백준 본 사이트보다 내 블로그가 먼저 뜬다 ㅋㅋㅋ9184번 글을 아예 서버에서 내렸었는데, 이거 보고 다시 올려놨다. URL 삭제Google Search Console에서 캐시된 URL 삭제 항목을 발견하여 시험삼아 게시물 두 개를 지워놨다. Google 공식 문서 이놈 처리 결과를 지켜보면 될 것 같다. 만약 이전의 자료들이 전부 사라지고 재크롤링된다면 아예 블로그 주소 삭제 요청을 해버려서 위에 언급했던 초기화가 가능할 수도 ..? 2021.02.06.다음과 같이 저장된 ‘캐시’ 내용이 모두 사라졌다. 이 경우 URL은 달려 있는데 (누르면 잘 뜸), 미리보기나 저장된 페이지가 아예 안 뜬다!다음번 크롤링 때 올바르게 적용이 되는지 확인해 보면 되겠다. 추가로, 블로그 제목은 그냥 최근 글을 따라가는 것 같다. 이건 고칠 수 있을지 모르겠다,, 사실 다른 방법으로 검색하면 아래와 같이 뜨기 때문이다. 2022.04.11 NEW PROBLEM군 입대를 하여, 자대에 잘 도착하고, 적응도 어느 정도 하여 싸지방에서 개인적인 공부들을 건드리기 시작할 때 쯔음 … 치명적인 하나의 문제를 알게 되었다. Desilo 를 Google에 검색하였을 때, 내 블로그의 인턴 게시물이 첫 페이지에 노출된다! SEO가 잘 작동한다는 것은 좋은 소식이나, 사실 게시물을 작성하기 전부터 내 인턴 글은 의도치 않은 구글 검색에 노출되는 것은 원하지 않았다. 예를 들어 Desilo 회사에 대하여 알아보기 위해 검색했는데, 내 블로그 게시물이 검색 결과에 노출된다 하자. 나쁜 말을 쓴 것은 아니다만, 어쨌든 회사의 사람들과 합의를 하거나 검사를 받고 올린 글은 아니지 않은가. (Desilo에 관한 인터뷰를 본인에게 직접 요청한 사람도 있었다. 이 사람도 이러한 경로로 나에게 찾아오지 않았을까?) 이를 의식하여 블로그 post의 front-matter 부분에 sitemap: false를 추가하여 블로그 sitemap에 자동 등록되는 것을 방지, 결과적으로 Google-bot도 이 페이지 정보를 얻어내지 못하여 (크롤링 실패) 검색 결과에 등장하지 않는 그림을 생각하였다. 허나 문제는, sitemap: false를 추가하기 전에 이미 블로그를 한 번 서버에 업로드를 하였고, 초기의 sitemap 버전에 인턴 글들이 모두 실렸으며, Google-bot이 초기 sitemap을 통해 이미 크롤링을 다 해버렸으며, 따라서 그 이후에 sitemap에서 페이지를 삭제한 것은 전혀 유효하지 않았다. 그래서 시도한 첫 번째 방법은 meta tag를 이용한 방법이었다. Google 공식 문서를 참고하였는데, 이 문서의 추천 방안은 다음과 같았다: robots.txt에서 없애는 것은 의미가 없으며 페이지의 &lt;head&gt; 섹션에 다음의 메타 태그를 추가하라: 1&lt;meta name=&quot;robots&quot; content=&quot;noindex&quot;&gt;이 기능 자체는 Hexo에 있는 기본적인 기능은 아니었기에, 블로그의 config 파일을 조금 손볼 필요가 있었다. 구글링(Hexo와 비슷하게 동작하는 다른 블로그들을 많이 참조하였다)과 소스코드 뜯어보기를 통해, layout의 head.jsx 파일에서 각 post의 &lt;head&gt; 섹션을 생성한다는 것을 알게 되었다. 내가 원하는 페이지에만 위의 메타 태그를 추가해야 했기에, post 마다 front-matter로 조절하는 것이 가장 쉽겠다고 판단하여 head.jsx 파일을 수정하여 noindex: true를 front-matter에 추가하면 위 메타 태그가 삽입되도록 하는 데에 성공하였다. (참고: Git Commit) 원하는 방향으로 모두 잘 작동하였다. 원하는 두 페이지에만 noindex 메타 태그가 삽입되었으며, HTML 파일이 생성되는 본인의 Github 이나 Chrome의 F12 DevTools(Elements)를 통해 이를 확인할 수 있었다. 허나, sitemap의 update가 이루어졌음에도 검색 결과에서 본인의 블로그가 삭제되지 않았다. 대 실패였다. 이 방법 역시 이미 한 번 크롤링된 문서를 다시 내려버릴 순 없는 것 같았다. (어찌 보면 당연한 결과이기도 하다) 결국 최후의 방법을 선택하게 되었다: 같은 글을 주소가 바뀌도록 재업로드 한다. 실제로 주소에 년/월/일 이 포함되므로, 작성한 날짜만 바꾸면 된다. 기존 글을 삭제한다. 기존 글은 이제 없는 페이지이므로 (404 Error), 구글에 삭제 요청을 직접 보낸다. 구글링 결과, Google Search Console Settings 에서 삭제된 콘텐츠를 Google 검색에서 삭제할 수 있었다. 결과는 성공이었다! 이틀 정도 기다리니 Google Search Console Settings에서 보낸 삭제 요청이 승인됨을 확인할 수 있었고, 이제 더 이상 Google에 Desilo를 검색했을 때 본인의 블로그 인턴 정리글이 나타나지 않았다.","link":"/2021/02/03/2021-02-03-SEO-Test/"},{"title":"APSS 1. 문제 해결과 프로그래밍 대회","text":"연습문제 채점 방법알고스팟 에서 모든 연습문제에 대해 제출 및 채점을 할 수 있다 프로그래밍 대회ACM-ICPC (ACM 대학생 프로그래밍 경시대회) 3명이 한 팀으로 5시간, 8~10문제 상위 입상 팀은 다른 나라의 세계 결선에 참가할 자격을 얻는다 탑코더 (TopCoder) 알고리즘 뿐만 아니라 다양한 트랙이 있다 알고리즘 트랙은 1시간 15분, 3문제 1~2주 간격으로 온라인 대회 개최한다 구글 코드 잼 (Google Code Jam) 구글이 개최하는 프로그래밍 대회 코드포스 (CodeForces) 성적을 점수화하여 공개 (개인) 백준 아이디 색깔 바꿀 수 있음. 간지작살 온라인 채점 사이트 (대회 준비)알고스팟 초, 중급자용 백준 초, 중급자용 다양한 한글 문제 USACO Training Program 초, 중급자용 강좌, 난이도 순서 문제 제공, 실패한 입력 알려줌(친절) TopCoder 중급자용 기출 문제를 풀고 채점받을 수 있음 대회 아레나 내에서 프로그램을 작성해야 하며, 디버그가 어려움 ACM-ICPC Live Archive 중급자용 Project Euler 중급자용 SPOJ Online Judge 상급자용 수준 높은 문제들이 많음 당연히, 가능한 한 많은 프로그래밍 대회에 참여하는 것이 중요하다! 팀 단위 연습을 위한 조언 종이 위에 답안 스케치 ( 자료 구조 / 함수 이름 / 수도코드 미리 구상 ) 치밀한 역할 분담 페어 프로그래밍 연습 디버거 없이 디버깅하기 인쇄 대기 감소를 위한 두 화면 분할 ( vim )","link":"/2021/02/05/2021-02-05-APSS-1/"},{"title":"Baekjoon 17298 (오큰수)","text":"Baekjoon 17298, 백준 17298 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;utility&gt;#include &lt;stack&gt;#define MAX_N 1000000int NGE[MAX_N+2];int main() { // Initialization int N; scanf(&quot;%d&quot;, &amp;N); std::pair&lt;int, int&gt; *pairArr = new std::pair&lt;int, int&gt;[N+2]; // save &lt;i, Ai&gt; for(int i = 1; i &lt;= N; i++) { pairArr[i].first = i; scanf(&quot;%d&quot;, &amp;pairArr[i].second); } // Initialize array NGE to -1 memset(NGE, -1, sizeof(NGE)); // Use a stack to solve problem std::stack&lt;std::pair&lt;int, int&gt;&gt; s; // Push pairs to the stack for(int i = 1; i &lt;= N; i++) { // Pop every member in stack while pairArr[i].second is smaller than s.top() if(!s.empty()) { while(pairArr[i].second &gt; s.top().second) { std::pair&lt;int, int&gt; topPair = s.top(); s.pop(); // Update topPair's NGE info NGE[topPair.first] = pairArr[i].second; if(s.empty()) break; } } s.push(pairArr[i]); } // Print answer for(int i = 1; i &lt;= N; i++) { printf(&quot;%d &quot;, NGE[i]); } delete[] pairArr;} 이 문제의 경우에도 스택 단원에 있었기에 자연스럽게 힌트를 받고 들어가게 되었다. 아마 그렇지 않았다면 조금의 시간 투자가 더 필요했을 것이다. 채점 시에 70% 안팎에서 ‘틀렸습니다’ 가 떠서 특정 케이스에서 에러가 나는 것을 확인하였다. 다양한 경우를 디버깅 해보다가, 본인의 같은 코드와 같은 Input을 넣었을 때 10번 중 1번 꼴로 이상한 값이 섞여 나타나는 것을 확인하였다. 여기서 디버깅의 핵심이 됐던 점은 이상한 값의 범위 였다. 대략 32700 안팎의 랜덤 숫자가 포함되었는데, 여기서 $2^{15} = 32768$ 임을 떠올려 어디선가 overflow가 되지 않았을까..? 하는 생각을 해보게 되었다. 결국 배열을 너무 타이트하게 동적할당 해 주어 생긴 문제임을 알게 되었다. 보통 “아 이거 맞았다!” 했을 때 ‘틀렸습니다’를 맞이하면, 쉬운 부분에서 실수를 한 케이스다. 이 문제는 20분만에 찾았지만, 실제로 CP를 할 때라던지 코테를 볼 때는 치명적인 시간이 된다. 그런 면에서 한 가지 실수 요소를 배우게 되었으니 나름 유익한 삽질이였다고 생각한다. 본인은 풀이에서 기본적으로 pair를 하나의 요소로 두고 다루었다. pair가 담긴 stack이라던지 등등. 그러나 제출한 후에 다른 분들의 코드를 살펴보니 굳이 그럴 필요가 없음을 깨달았다. 내가 pair로 지정한 이유는 &lt; int, int &gt; = &lt; $i$, $A_i$ &gt; 와 같이 각 $A_i$ 의 값에 $i$ 의 정보를 계속 달고 다니게 하기 위해서였는데, 결국 로직 상 $A_i$ 가 순서대로 저장되기 때문에 $i$의 정보는 필요가 없었다. 본 코드는 짧은 편이었어서 pair로 복잡하게 짜도 시간이 오래 걸리거나 코드가 꼬이는 일은 없었지만, 앞으로는 전반적인 아이디어를 잡은 후, 구체화하는 과정에서 최대한 단순화 하는 것이 실수를 줄일 수 있는 방향이라고 생각하였다.","link":"/2021/02/09/2021-02-09-Baekjoon-17298/"},{"title":"Baekjoon 13305 (주유소)","text":"Baekjoon 13305, 백준 13305 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#define MAX_N 100000int N, road[MAX_N+3], gas[MAX_N+3];int main() { // Initialization: save inputs scanf(&quot;%d&quot;, &amp;N); for(int i = 0; i &lt; N-1; i++) { scanf(&quot;%d&quot;, &amp;road[i]); } for(int i = 0; i &lt; N; i++) { scanf(&quot;%d&quot;, &amp;gas[i]); } long long totalMoney = 0; // total money int gasVal = gas[0]; // lowest gas value until now (Greedy Algorithm) int roadNum = 0; // road number (0 to N-1) while(true) { totalMoney += (long long)gasVal * road[roadNum]; roadNum++; if(gas[roadNum] &lt; gasVal) { // Greedy: Use the new gas value from now on gasVal = gas[roadNum]; } if(roadNum == N) { // Finish Algorithm break; } } printf(&quot;%lld\\n&quot;, totalMoney);} 본 문제는 그리디 알고리즘 (Greedy Algorithm) 을 사용하는 문제였다. 예전부터 언급해왔던 ‘백준 단계별로 풀어보기’의 치명적인 단점은 단계 명에서 어떠한 알고리즘을 사용해야 하는지 친절하게 알려준다는 점이다. 사실상 거대한 힌트를 얻고 들어가는 것이니…본 문제는 자체로 어려운 문제는 아니였고, 그리디 알고리즘을 사용하라는 힌트를 받으면 더 쉬워지는 문제였다. 이 정도라면 힌트 없이도 무난하게 그리디로 풀겠다는 감을 잡을 수 있지 않을까? 아이디어는 여태까지 나온 최고 저렴한 기름으로 최대한 많이 이동하는 것 이다. 별 다른 증명 없이 꽤 깔끔하게 이 사실이 받아들여진다. 그럼에도 불구하고 세 번이나 틀렸습니다 를 마주했는데, 범인은 int의 자료형 초과였다. 변수에서, 그리고 형변환 시에 unsigned long을 명시해 주니 바로 통과할 수 있었다. 롱태식이 오랜만이다!","link":"/2021/02/09/2021-02-09-Baekjoon-13305/"},{"title":"Baekjoon 1707 (이분 그래프) + 그래프 저장 방법","text":"Baekjoon 1707, 백준 1707 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define MAX_V 20000#define NOT_VISITED 0#define WHITE 1#define BLACK 2std::vector&lt;int&gt; graph[MAX_V + 1];// graph[i]: vector of dots connected with dot iint colors[MAX_V + 2]; // 0: NOT_VISITED, 1: WHITE, 2: BLACKbool isBip;void init() { isBip = true; for(int i = 0; i &lt;= MAX_V; i++) { graph[i].clear(); } memset(colors, NOT_VISITED, sizeof(colors));}void dfs(int start) { for(int i = 0; i &lt; graph[start].size(); i++) { int tempDot = graph[start][i]; if(colors[tempDot] == NOT_VISITED) { // if not visited, give an opposite color with mine if(colors[start] == WHITE) colors[tempDot] = BLACK; else if(colors[start] == BLACK) colors[tempDot] = WHITE; dfs(tempDot); } else if(colors[tempDot] == colors[start]) { // if two connected dots have the same color, this graph cannot be a Bipartite Graph isBip = false; return; } }}int main() { int testNum; scanf(&quot;%d&quot;, &amp;testNum); while(testNum--) { int V, E; scanf(&quot;%d %d&quot;, &amp;V, &amp;E); init(); while(E--) { int a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); // save the connection a-b to 'graph' graph[a].push_back(b); graph[b].push_back(a); } for(int i = 1; i &lt;= V; i++) { if(colors[i] == NOT_VISITED) { // if dot i is not visited, start dfs // Considering a non-connected graph colors[i] = WHITE; dfs(i); } } if(isBip) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); }} 문제를 보고 DFS로 해결해야겠다는 아이디어 자체는 쉽게 떠올랐다. 점들에 색칠놀이를 해 주면 되기 때문이다. 사실, 이분그래프(Bipartite Graph)의 정의는 인접한 점들은 다른 색이 되도록 칠할 수 있는 그래프 이다. 그리고 이는 본 문제에서 준 조건인 그래프의 정점의 집합을 둘로 분할하여, 각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때, 그러한 그래프 와 동치이다. 그래서 잘 구현만 해주면 됐는데, 생각보다 여기서 엄청난 삽질을 했다. 결론적으로 데이터 저장을 너무 바보처럼 하고 있었다! 오랜만이라 그래프 정보를 저장하는 것도 까먹고 무식하게 std::pair 로 쑤셔넣고 있었다.. Adjacency List로 넣어 주니 훨씬 간결하게 해결할 수 있었다. Linked List까지 구현할 필요도 없었고 그냥 std::vector 들의 array로 구현해도 충분했다. 이걸 부르는 다른 이름이 있었나? 문제에 대한 큰 틀의 참고사항들은 다음과 같다. 연결그래프가 아닐 수 있어서 for 문으로 전체 점에 대한 DFS를 돌려주어야 한다. 실제로 이 문제의 ‘틀렸습니다’의 단골 사유라고 한다. 본인은 이런 문제 유형상 DFS가 효율이 더 좋을 것 같아서 DFS로 구현을 시도하고 성공했지만, 사실 BFS로 돌려도 상관 없다. 어차피 건드릴 수 있는 모든 점들을 들러서 색칠해 주어야 하기 때문이다. 아래는 그래프 정보를 저장하는 가장 유명한 세 가지 방법인 Binary-relationship list, Adjacency Matrix와 Adjacency List를 정리해 두겠다. 출처는 아래의 2020-2학기에 들었던 이병영 교수님의 ‘자료구조의 기초’ 수업 메모.. Binary-relationship List말 그대로 인접한 $(v_j, v_k)$ 들의 쌍을 모두 담은 리스트 인접 판단: $O(|E|)$ 이웃 찾기: $\\Theta(|E|)$ 메모리: $\\Theta(|E|)$ Adjacency Matrix2차원 배열을 이용하여, 선 $(v_j, v_k)$가 있으면 $(j, k)$에 true와 같은 표시를 해주는 방법. 더 나아가, 선의 가중치를 배열에 적어줄 수도 있다. 인접 판단: $O(1)$ 이웃 찾기: $\\Theta(|V|)$ 메모리: $\\Theta(|V|^2)$ Adjacency List각 점에 대하여, 그 점과 이웃한 점들을 Linked List의 형태로 저장하는 방법 인접 판단: (평균) $O({|E| \\over |V|})$ 이웃 찾기: $\\Theta({|E| \\over |V|})$ 메모리: $\\Theta(|V|+|E|)$ 사진 출처: Adjacency Matrix Adjacency List","link":"/2021/02/15/2021-02-15-Baekjoon-1707/"},{"title":"Baekjoon 2629 (양팔저울)","text":"Baekjoon 2629, 백준 2629 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#define MAX_WEIGHT 500#define MAX_WEIGHT_NUM 30#define MAX_WEIGHT_VAL 40000#define MAX_TEST_NUM 7int main() { // Initialization: save inputs int weight_num, test_num; int W[MAX_WEIGHT_NUM + 2], T[MAX_TEST_NUM + 2]; scanf(&quot;%d&quot;, &amp;weight_num); for(int i = 0; i &lt; weight_num; i++){ scanf(&quot;%d&quot;, &amp;W[i]); } scanf(&quot;%d&quot;, &amp;test_num); for(int i = 0; i &lt; test_num; i++){ scanf(&quot;%d&quot;, &amp;T[i]); } // Using 2D-array for DP // if using 0th~ith weight can make weight j, DP[i][j] = true bool DP[MAX_WEIGHT_NUM+2][MAX_WEIGHT_VAL+2] = {false}; DP[0][W[0]] = true; DP[0][0] = true; // Set values of array DP for(int i = 1; i &lt; weight_num; i++) { for(int j = 0; j &lt; MAX_WEIGHT_VAL; j++) { DP[i][j] = DP[i-1][j] or DP[i-1][std::abs(j+W[i])] or DP[i-1][std::abs(j-W[i])]; } } for(int i = 0; i &lt; test_num; i++) { if(DP[weight_num - 1][T[i]]) printf(&quot;Y&quot;); else printf(&quot;N&quot;); if(i != test_num - 1) printf(&quot; &quot;); }} 2차원 배열로 DP를 돌리는, 어찌 보면 유명한 유형의 DP(동적 계획법) 문제라고 할 수 있겠다. 문제 설명에는 ‘냅색 알고리즘’ 이라고 나와 있다.본인은 다음의 두 가지를 고려하지 못하여 한 번씩 틀리고 세 번째 제출에 ‘맞았습니다’를 볼 수 있었다. 답안 출력 형태여러 숫자들이 space 한 칸을 기준으로 나열되는데, for 문에서 출력 -&gt; space 이런 식으로 하니 마지막 답안의 뒤에도 자연스럽게 space가 붙어서 나온다. 사실 이 때문에 ‘틀렸습니다’가 뜨는지는 모르겠으나, 엄밀히 따지면 문제에도 답안 사이에만 공백을 두라는 말이 있으므로 틀렸다고 해도 할 말은 없다. 이렇게 한 try를 날리면 아쉬우니까 꼭꼭 답안 출력 형태를 꼼꼼히 보자. DP 초기화본인은 DP[0][W[0]] = true 만을 두었었는데, DP[0][0] = true 도 해 주어야 한다. (0번째 추를 사용하지 않는 경우) 명백한 실수! 실수 줄이자.","link":"/2021/02/15/2021-02-15-Baekjoon-2629/"},{"title":"Baekjoon 7562 (나이트의 이동)","text":"Baekjoon 7562, 백준 7562 문제의 본인 풀이입니다!문제는 아래의 링크에서 확인할 수 있습니다.문제보기 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX_LEN 300typedef struct Knight { int X; int Y; int dist;};// 8 ways of Knight movingint direction[8][2] = { {2,1}, {1,2}, {-1,2}, {-2,1}, {-2,-1}, {-1,-2}, {1,-2}, {2,-1} };int main() { int testNum; scanf(&quot;%d&quot;, &amp;testNum); while(testNum--) { // Save inputs int boardLen, startX, startY, endX, endY; scanf(&quot;%d&quot;, &amp;boardLen); scanf(&quot;%d %d&quot;, &amp;startX, &amp;startY); scanf(&quot;%d %d&quot;, &amp;endX, &amp;endY); // BFS Settings bool board[MAX_LEN+2][MAX_LEN+2]; // board[X][Y] = true if visited (X,Y) memset(board, false, sizeof(board)); std::queue&lt;Knight&gt; q; q.push(Knight{startX, startY, 0}); // Solve by BFS while(!q.empty()) { Knight topKnight = q.front(); board[topKnight.X][topKnight.Y] = topKnight.dist; if(topKnight.X == endX &amp;&amp; topKnight.Y == endY) { // Arrived at the destination printf(&quot;%d\\n&quot;, topKnight.dist); break; } // push next 8 locations to queue (if valid) for(int i = 0; i &lt; 8; i++) { int tempX = topKnight.X + direction[i][0]; int tempY = topKnight.Y + direction[i][1]; // check if valid location if(tempX &gt;= 0 &amp;&amp; tempX &lt; boardLen &amp;&amp; tempY &gt;= 0 &amp;&amp; tempY &lt; boardLen) { // only push when not visited before if(!board[tempX][tempY]) { q.push(Knight{tempX, tempY, topKnight.dist + 1}); board[tempX][tempY] = true; // check visited } } } // pop the top Knight of queue q.pop(); } }} 흔한 유형의 BFS 문제였다. 문제를 보면 어 BFS인가?! 하는 느낌이 바로 온다.본 코드만의 특징이라면 Knight 구조체를 이용하여 복잡한 STL의 사용 없이 직관적으로 쓰고, direction 배열을 이용하여 노가다성 코드를 최소화한 점..? 구조체는 워낙 유명하니 쓰면 좋고, direction 배열을 이용하는 아이디어는 많은 곳에서 적용이 될 것 같다. (본인도 처음 미로찾기 DP 문제 풀 때 다른 사람의 코드에서 참고했던 것 같다)","link":"/2021/02/15/2021-02-15-Baekjoon-7562/"},{"title":"CP 꿀팁","text":"CP는 무엇보다도 푸는 시간이 짧아야 한다. 쉬운 A B 문제들을 얼마나 빠르고 정확하게 푸느냐가 대회의 성적에 꽤나 많은 영향을 준다. 본 게시글에서는 이에 대한 꿀팁들을 정리해 놓으려고 한다. bits/stdc++.h 헤더가장 많이 알려져 있는 꿀팁이다. 모든 C++ 표준 라이브러리가 포함된 헤더이다. 표준 헤더가 아니기 때문에 GCC가 아닌 컴파일러로는 컴파일(인식)이 되지 않지만 백준, 코드포스, ACM-ICPC와 같이 GCC를 컴파일러로 사용하는 대회에서 유용하게 사용된다. 헤더 부분이 지저분해지는 것을 방지할 수 있고, 컴파일 시간은 오래 걸리지만 코딩 시간은 줄일 수 있다! 하지만, 필자는 다음의 이유로 사용하지 않기로 결정하였다. 굉장히 안 좋은 습관이 든다. 컴파일 시간의 차이가 결국 라이브러리 한 문장 추가하는 것과 차이가 없다는 의견 CLion에서 헤더 인식을 못함 도대체 외않되? Debugging Header (dbg.h)dbg.h 헤더를 이용한 디버깅을 이용한다. printf를 이용해서도 할 수 있지만 우선 적어주기도 귀찮고(시간이 오래 걸리고), 온라인 저지에 제출할 때 지워줘야 하기 때문에 헤더를 이용하는 것을 추천한다. (또한, map과 같은 STL을 사용할 때 반복문 없이 모든 요소들을 print해 준다) dbg.h 헤더는 이 주소의 헤더를 사용하였다. (설명법도 적혀 있다) 사용법으로는 우선 헤더를 인식 가능한 위치에 저장해 두고, 다음의 코드를 위에 추가해 준다.12345#ifdef __APPLE__#include &quot;dbg.h&quot;#else#define dbg(...)#endif간단한 코드인데, #ifdef __APPLE__ 에서 컴파일러가 Mac OS 임을 검사한다. 본인의 컴퓨터인 맥북에서는 dbg.h 헤더를 include하여 사용하고, 그 외에는 무시한다. 추가로, 윈도우의 경우에는 #ifdef WIN32나 #ifdef WIN64를 사용하면 될 것이다. (확인해보지 않았음) 이후, dbg(변수); 를 해주면 console 창에 변수의 값과 자료형이 적힌다. C++에서 string 입력 받기공백이 포함된 한 줄 전체를 string으로 받아올 때는 다음과 같이 getline을 사용할 수 있다.12string str;getline(cin, str); 그래프 그려주는 툴https://csacademy.com/app/graph_editor/ 입력 개수가 명시되지 않은 입력 받기C++의 경우에는 while(cin &lt;&lt; n) 으로 받을수 있으며, C의 경우에는 다음과 같이 받을 수 있다.1234int n;while(scanf(&quot;%d&quot;,&amp;n) != EOF) { // code} { } 로 컨테이너 값 입력하기make_pair와 같은 함수를 사용하지 않고, 간단하게 { } 를 사용하여 값을 초기화해 줄 수 있다.1234pair &lt;int, int&gt; p;p = {3,4};// this is same with// p = make_pair(3,4);stack, queue를 제외한 컨테이너(pair, vector, deque, set, list, array, tuple)에는 모두 적용 가능하다. 유용한 함수들GCDstd::gcd(value1, value2) : 최대공약수 빠르게 구하기 (유클리드 호제법 사용 안해도 됨)#include &lt;numeric&gt; 해주어야 한다. 특정 값으로 배열 초기화memset(a, 2, sizeof(a)) : 배열 a를 2로 초기화 (for문 보다 빠를 수도 있다 - 컴파일러 따라 다름)#include &lt;cstring&gt; 해주어야 한다. 여러 값의 minmin({a, b, c, d, ...}) 와 같이 쓰면, 여러 값들의 최소값을 한 번에 구할 수 있다. push_back 대신 emplace_backemplace_back()이 push_back() 보다 빠르다고 한다. 사용법은 같다. 출처1출처2출처3","link":"/2021/02/16/2021-02-16-CP-Tips/"},{"title":"CP, CodeForces 가이드","text":"본 글에서는 CP와 CodeForces에 대한 가이드를 제시한다. CP (Competitive Programming) 이란CP보다는 PS(Programming Solving) 이라는 단어가 훨씬 익숙할 것이다. 사실 두 개의 단어는 꽤 많이 혼동되고 있고 사람마다 사용하는 의미가 다르다. 흔히 우리가 알고리즘 문제를 푸는 것을 PS라고 하며, CP는 말 그대로 빠르게 코드를 짜야 하는 “경쟁적 코딩” 이다. 개인적으로는 다음과 같이 생각하고 있고, 앞으로 이 블로그에서도 이렇게 사용할 예정이다. PS는 알고리즘 문제 풀기, CP는 그 중에서 빨리 짜야 하는 경우 CP의 예시: 코테 (코딩테스트), CodeForces Contest 등등 CP는 PS에 포함되는 용어 그러나 CP랑 PS를 구분하지 않는 경우도 다반수이며, 포럼에도 이런 토론이 많이 올라와 있다. 이 블로그의 게시글에 의하면, 일본과 중국의 경우에는 어느 정도 통일된 용어가 이용되는 것 같다. 필자는 그래도 느긋하게 고민하면서 백준 푸는 거랑, 최대한 빠르게 코드를 짜는 CodeForce Contest에는 확연한 차이가 있는 것 같아서 나누어 부르려고 한다. CodeForces 이란CodeForces는 정확히는 알고리즘 대회가 열리는 사이트이고, 이 대회를 그냥 CodeForces 대회라고 보통 부른다. 본인 블로그의 이 글에서도 등장한다! 레이팅과 Division우선 레이팅이라는 것이 존재한다. 게임에서의 MMR(Matchmaking Rating)과 유사한 개념이라고 생각하면 편하다. 참여한 대회의 상대적인 성적에 따라 이 레이팅이 변동한다. 레이팅 등급에 따라 색깔이 부여되며, 아래의 표와 같다. 백준에서 이름에 색깔이 입혀진 경우를 본 적 있을텐데, 백준에서 CodeForces와 연동을 하여 이 등급 색깔이 백준에 표기되는 것이다. 첫 Contest를 보면 1400점에서 시작하며, 점수가 떨어지지 않는다면 저 민트색이 된다. 몇 번 더 점수를 올리면 파랑이가 될 수 있다. 개인적인 목표는 바이올렛이다! 바이올렛은 상위 7%에 해당하니, 롤로 따지면 플레4 정도에 해당한다. 플레 정도면 어디가서 롤 좀 한다고 말할 수 있지 않나?ㅎㅎ 위의 표를 보면 Division 이라는 것이 있는데, 이는 대회 난이도라고 생각하면 된다. 바이올렛이 되어야 Division 1에 참가할 수 있으며, Division 1 부터는 복잡한 개념들과 어려운 알고리즘들이 등장한다. 다른 말로 말하면, Division 2와 3에서는 어려운 알고리즘들이 등장하지 않는다. 이 블로그의 게시글에 의하면 퍼플까지 Math, DP, Greedy, DFS/BFS, Prefix Sum, 기본적인 Tree 개념, Disjoint-set Union, Binary Search 정도만 알아도 충분히 도달할 수 있다고 말한다. 또한, 고급 알고리즘을 요구하는 문제는 나오지 않지만 알고 있다면 다른 문제들을 풀 때 영향을 줄 수 있다고 언급한다. 즉, 고급 알고리즘들의 작은 구현들이나 아이디어들은 이용할 수 있는 것이다. 역시 아는 만큼 보인다! 대회 참가굉장히 대회가 자주 열린다. 일주일에 최소 두 번 정도? CodeForces 사이트의 Contest 탭에서 다음 대회 일정을 확인 및 Register 할 수 있다. Register는 시험 시간 24시간 전부터 가능하며, 대부분의 시험은 우리나라 기준 23:35 ~ 01:35 의 2시간동안 이루어진다. 필자는 2021.02.16 일자의 Codeforces Round #702 (Div.3)을 처음으로 도전할 예정이다. 본의 아니게 Division 3부터 시작하게 되었는데, 맛보기 느낌으로 시작하면 될 것 같다 ㅎㅎ (Division 3이 Division 2보다 쉽다) [2021.02.18] Codeforces Round #703 (Div.2)을 처음으로 시작하였다! 대회 규칙대회는 보통 A ~ E 나 A ~ F 의 5~6 문제로 이루어진다. 보통 쉬운 난이도가 앞쪽에 배치되어 있는데, 그렇지 않을 때도 있다. 보통은 푼 사람 수가 실시간으로 뜨기 때문에, 이를 이용해서 쉬운 문제를 먼저 접근해 보는 것이 유리하다. 문제의 점수는 A부터 점점 올라가며, 시간이 지날수록 점차 감소한다 (1분이 지날때마다 2점씩 감소). WA(Wrong Answer, 틀렸습니다)를 받을 때마다 50점이 감소한다(원래 문제 점수의 30% 아래로는 떨어지지 않는다). 이 점수 체계가 빠르고 정확한 문제풀이를 요구한다. 참고로, 기존의 코드 복붙 제출이 가능하다. 또한, 꽤나 복잡한 Hack이라는 시스템이 있다. 우선, 대회 시간 내에 채점을 할 때는 대략 15개 정도의 테스트 케이스(Pretest)만 이용한다. 따라서 실제로 코드가 완벽하지 않더라도 Accepted가 될 수 있다. 다른 참가자의 Accepted 된 코드에서 에러를 일으키는 반례 테스트 케이스를 찾는 것을 Hack 이라고 한다. Hack에 성공하면 100점을 얻고, 실패하면 50점을 잃는다. (단, 컴파일 에러나 아예 첫 번째 테스트 케이스부터 오답이 발생하면 점수가 차감되지 않는다). Hack을 하기 위한 조건은 다음과 같다. Hack을 할 대상이 나와 같은 Room (대회에서 임의로 배정해 주는 그룹)에 있어야 한다. 내가 Pretest에 통과한 문제이고 Lock을 해야 한다. Lock은 Pretest에 통과한 문제의 제출을 더 이상 하지 않겠다는 선언이다. Lock을 해야만 다른 사람의 코드를 보고 Hack을 시도할 수 있다. Hack을 당하면 CodeForces 사이트에서 알람이 온다. 만약 Lock을 하지 않았다면 오류를 고쳐 재제출을 해야 할 것이고, Lock을 이미 했다면 어쩔 수 없이 틀린 문제가 된다. 조금 덧붙이자면, Hack을 당하지 않도록 코드를 의도적으로 지저분하게 적는 것은 결국 자신에게 손해이다. 빨리 Hack을 당해야 고쳐서 제출할 수 있기 때문이다. Hack이 될 코드는 어차피 System Test에서 걸러진다는 뜻 대회가 모두 끝난 이후, Pretest를 통과한 코드들에 대해 60개 이상의 테스트 코드로 재채점이 이루어진다(System Test). 이 System test가 통과해야 비로소 해당하는 점수를 받는다. Virtual Contest기존에 시행되었던 대회를 “실제로 시험장에 있었던 것처럼” 참여할 수 있다. 지나간 대회에서 Virtual Participation 을 누르면 된다. 2시간을 똑같이 재고 풀게 되며, 시험장 기준으로 현재 등수도 확인할 수 있다! 개인적으로 CodeForces 사이트에서 가장 마음에 드는 기능이다. CP 용어 정리업솔빙 (Upsolving)대회가 끝난 후에 문제를 푸는 것. 실제로 업솔빙을 해야 실력이 효율적으로 는다는 의견이 굉장히 많다. ACAccepted, 맞았습니다! 를 의미. 보통 초록색 WAWrong Answer, 틀렸습니다 를 의미. 보통 빨간색 TLETime Limit Exceeded, 시간 제한 초과 MLEMemory Limit Exceeded, 메모리 제한 초과 RERuntime Error, 런타임 에러 (접근 불가능한 영역에 접근하는 경우가 대부분) CECompile Error, 컴파일 에러 올솔All Solve로, 모든 문제를 풀었다는 뜻이다. 맞왜틀 / 틀왜맞맞았는데 왜 틀려, 틀렸는데 왜 맞아 를 의미. 좌셋모든 문제가 풀렸으면서, 모든 문제를 푼 사람은 없는 문제 셋을 의미.모든 문제가 풀렸기 때문에 대회 시간 내에 풀 수 있는 문제들이라는 뜻이며, 모든 문제를 푼 사람은 없기 때문에 변별력이 있었다는 뜻이다. 좌셋은 성공적인 대회, 좋은 대회의 기준이 되기도 한다. 대회 규칙 작성 시 참고 &amp; 사진 출처용어 정리 작성 시 참고","link":"/2021/02/16/2021-02-16-CodeForces-Manual/"},{"title":"01. CodeForces Round #703 (Div.2) 풀이 &amp; 후기","text":"대회 소감첫 번째 CodeForces 대회였다. 당분간 초점은 무조건 적응이다. 나는 알고리즘의 굉장한 실력자가 결코 아니기 때문에 쉬운 A, B번 문제를 얼마나 빨리 푸는가가 생각보다 점수와 등수를 많이 가른다. 허나 본인은 여기에 삽질까지 추가로 해버리고 있기 때문에.. 어서 타임어택의 CP에 적응해야 한다. 다음의 사항들에 중점적으로 적응하도록 하자. C 개발환경의 문제 (형변환, 오버플로우, 함수 용법) 문제 똑바로 읽고 이해하기 대부분의 A는 쉬운 수학인데, 확실하게 풀고 코드로 옮기자 시간 복잡도 계산해보고 코드로 넘어가기 TLE가 떴다면, 아예 다른 접근으로 생각하기 풀이A (Shifting Stacks)문제 보기 A번 문제 풀이 + 본인의 코드 stack의 이동이 i → i+1 로의 커지는 방향으로만 가능했다는 것을 읽지 못하여 try를 2번이나 소모하였다. 깨달은 후에 바로 해결한 쉬운 수학문제 교훈 문제를 꼼꼼히 읽자 'Round #703 - A.cpp : AC'123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;using namespace std;#ifdef __APPLE__#include &quot;dbg.h&quot;#else#define dbg(...)#endifint main() { int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { int n; bool flag = false; long long sum = 0; scanf(&quot;%d&quot;, &amp;n); long long h[102]; for(int i = 0; i &lt; n; i++) { scanf(&quot;%lld&quot;, &amp;h[i]); } for(int i = 0; i &lt; n-1; i++) { h[i+1] += h[i] - i; if(h[i+1] &lt; i+1) { flag = true; break; } } if(flag) printf(&quot;NO\\n&quot;); else printf(&quot;YES\\n&quot;); }} B (Eastern Exhibition)문제 보기 B번 문제 풀이 + 본인의 코드 삽질하느라 A번이 늦었던 것 치고 굉장히 빨리 B번을 해결하였다. $|x_1 - x_2| + |y_1 - y_2|$에서 앞 두 항이 완벽하게 독립이라는 사실을 바로 캐치하였고, 이어서 홀수일 때는 답이 항상 1이라는 것을 알아냈다. 이처럼 쉬운 수학 문제의 경우에는 규칙 찾기가 굉장히 중요하다는 교훈을 얻었다. 처음에 문제를 보자마자 쫄아서 “빠르게 테스트”하는 방법을 고민하였는데, 주어진 숫자 범위에서는 당연히 TLE가 뜰 수밖에 없다. 이를 빨리 깨닫고 넘어갔으면 더 빠르게 풀었을 것이라고 생각한다. 심지어 변수 선언을 마지막에 실수로 long long으로 해주지 않아 한 번의 try를 날렸다. 교훈 어려워 보이는 (앞 번호) 문제라면 규칙 찾기를 시도해 볼 것. 변수형 선언 꼼꼼히 하기 (애매하면 그냥 long long으로 두기) 'Round #703 - B.cpp : AC'123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;using namespace std;#ifdef __APPLE__#include &quot;dbg.h&quot;#else#define dbg(...)#endif#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() { int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { int n; scanf(&quot;%d&quot;, &amp;n); vector&lt;long long&gt; x; vector&lt;long long&gt; y; for(int i = 0; i &lt; n; i++) { long long a, b; scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b); x.push_back(a); y.push_back(b); } if(n%2 == 1) { printf(&quot;1\\n&quot;); continue; } dbg(x); dbg(y); sort(x.begin(), x.end()); sort(y.begin(), y.end()); long long a = x[n/2] - x[n/2 - 1] + 1; long long b = y[n/2] - y[n/2 - 1] + 1; printf(&quot;%lld\\n&quot;, a*b); }} C2 (Guessing the Greatest - hard version)문제 보기 C번 문제 풀이 + 본인의 코드 흔하지는 않은 interactive 문제를 인생 첫 코드포스 대회에서 만나 놀랐다. 나중에 확인해 보니 대회 전에 공개된 round 소개에 나와 있었다. 본인은 하나도 준비를 안한 채 만나서 당황도 했고, 무엇보다도 문제 이해 + 구현에 꽤 많은 시간이 들었다. 사실 문제를 보자마자 아이디어는 굉장히 빠르게 떠올랐다 - 이진탐색!어떤 배열에서 두 번째로 큰 수의 위치를 얻는다. 이후, 가장 큰 수가 그 수 기준으로 왼쪽에 있는지 오른쪽에 있는지 판별할 수 있다 (왼쪽 혹은 오른쪽 구간에서 query 한 번을 사용) 이런 이진탐색 스러운 느낌을 살려서 가장 큰 수를 찾으면 되는데… 위 아이디어를 살려 코드를 제출하였지만, 3번 pretest에서 발생하는 TLE를 해결하지 못한 채 대회가 종료되었다. 끝나고 곰곰히 생각해 본 결과, 이진탐색의 느낌을 살리는 것이 아니라 “정말 이진탐색과 똑같이” 해도 상관 없음을 확인하였다. 기존까지는 두 번째로 큰 수를 포함하는 범위로 나누었는데, 사실 이렇게 하면 worst case에서는 최악으로 시간복잡도가 $O(n)$이 되므로, TLE가 뜰 확률이 높다. 그냥 이진탐색을 돌리면 되었다. (조금 더 자세히 말하자면, 맨 처음에만 두 번째로 큰 수를 포함하는 범위로 나눠주면 된다) 왜 이걸 찾지 못했을까 이 아이디어로는 C2(hard version)이 통과되며, C2보다 시간 제약이 더 널럴한 C1은 당연히 통과된다. 교훈 TLE가 발생하면 알고리즘 자체를 다시 생각해보자 'Round #703 Upsolving - C.cpp : AC'12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;using namespace std;#ifdef __APPLE__#include &quot;dbg.h&quot;#else#define dbg(...)#endif#include &lt;iostream&gt;int ask(int start, int end) { if(start &gt;= end) return -1; printf(&quot;? %d %d\\n&quot;, start, end); fflush(stdout); int response; cin &gt;&gt; response; return response;}int main() { int n; scanf(&quot;%d&quot;, &amp;n); int secondMax = ask(1, n); if(secondMax == 1 || ask(1, secondMax) != secondMax) { int left = secondMax, right = n; while(right - left &gt; 1) { int middle = (left + right) / 2; if (ask(secondMax, middle) == secondMax) { right = middle; } else { left = middle; } } printf(&quot;! %d\\n&quot;, right); } else { int left = 1, right = secondMax; while(right - left &gt; 1) { int middle = (left + right) / 2; if (ask(middle, secondMax) == secondMax) { left = middle; } else { right = middle; } } printf(&quot;! %d\\n&quot;, left); }} D (Max Median)문제 보기 D번 문제 풀이 + 본인의 코드 업솔빙 할 당시에도 문제 감을 전혀 잡지를 못해서 Tutorial을 참고하여 힌트를 얻었다.전반적인 아이디어 틀은 Binary Search, 좀 더 상세히 말하자면 Parametric Search 였다. 어떠한 x에 대하여 이 값이 median으로 가능한지 확인해 보는 방향이다. 이는 첫 번째 힌트인 “모든 값이 -1 또는 1일 때를 생각해 보라” 에서 추리할 수 있다. 이 특수한 경우에서는,’부분 수열의 합이 0 이상이다 = -1의 개수보다 1의 개수가 많다’를 의미한다.이 힌트는 왜 갑자기 등장했을까. 어떠한 x에 대하여, x보다 작거나 같은 값들을 -1로, x보다 큰 값들을 1로 변경한다. 그러면, 부분 수열의 합이 0 이상이 된다는 것은 “x 이상인 값이 median이 될 수 있음”을 보장해 준다! 여기까지가 문제풀이의 가장 큰 핵심이 된다. 부분 수열의 합은 Prefix Sum으로 구한다.허나, 한 가지 아이디어가 더 필요하다. 아직 변수 k를 고려하지 않았다! 그러나 각 탐색 작업에 $O(k)$의 시간복잡도를 투자하여 부분 배열을 검사하는 것은 TLE로 이끈다. 필자는 Gravekper 로부터 아이디어를 받았는데, prefix sum들의 최솟값을 저장하는 배열을 하나 더 선언하는 것이다. 이렇게 하면 $O(k)$를 들여 검사를 하지 않고 preSum[i]와 minSum[i-k] 의 대소 비교 한 번을 통해 가능성 여부를 파악할 수 있다. Upsolving 하고 나니 꽤나 많은 힌트들을 필요로 했고, 아이디어도 굉장히 많이 요구되었던 것 같다. 대충 아직 나의 실력보단 높은 난이도 란 뜻이다. D번의 Upsolving은 실전의 도움보다는 지적 호기심이 더 맞겠다 ㅎㅎ 'Round #703 Upsolving - D.cpp : AC'1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;using namespace std;#ifdef __APPLE__#include &quot;dbg.h&quot;#else#define dbg(...)#endif #include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAX_N 200000 int n, k;int arr[MAX_N+5]; bool check_X(int x) { // check if x is possible for answer int brr[MAX_N+5], preSum[MAX_N+5], minSum[MAX_N+5]; memset(brr, 0, sizeof(brr)); memset(preSum, 0, sizeof(preSum)); memset(minSum, 0, sizeof(minSum)); if(arr[1] &lt; x) brr[1] = -1; else brr[1] = 1; preSum[1] = brr[1]; minSum[1] = min(preSum[1], minSum[0]); for(int i = 2; i &lt;= n; i++) { // set values of preSum and minSum if(arr[i] &lt; x) brr[i] = -1; else brr[i] = 1; preSum[i] = preSum[i-1] + brr[i]; minSum[i] = min(minSum[i-1], preSum[i]); if(i &gt;= k &amp;&amp; preSum[i] &gt; minSum[i-k]) return true; } return false;} int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;arr[i]); } // binary search int l = 1; int r = n; int m, ans = arr[1]; while(l &lt;= r) { m = (l+r)/2; if(check_X(m)) { ans = m; l = m + 1; } else { r = m - 1; } } printf(&quot;%d\\n&quot;, ans);} E번, F번 문제는 그래프 관련된 문제들이라 당분간 풀이하지 않겠다. C번/D번까지 대회 내에서 도달하는 날이 온다면, 그래프 이론을 완벽하게 머리에 넣고 도전해 보겠다.","link":"/2021/02/18/2021-02-18-CodeForces-703/"},{"title":"Desilo 인턴 돌아보기 - 01","text":"01. About My First Internship얻은 것도 많고, 느낀 점도 많았던 나의 첫 번째 인턴 생활에 대해 정리해보려고 오랜만에 블로그에 글을 올린다. 첫 번째 글에서는 인턴 생활에 대한 정보들과 느낀 점들을 정리하고, 이후 글들에서는 회사에서 진행한 개인 프로젝트들에 대하여 남겨 놓으려고 한다. 인턴 생활의 시작윤성로 지도교수님의 추천으로 Desilo(디사일로) 라는 스타트업에서 인턴을 하게 되었다. 13학점만을 남겨 놓은 채로, 학기와 인턴을 병행하였다. 종강 때 까지는 점심 시간 이후에 참여하였고, 종강 이후에는 오전부터 오후까지 쭉 회사에 있었다. 계약은 월~금, 하루 5시간씩이었다. 회사는 네이버의 D2SF Startup Factory에 입주해 있었는데, 강남역 바로 앞 건물에 위치해 있어서(9월에 이사를 간다고 한다) 집에서 매우 가까워 좋았다. 인턴 생활현업에서 내가 잘 아는 개발 분야가 백엔드여서, 백엔드 개발자로 인턴에 들어가 처음에는 API 및 테스트 코드 작성을 도왔다. 허나 대표님과 리드 개발자님 모두 나의 최종 목표가 백엔드 개발자가 아니라는 것을 알고 있었기에, 나의 Task 선정에 굉장히 많은 고민을 해주셨다. 그 덕분에 이번 인턴을 통해 생각보다 다양한 방면에서 성장하고 배울 수 있었다. 어떻게 하면 내가 인턴 기간에서 더 많은 것을 얻어갈 수 있을지 항상 고민해 주신 너무 고마운 분들이다. 회사 생활적인 측면에서는 정말 놀란 점이 많다. 굉장히 자유로운 분위기였으며, 리드 개발자님을 포함하여 모두가 서로를 존중한다는 느낌을 처음부터 끝까지 강하게 받았다. 개발자 분들이 내가 질문을 들고 갈 때도 너무 친절하고 자세하게 알려주셨고, 내 코드에 대해서 부담 없이 물어보시는 것도 첫 인턴인 나의 입장에서 꽤나 놀라웠다. 리드 개발자님께서 인턴인 나에게도 별 거 아닌 일로 하루에 몇 번씩 “죄송합니다”라고 하시는 것도 굉장히 놀라웠고, 멋있어 보였다. 회식 술자리에서 “코딩 잘하면 형님”이라는 말도 하셨듯이, 다른 거 필요 없이 오로지 ‘실력’만을 생각하고 인정해 주는 모습과 함께 말이다. 회사에는 굉장히 독특한 문화들도 많았다. 우선은 점심 때 샐러드를 주문하는 사람과, 그렇지 않은 사람(샐파/비샐파)으로 나뉘었다. 두 그룹을 왔다갔다하는 사람들도 있어서 메뉴 선정과 그루핑(grouping)은 하루의 재미 요소 중 하나였다. 또한 회사가 16층에 위치해 있었는데, 근무 시간 중에 한 번정도씩 1층에서 계단으로 올라오는 문화가 있었다(물론 본인이 선택할 수 있었다). 회사 분들이 모두 건강을 매우 중요시 생각하고 잘 챙긴다는 것을 알 수 있다.. 또한 정말 생각치 못하게 인턴 중에 친구를, 그것도 외국인 친구를 만나게 되었다. 키르기스스탄에서 온 Daniiar 라는 친구였는데, 나와 같이 인턴으로 6월 말 즈음에 입사하였다. 다니아르도 나와 같이 비교적 소수였던 비샐러드 파여서 종종 둘이서 점심을 먹었는데, 그럴 때마다 재밌는 대화들을 많이 할 수 있었다. 이 때 외국인과 대화하는 것이 영어 실력이 급상승하는 지름길임을 스스로 깨닫게 되었다. 복학하면 스누버디에 지원해보는 것도 나쁘지 않을지도.. 가장 좋아하고 잘하는 운동이 탁구라는 점에서도 나와 똑같았어서, 회사에서 탁구도 몇 번 쳤다. (근데 1:1 두 번 졌다 ㅠㅠ 잘하더라..) 다니아르와는 나중에 미국에서 꼭 만나자는 약속을 하고 헤어졌다. D2SF에서 새로 입주한 회사에서 과 선배도 만날 수 있었다. 17학번 김지수 선배였는데, 처음 입학했을 때 새내기 단톡방을 관리하셨어서 이름이 낯에 익었고, 연락을 드려서 인사하고 밥도 한 번 사주셧다. 개인적으로 내가 전기과 중에서 외부적으로 활발하게 관심을 가지고 움직인 편이라고 생각했는데, 선배님이 나보다 몇 배는 열심히 활동하신 것 같아서 놀라웠고 자극이 되었다. 4달 동안 편안하고 재밌는 곳에서 일했던 것 같다. 무엇보다 하루하루 회사를 가는 ‘재미’가 있었다는 것이 스스로도 놀라웠다. 역시 “좋은 사람들과 함께하는 것”이 무엇보다 중요한 것 같다. 결론주변 사람들에게 스타트업 인턴의 단점을 정말 많이 들었던지라, 비교하였을 때 너무나 만족스럽고, 행복했었던 것 같다. 이보다 더 좋은 회사 인턴 생활을 할 수 있을까? 싶었다. 그래서 다른 회사 인턴을 더 할 것 같지는 않다ㅎㅎ 글의 처음부터 끝까지 좋은 말밖에 하지 않았는데, 이미지 관리나 다른 이유 전혀 없이 정말 불편한 점이 단 하나도 없었다. 굳이 꼽자면 MVP 작업을 막 시작하려는 단계에 내가 입사하여, 모두가 정신이 좀 없었던 점? 근데 소규모 스타트업에게 이 ‘정신 없음’은 너무나 당연한 특성이며, 충분히 예상하고 있었다. 인턴 프로그램이 체계적으로 갖추어진 대기업 인턴과 비교하였을 때 가장 큰 차이인데, 이것이 나에게는 오히려 큰 장점으로 다가왔다. 더욱 흥미로운 Task들을 맡을 수 있었으며 나의 코드와 연구들이 직접적으로 회사에 사용되고, 도움이 되는 것을 보니 너무나 뿌듯했기 때문이다. 물론 호불호가 갈리는 사항이긴 하다: 나처럼 Task가 모호하여 직접 Task을 정의하고 알아가는 과정을 즐기는 사람들도 있는 반면, 친구들 중에서도 명확한 Task들을 선호하는 친구들이 있기 때문이다. 결국 대표님께서 퇴사 전 날에 회사에서 고치면 좋을 점을 꼭 하나 찝어달라고 하셨을 때, 끝까지 대답하지 못했다. 개인적으로 스타트업에 처음 들어왔을 때 배워갈/얻어갈 수 있을 거라 기대한 점은 인맥, 조금의 실력 상승, 스타트업의 분위기 정도였다. 이 세 개는 당연히 챙겨갈 수 있었고, 이외에도 생각보다 많은 실력 상승, 사회 생활, 영어 실력(아마?), 그리고 자신감과 뿌듯함을 얻어갈 수 있었다. 예상한 것보다 나의 코드들과 연구들이 회사에 직접적으로 도움이 되었고, 많은 영향을 미쳤다는 느낌이 들었기 때문이다. 리드 개발자님께서 어딜 가서 무얼 하든 잘 할 것이라고 말씀해 주셨는데, 앞으로 목표를 향해 나아갈 때 큰 힘이 될 것 같다. 퇴사 전날 대표님과 함께 티타임을 가졌었는데, 평소에 궁금했던 질문을 대표님께 드렸다: “회사에 계신 훌륭한 사람들을 어떻게 본인의 편으로 만들었나요?” 대표님께서는 ‘따로 계획하거나 작정하고 사람들을 모은 것은 아니지만, 매 순간 최선을 다하고 진정성 있는 관계를 유지했더니 주변에 좋은 사람들이 남았다’고 말씀해 주셨다. 대표님께서 예상하시지 못한 질문이었던 것 같았지만, 대표님의 답변이 생각보다 너무 중요하고 와닿는 말이라고 느꼈다. 이렇게 ‘스타트업’과 ‘인턴’의 좋은 면들만 잘 누린 너무 좋은 경험이었다고 생각한다. 좋은 스타트업 인턴을 추천을 해 주신 윤성로 교수님, 인턴의 기회를 주신 이승명 대표님, 항상 신경 써주신 정승우 리드개발자님, 그리고 나머지 모든 회사 사람들에게 너무 감사드린다.","link":"/2021/08/03/2021-08-03-Desilo-Intern-01/"},{"title":"Desilo 인턴 돌아보기 - 02","text":"02. 초기 Task들첫 번째로 받은 초기 Task들을 간단하게 정리하고자 한다. 동형암호를 전문적으로 다루는 스타트업인 만큼 초반에는 동형암호와 그 라이브러리들에 대한 전반적인 지식이 요구되었다. 이후 회사의 HE (Homomorphic Encryption, 동형암호) Library 를 직접 만들어 배포하는 것에 기여하게 되었다. 대표님, 리드개발자님과 인턴을 위한 인터뷰를 진행하였을 때, 직전에 한 프로젝트이자 자신있는 파트 중 가장 현업과 직접적인 관련이 높았던 파트가 서버 파트였기 때문에, 자연스럽게 서버 관련 Task도 받게 되었다. 동형암호란Homomorphic Encryption (동형암호) 란, 암호화된 암호문들을 연산해도 그 성질을 잃지 않는 암호를 의미한다. f(x) + f(y) = f(x + y) 인 함수를 homomorphism 이라고 부르는 것을 떠올리면 이해하기 쉽다. a1, a2를 암호화했을 때 각각 c1, c2가 되었다면, c1 + c2를 복호화하면 a1 + a2 가 된다. (곱셈도 된다) 동형암호의 강력한 장점 중 하나는 데이터 연산 시 복호화 과정이 필요 없다는 점이다. 데이터셋을 머신러닝에 이용한다고 하자. 동형암호를 사용하지 않는다면, 데이터셋 복호화 → 머신러닝 (데이터 조작) 하여 의미있는 결론 도출 → 데이터셋 암호화 의 과정을 거쳐야 한다. 복호화 과정이 불가피하게 최소 한 번은 필요한 것이다. 따라서 데이터를 조작하거나 의미 있는 결론을 얻어내기 위해서는 어쩔 수 없이 데이터 원문이 드러나게 된다. 이는 ‘해킹에 취약함’을 의미하기도 한다. 하지만 동형암호를 사용한다면, 복호화 하지 않고도 데이터셋에서 유의미한 결론을 얻어낼 수 있다! 이는 우리 회사 Desilo에게 반드시 필요한 기술이다. 정말 간단하게 설명하자면 Desilo는 회사들이 각자의 Dataset들을 업로드하거나, 다른 회사의 Dataset을 사고 팔 수 있는 플랫폼(B2B 서비스)을 만드는 것이 목표였다. (적어도 내 인턴 기간 동안에는) 사이트에 Dataset을 업로드 하면 동형암호로 자동 암호화 되며, 타 회사의 Dataset을 구매하면 사이트 내에서 데이터 조작을 할 권한을 얻게 된다. 동형암호의 특징을 이용하면 거래 및 데이터 조작 시에도 Dataset을 복호화할 필요가 없으며, 심지어 서버를 운영하는 Desilo 회사도 복호화할 수 없게 할 수 있다. (개인 암호 키를 본인 컴퓨터 하드웨어에만 저장해 두면, 서버 운영자를 포함한 그 누구도 복호화할 수 없다.) 이런 면에서 Dataset을 업로드하는 회사는 자회사 고객의 privacy 문제나, 회사 이익 측면 등에서 전혀 타격을 받지 않을 수 있다! Task 1-1 : Desilo HE Library다양한 라이브러리들이 현재 동형암호를 지원해 주고 있는데, 가장 유명한 C++ 동형암호 라이브러리에는 Microsoft 사의 SEAL 과 Duality Technologies의 PALISADE가 있다. (결국 본인은 인턴 기간 동안 이 두 라이브러리를 모두 잘 다루게 되었다) 첫 번째 Task에서는 추후 회사에서 개발에 직접 사용할 Desilo HE Library를 만드는 것이었다. 동형암호의 연산은 SEAL 라이브러리를 이용하였는데, MVP 개발 시 SEAL을 매번 직접 이용하기 위해서는 개발자 모두가 SEAL과 동형암호에 대한 이해가 필요하기 때문에, 그리고 코드가 길어지고 더러워질 것이기 때문에 이를 방지하기 위해 API 형식으로 회사 자체 라이브러리를 만들고자 하였다. Input과 Output들이 회사의 MVP에 맞게 정해졌다. 본인은 Rotation Sum, Count, Filter 함수를 맡게 되었다. Task 자체는 크게 어렵지 않았는데, 입사하고 첫 번째 Task인 만큼 처음에 정말 감을 많이 못 잡았던 것 같다. 회사의 환경(협업 툴 Gitlab를 비롯한 Notion 등등)에 적응하는 것을 떠나, 무엇보다 Task 해결의 시작이 막막하게 느껴졌다. 리드개발자님께 “어디서부터 어떻게 시작해야 할 지 정말 모르겠다”고 털어놓았을 정도였다. Turning Point가 되었던 부분은 이론 공부의 부족함을 느끼고 처음으로 돌아가 더 꼼꼼히 공부한 것이었다. 초반에는 어서 Task를 해결하고 싶은 급한 마음에 동형암호와 라이브러리에 대한 심도 깊은 이해를 하지 않고 넘어갔다. 사실 어려운 정수론을 비롯한 수학이 배경에 있는 학문인지라 개인적으로 어느정도까지 깊게 공부해야 하는가?가 어려운 포인트였다. 동형암호의 간단한 응용만 하면 되는 Task에서 근본적인 원리까지 파헤치는 것은 불가능해 보이기도 했고, 비효율적일 것이기 때문이다. 처음 내린 결론은 ‘이정도만 이해해도 되겠지’ 였지만 결국 이것이 발목을 잡고 괴롭혔다. 또 한 번 기본기의 중요함을 깨닫는 기회였다. 앞으로 내 인생에서도 이 질문은 자주 등장하여 나를 괴롭힐 것 같은데, 많은 경험을 통해 이를 익히는 것도 중요한 능력 중 하나가 될 것 같다. 어쨌든 감이 잡히지 않으면 처음으로 돌아가 다시 공부해라는 교훈을 얻었다. 또한, 질문을 자주 한 것도 많은 도움이 되었다. 사실 입사 전까지 본인은 개인 프로젝트의 비중이 월등히 높았고, 도전적이고 어려웠던 경우는 대부분 스스로 하였다. 그래서 막혔을 때 누구에게 물어보기 보다는 스스로 구글을 뒤지거나, 직접 부딪혀가며 해결하였다. 그러나 집단 단위의 프로젝트, 특히 회사의 경우 이것이 정답이 아니라는 것을 깨달았다. 스스로 해결하는 문제해결 방법은 개인의 역량 키우기에는 도움이 될 수 있겠지만, 회사의 입장에서 이는 시간 낭비일 확률이 높다. 옆 사람이 똑같은 문제로 시간을 투자하여 해결했다면, 나는 답을 듣고 바로 다음 단계로 넘어가는 것이 회사에게는 이상적이고 효율적인 것이다. 인턴 첫 달 동안 나의 ‘질문’에 대한 인식이 많이 바뀌었던 것 같다. 인턴인 나에게도 정말 친절히, 기초부터 알려주었던 회사의 개발자 분들이 많은 긍정적인 영향을 준 것 같다 : ) 결과론적으로 SEAL 과 SEAL-Python 을 성공적으로 마스터하고, Library 함수도 성공적으로 완성하였다. Pytest을 이용하여 검증하라는 subtask도 함께 해결하였는데, 저번 서버 프로젝트 때 한 API test와 유사한 형식을 지녀 비교적 빠르게 이해하고 완성할 수 있었다. (임의의 case들을 input으로 넣고 output을 확인한다는 원리는 같으므로) 추가적으로 Monkeypatch를 이용하는 방법도 공부하여 익힐 수 있었다. Task 1-2: User Scenario TestTask 1-1에서 작성한 Library들을, 있을법한 Scenario에 적용하여 올바르게 동작함을 보여주는 Subtask 였다. Library와 마찬가지로 python(jupyter notebook)을 이용하였는데, python 환경에서 Data 처리를 쉽게 해주기 위해 pandas 라이브러리도 공부하여 익혔다! Task 1-3: WebAPI개인 프로젝트였던 다음 Palisade-Python (Pypalisade) 프로젝트 이전에 잠시 받았던 간단한 Task였다. MVP 웹사이트에 사용될 Register Local Dataset WebAPI를 작성하게 되었다. 웹 서버도 Python 기반의 FastAPI를 이용하고 있었는데, 동형암호로 암호화된 Dataset들이 굉장히 용량이 크기 때문에 비동기 처리를 위해 FastAPI를 채택한 것으로 기억한다. API 개발과 더불어 MySQL도 리눅스 환경에서 잘 다룰 수 있게 되었다. 마무리하며초반에는 비교적 다양한 Task들을 하면서 다양한 skill들을 익힐 수 있었던 것 같다. 동형암호와 SEAL 라이브러리 공부가 꽤나 어려웠던 기억이 있다 - 동형암호의 이론 자체는 생각보다 쉬웠지만 직접 라이브러리를 사용하기 위해서는 생각해야 할 인자와 key가 꽤 많았고, 이 설정을 제대로 해주지 않으면 연산이 수행되지 않기 때문이었다. 애초에 Git은 굉장히 자유자재로 다룰 수 있었고, 이전의 협업 프로젝트들을 통해 협업 툴 사용법과 팁들은 알았기에 ‘회사에서의 협업’ 부분에서는 큰 어려움 없이 적응할 수 있었다. 위의 Task들은 입사한 2021.04.01 일자부터 05.31 까지 약 두 달에 걸쳐 수행하였다. 아예 새로 알게 된 동형암호의 개념부터, 기존에 다루었었던 백엔드 개발과 Python, C++ 문법 등등 전반적으로 기본기를 다지며 회사에 적응하고 스며든 시기였다.","link":"/2022/01/15/2022-01-15-Desilo-Intern-02/"},{"title":"02. CodeForces Round #704 (Div.2) 풀이 &amp; 후기","text":"대회 소감두 번째 CodeForces 대회였다. 뒤에서도 언급하겠지만, 여러모로 너무나도 허무했던 시험이었다. 다음 Contest를 빨리 봐서 극복하고 싶다는 의지를 강력하게 점화해준, 어찌보면 고마운..? 시험이라고 생각하자 ^____^ 풀이A (Three Swimmers)문제 보기 A번 문제 풀이 + 본인의 코드 굉장히 쉽게 풀었는데, C언어의 나눗셈을 실수하여 삽질한 문제. 정수 형태의 나눗셈을 해주려면 (long double) a/b 이런 식으로 앞에 형 변환을 해주어야 하는데, 이걸 새까맣게 잊고 있었다.본인이 발견하고도 굉장히 어이가 없었다…오히려 ‘A번이 늦어지고 있다’는 것에 너무 신경이 쓰여서 집중해서 발견하지 못한 것 같다. 디버깅을 통해 충분히 찾아낼 수 있었는데,, 초반인 만큼 더더욱 중요하지 않은 곳에서 삽질할 확률이 높으니, 침착함을 유지하는 것이 중요하다고 느꼈다. 특히나 A, B번에서는 말이다. 교훈 WA가 떠도 침착하게 디버깅하자. 문제 다시 읽어보기 ➡ 올바르게 풀었는지 확인 ➡ 디버깅 (실수 잡기) 'Round #704 - A.cpp : AC'123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#ifdef __APPLE__#include &quot;dbg.h&quot;#else#define dbg(...)#endif long long int p, a, b, c; long long int func(long long int x) { auto temp = (long long int)(ceil((long double)p/x)); dbg(temp); return (temp*x - p);} int main(){ int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%lld %lld %lld %lld&quot;, &amp;p, &amp;a, &amp;b, &amp;c); printf(&quot;%lld\\n&quot;, min({func(a), func(b), func(c)})); }} B (Card Deck)문제 보기 B번 문제 풀이 + 본인의 코드 A번에서 삽질을 하여 급하게 넘어와서인지, B번에서 더 많은 삽질을 해버렸다. 우선 맞았다고 생각한 알고리즘에서 TLE가 떠서, 멘탈이 나갔다. 이후 ‘틀렸을 리가 없어..’ 하면서 부분적 수정으로 시간 복잡도를 감소하려 했는데 여기서 정말 많은 try와 시간을 소모했다. (덕분에 C번 문제는 읽지도 못했다) 대회 시간이 끝나갈 때, 반 쯤 포기한 상태의 편한 마음가짐에서 생각하니 바로 아이디어가 떠올랐고, 3분만에 구현하여 AC를 받았다. A번도 그렇고, B번도 그렇고 여러모로 너무나도 허무한 contest였다 ㅜㅜ 교훈 TLE가 떴으면 알고리즘 생각 자체를 다시 해야 할 확률이 높다. 시간복잡도를 정확히 계산해 보고, 정말 간당간당하게 못 넘겼다면 부분적 수정을 하되 그럴 일은 거의 없다. 부분적인 시간 복잡도 감소를 try하여 점수를 잃지 말자. 애초에 구현하기 전에, 시간복잡도를 계산하자. 특히 Worst Case의 시간복잡도. 스스로 시간을 정해 놓고, 그 안에 못 풀면 차라리 다음 문제로 넘어가자. 개인적으로 이번 상황에서는, TLE가 떴는데 즉석으로 아이디어가 떠오르지 않았을 때 바로 넘어가는 것이 맞지 않았나 싶다. 'Round #704 - B.cpp : AC'1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#ifdef __APPLE__#include &quot;dbg.h&quot;#else#define dbg(...)#endif stack&lt;int&gt; a;stack&lt;int&gt; temp;vector&lt;int&gt; b;bool check[100002];int n; void func() { dbg(b); while(true) { int top = a.top(); a.pop(); temp.push(top); if(check[top]) { while(!temp.empty()) { int xx = temp.top(); temp.pop(); b.push_back(xx); } if(a.empty()) { return; } else { return func(); } } else { continue; } }} int main(){ int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { scanf(&quot;%d&quot;, &amp;n); b.clear(); int max = 0; memset(check, false, sizeof(check)); for(int i = 0; i &lt; n; i++) { int input; scanf(&quot;%d&quot;, &amp;input); a.push(input); if(input &gt; max) { max = input; check[input] = true; } } func(); for(int i = 0; i &lt; n; i++) { printf(&quot;%d&quot;, b[i]); if(i != n-1) { printf(&quot; &quot;); } else { printf(&quot;\\n&quot;); } } }} C (Maximum Width)문제 보기 C번 문제 풀이 + 본인의 코드 아직 Upsolving 하지 않았습니다. D (Genius’s Gambit)문제 보기 D번 문제 풀이 + 본인의 코드 아직 Upsolving 하지 않았습니다.","link":"/2021/02/23/2021-02-23-CodeForces-704/"},{"title":"Desilo 인턴 돌아보기 - 03","text":"03. 첫 프로젝트: Create PALISADE-Python처음으로 받은 ‘프로젝트’ 급의 과제였다. 첫 글에서 언급했듯 대표님과 리드 개발자님 모두 나의 최종 목표가 백엔드 개발자가 아니라는 것을 알고 계셨기에, 어떤 Task를 나에게 부여해야 회사와 나 모두에게 도움이 되는 방향인지에 대한 고민을 (정말 감사하게도) 많이 하셨다. 결론적으로 나에게 “개인 프로젝트”를 Task로 부여해 주었다. 처음 Task를 받았을 때에는, 설렘에 심장이 쿵쿵 뛰었던 것 같다. 여태 개인 프로젝트는 학교에서 수업을 위한, 즉 나의 학점을 위한 용도였거나 개인 만족/실력 향상의 용도로밖에 쓰이지 않았는데, 내 개인 프로젝트가 회사(남)를 위해 쓰인다고? 내 실력을 제대로 발휘할 수 있는 절호의 기회라고 생각하였다. 최선을 다해 열심해 해보아야 겠다는 의지가 불타올랐다. 다가올 커다란 산은 생각하지 못한 채.. Pypalisade Task 원문Create Palisade-PythonDuality Technologies have library called Palisade, released regularly here: link We can utilize the PALISADE when we can make a Python wrapper around the C++ library, as done here: link This involves: understanding CPython C APIs and how objects are transferred from C++ to Python environment understanding how we can do that using pybind11 - link understanding the Python packaging process involving distutils - link Objective is to make relatively bug-free Python package that wraps PALISADE that we will publish on Github as desilo/Pypalisade. Task 보충설명 (21.07 기준)Task에 대한 간단한 포인트들만 Q&amp;A 형식으로 남겨두겠다. Q1. SEAL과 같은 동형암호 라이브러리들을 잘 사용하고 있는데, 왜 PALISADE에 관심을 가지는가?A1. PALISADE 라이브러리에서는 SEAL이 지원하지 않는 BinFHE(TFHE)나 Multiparty(Threshold HE) 등의 기능들을 지원한다. 실제로, PALISADE가 가장 실험적인 동형암호 라이브러리라는 평이 많았다. Q2. Duality Tehcnologies에서 PALISADE의 Python wrapper를 지원하는 것 같던데?A2. 실제로 Demo 버전이 올라와 있긴 했으나, 몇 가지 문제점들이 있었다. 우선 소수의 기능들만 제공하는, 아이디어 제공용 라이브러리였다. (repo 설명 원문: This repository contains an example python 3 wrapper for PALISADE. It does not expose all functionality of PALISADE, rather it is an example of how to build a specific python application program using a python wrapper, Boost/python bindings and an installed PALISADE library. Check out the README in the repository for more details.)또한 정식 배포 버전이 아니므로 PALISADE의 업데이트에 맞추어 최신화가 될지도 미지수이다. 이는 회사에서 사용하는 목적에서 꽤나 치명적이다. 회사에서 직접 라이브러리를 만들게 되면 에러가 발생하더라도 직접 코드 수정을 하여 고칠 수 있지만, 가져다 쓰는 라이브러리가 에러를 뱉는다면 Duality 측에서 라이브러리를 건드려 직접 에러를 수정해 줄 때까지 우리는 할 수 있는게 없다. Task 수행 과정첫 번째 과정으로는, 기본 지식 학습의 선행이 필수적이었다. 우선 다루어야 하는 PALISADE 라이브러리와 친해져야 했다. Duality Technologies에서 50페이지 가량의, 논문 형식의 Manual을 제공해 주어 많이 참고(10회독 가량..?)하였다. 그런데 오류 및 오타가 정말, 정말 많았다. 거의 두 페이지에 하나씩 있는 꼴이었다. 기존의 SEAL과 같은 라이브러리에서 보지 못했던 Multiparty Homomorphic Encryption과 같은 개념들이 등장하여, 이해를 위해 PALISADE Webinar 까지 들어 가면서 공부했던 기억이 난다. 이후로는 wrapping 작업에 이용할 pybind11 툴을 익혔다. 공식 문서를 꼼꼼히 읽었고, 예제를 직접 실행 시켜 보며 알아갔던 것 같다. 가장 널리 보급된 Python인 CPython의 경우 C로 작성되어 있으므로 연관이 있다는 것은 사전에 인지하고 있었는데, C로 작성된 코드를 wrapping 작업을 통해 Python에서 구동시킬 수 있다는 점은 굉장히 신기했다. 주요한 두 툴을 익힌 이후로는 이제 직접 PALISADE에 pybind11을 접목하여야 했다. PALISADE의 source code를 찬찬히 뜯어보았고 (생각보다 파일이 정말 정말 많았고 코드들도 기본 몇 백줄이었으며 구조 자체도 굉장히 복잡하게 되어 있어서 꽤나 오랜 시간이 걸렸다) 이미 pybinding된 선례인 SEAL과 Huelse/SEAL-Python을 적극 참고하였다. (이 과정에서 사실상 SEAL과 SEAL-Python의 source code도 모두 익히게 되었다). PALISADE의 구조도 어느 정도 파악하였고, pybind11도 완벽하게 다룰 줄 알게 되어 자신 있게 pybinding을 시작하였다. 그러나, 시간이 지남에 따라 자연스럽게 정석적인 pybinding이 불가능함을 깨닫게 되었다. 거대한 산위에서도 언급했듯 PALISADE는 구조가 기본적으로 복잡했다. 또한 C++의 최신 문법을 포함한 다양한 문법이 이용되었는데, 이 중 깔끔하게 pybinding 되지 않는 문법들이 꽤나 많았다. 대표적으로는 smart pointers, templates, virtual functions, abstract classes 가 있었다. 이론상 pybinding이 불가능한 것은 아니었다. Custom smart pointer 들은 macro invocation을 이용한 transparent conversion을 이용하여 해결할 수 있다. Template의 경우는 입력 가능한 모든 타입을 하나씩 분해하여 직접 function이던, class이던 하나씩 수동으로 만들어 주면 된다. Virtual function을 포함한 abstract class들은 추가적인 “trampoline class”를 만들고 pybinding 하여 이 abstract class의 역할을 수행할 수 있었다. 이론상 불가능한 건 없었다. 다만 수동적인 작업들이 많아 시간이 많이 요구되고 귀찮다는 점인데, 그게 한 두개도 아니고 수백개가 넘는다는 사실이다. 게다가 대부분의 class가 template 변수를 달고 다닌다는 것을 고려하면? 천 개가 넘을 것이다. 간단한 코드 작성 실험을 통해 한 class의 function을 사용하려면 그 class가 상속하는 모든 subclass들을 모두 pybinding하여 구현해야 한다는 것도 연이어 깨달았다. (어찌보면 당연하다) 옆 동네의 pybinding에 성공한 사례인 SEAL의 경우에는, PALISADE에는 떡칠이 되어 있는 template과 abstract class들이 전혀 없이 작성되어 있었으며 구조도 훨씬 간편했고, 코드들도 짧고 간결했다. 절망적이었다. 불가능하진 않지만 사실상 불가능하다. 이 말이 나를 괴롭히기 시작했다. 설득력이 굉장히 부족했기 때문이다. 다른 사람에게는 ‘귀찮고 머리 아픈 작업이라 하기 싫어하는 건가?’ 하는 냄새를 풍길 수도 있다. 어쩌면 무식하게 하나라도 먼저 시작했으면 인턴 기간 내에 어찌저찌 끝냈을 지도 모른다. (물론 그랬을 거 같진 않다. 최소 1년 반은 필요해 보였다.) 솔직하게는, 내가 성장하려고 하는 인턴인데 이 작업은 나의 성장과는 거리가 너무나 멀어 보이는 단순 노가다여서 꼭 이걸 해야되나.. 하는 심정이었다. 새로운 IDEA리드 개발자님께 어떻게 이 Task가 현실적으로 불가능함을 설명할지 고민을 거듭하던 찰나에, 새로운 IDEA를 떠올렸다. 꼭 직접 pybinding을 해야 할까? 하는 의문에서 출발하였다. 내 Task는 PALISADE를 pybinding을 하는 것이지만, 결국 궁극적인 목표는 PALISADE을 python 환경에서도 사용할 수 있도록 해주는 것이 아닌가. 아래 사진과 같이 새로운 라이브러리를 하나 만들어, 직접 PALISADE를 pybinding하는 것이 아닌 내가 만든 라이브러리를 pybinding하면 어떨까 하는 아이디어를 떠올렸다. 나는 어떠한 C++의 구조와 문법들이 pybinding이 어려운지 알고 있으니, 새 라이브러리를 만들 때 이들이 포함되지 않도록 하면 된다. 라이브러리 자체에서 PALISADE를 import하여 사용하므로, 내 라이브러리에는 PALISADE의 말단 클래스 (직접 호출하여 사용하는 클래스) 들만 포함해도 되며 따라서 pybinding 해야 하는 코드 자체가 기하급수적으로 감소한다. 해결!생각해낸 아이디어로 몇 개만 구현하여 실행하였더니, 잘 동작하였다. 흐름을 타 쭈욱 코딩하였다. 추정되는 모든 결과들을 오류 없이 잘 뱉어내는 모습을 확인하였을 때, 그 순간과 그 뿌듯함은 1년 가까이 지난 지금도 잊을 수 없다. Manual부터 Example Codes까지, 하나의 프로젝트를 처음부터 끝까지 꼼꼼하게 완성한 경험이었다. (원본은 Desilo Git에 있으며, 본인의 Hidden repository에도 올려둔 상태이다) 돌아보기해냈다! 처음으로 어떠한 프로그램의 Source code를 찬찬히 뜯어봤다. 사실 github에 올라와있는 대부분의 프로그램들은 쓰고 사용법을 익히기에 바쁘지 source code를 뜯어볼 일이 없었는데, 이 과정 자체가 생각보다 많은 도움과 경험을 준 거 같다. 학교에서 배우지 못했던 최신 C++ 문법들이 생각보다 많았으며, 이 과정 자체만으로도 C++에 대한 개념이 많이 정리되었던 것 같다. (다른 사람의 코드를 많이 읽어보는 것의 중요성은 굳이 말하지 않아도 다들 알 것이다.) 결국 나는 하나의 라이브러리이자 프로그램을 만든 것이다! 이를 배포하여 다른 개발자들에게 사용법을 설명해주고, 직접 설치 및 실행했을 때 전혀 오류 없이 구동되는 것이 떨리면서도 너무나 뿌듯했다. 이런 맛에 프로그램을 만들어 배포하는 것인가? 설명서를 항상 읽어보는 나에게, 친절한 설명과 예시가 중요했다. 근데 사람들은 내 고민의 중간과정을 전혀 접하지 못하고 바로 결과물만 본다. 이를 의식하면서 설명서를 만들도록 했는데 역시나 쉽진 않았다. 의외로 Weathy 에서 Server API를 만든 경험이 굉장히 많은 도움이 됐으며, 실제로 형식을 많이 참고하기도 하였다. 정석 방법(PALISADE를 직접 통째로 pybinding 하는 것)은 아니라 찜찜하긴 했지만, 그리고 회사에 실제로 이 코드가 쓰여 도움이 될진 모르겠지만 어쨌든 그 가능성을 봤다는 사실 자체가 중요하다고 생각한다. 나 한 명이 대표로 삽질을 하여, 아무도 가보지 않은 길을 내가 팠다. 내가 겪은 문제점들과 삽질한 포인트를 회사에서 인지하고 있는 것 자체만으로도 이득이 아닐까? 라고 스스로 믿고 있다 (아, 여기서 덧붙이자면 혼자 팠기 때문에 질문이 생겨도 물어볼 사람이 없었고, 이 부분이 어려움으로 다가오기도 했다.) 자존감과 자신감이 올라간 것은 당연한 사실이다! 완벽히 완성하였을 때에는 잊을 수 없는 뿌듯함을 느꼈다. 이것이 나의 길임을 또 한 번 깨달은 순간이자, 너무나도 행복했던 순간이었다. 리드개발자님께서 ‘어딜 가더라도 뭐든지 잘할 거 같다’고 말해주신 건 덤이었다. 아직까지 내 마음을 울리는 최고의 칭찬이었다.","link":"/2022/04/11/2022-04-11-Desilo-Intern-03/"},{"title":"Desilo 인턴 돌아보기 - 04","text":"04. 두 번째 프로젝트: Google FHE Transpiler Research첫 번째 프로젝트 (PALISADE-Python) 를 수행한 후, 일주일 안에 다음 프로젝트를 받게 되었다. 이후 2~3주동안 이 프로젝트를 수행하다가 인턴을 마치게 되었다. Task 설명본 프로젝트는 Google의 논문 A General Purpose Transpiler for Fully Homomorphic Encryption에 대한 연구 및 더 나아가 회사에 적용할 방안이 있는지 확인하는 프로젝트였다. Google FHE Transpiler 논문본 논문은 Google에서 진행한 흥미로운 연구인데, 요약하자면 C++로 작성된 프로그램 자체를 동형암호화 할 수 있는 방안에 대한 연구이다. 지금까지는 Data만을 암호화하였고, 한 번도 이를 벗어나는 생각을 해본 적이 당연히 없었던지라 처음 리드 개발자님께 논문을 소개받았을 때에는 아주 놀랐다. 프로그램 자체를 암호화하는게 된다고요? 딱 이 반응이었다. 논문에서는 동형암호화에 관한 전문성이 부족한 개발자들이 동형암호를 활용한 개발을 하는 것이 가능케 하는 것이 목표라고 밝혔다. 실제로 필자도 동형암호 관련 개발을 위해 기본적인 수학적 개념을 이해하여야 했으며, 효율적인 parameter 설정에는 더 깊은 수준의 전문성을 요구하였다. 동형암호를 전혀 모르는 개발자도, C++로 작성된 코드에 이 (실험적인) FHE Transpiler를 적용하면 동형암호 field에서 작동하는 코드를 만들 수 있는 것이다! 프로젝트를 받은 시점이 21년 7월 중순이었고, 논문이 6월 중순에 나왔으니 나온 지 한 달이 지나지 않은 꽤나 따끈따끈한 논문이었다. 첫 번째 Task는 이 논문 자체를 이해하고 (Google 놈들이 무슨 짓을 해놓은건지 파악하라고 하셨다 ㅋㅋㅋ), 두 번째 Task는 회사에서 이 논문을 적용할 방안이 있는지 확인하는 것이었다. 아래에 본 논문의 초록을 참고한다. Fully homomorphic encryption (FHE) is an encryption scheme which enables computation on encrypted data without revealing the underlying data. While there have been many advances in the field of FHE, developing programs using FHE still requires expertise in cryptography. In this white paper, we present a fully homomorphic encryption transpiler that allows developers to convert high-level code (e.g., C++) that works on unencrypted data into high-level code that operates on encrypted data. Thus, our transpiler makes transformations possible on encrypted data.Our transpiler builds on Google’s open-source XLS SDK (https://github.com/google/xls) and uses an off-the-shelf FHE library, TFHE (https://tfhe.github.io/tfhe/), to perform low-level FHE operations. The transpiler design is modular, which means the underlying FHE library as well as the high-level input and output languages can vary. This modularity will help accelerate FHE research by providing an easy way to compare arbitrary programs in different FHE schemes side-by-side. We hope this lays the groundwork for eventual easy adoption of FHE by software developers. As a proof-of-concept, we are releasing an experimental transpiler (https://github.com/google/fully-homomorphic-encryption/tree/main/transpiler) as open-source software. 과정논문을 읽으며 이해하는 것으로 시작하였다. 논문에서 사용된 Google XLS, Bazel 같은 tool들의 개념과 자주 사용해보지 않았던 TFHE (Torus FHE; AND, OR, NOT과 같은 Gate Operation들만을 사용하며 noise management 없이도 무한한 computation을 할 수 있다) 의 개념 등을 공부하며 이해하였으며, 앞선 프로젝트에서 ‘완벽히 새로운 분야에 머리 박으며 배우는 것’에 익숙해진 덕에 크게 어렵지 않았던 것 같다. 본 Transpiler의 아이디어를 이해한 이후에는, Google 측에서 올려둔 experimental transpiler를 직접 돌려보며 여러 가지를 분석하였다. Transpiler를 C++ 코드에 직접 적용하고 Bazel을 이용하여 build하는 방법과 적용 가능한 C++ 코드들의 조건을 확인하였다. (실제로 Data-Independent한 코드들에게만 transpiler가 적용 가능하다. 예를 들자면, loop이나 array의 길이가 변수면 안 되며, recursion과 pointer가 포함된 코드도 적용 불가능하다.) 마지막으로는 제공된 Example codes들을 직접 돌려보며 걸리는 시간을 측정하였다. num_opt_passes, Array size의 두 변수를 직접 바꾸어가며 측정하였으며, 시간은 abseil::Now()을 이용한 Total Time과 clock()을 이용한 CPU Time을 모두 측정하였다. 그 결과, 아직 이 실험적인 transpiler는 현업에 직접 사용되기 어렵다고 판단하였다. 기본적인 a + b의 덧셈이 30초~1분 가량 걸렸으며, input string을 뒤집어 출력하는 예시 코드는 무려 28분이나 걸렸다. 두 변인에 대한 유의미한 결론도 내릴 수 있었다. 인턴 끝!인턴 기간의 대부분을 독자적인 프로젝트 형태로 진행하였기에, 인턴 마지막 날에 수행한 두 프로젝트(PALISADE-Python, Google FHE Transpiler)를 모든 회사 사람들 앞에서 발표하게 되었다. 많은 분들께서 궁금증을 가지고 들어주시고, 질문해주셔서 감사하고 뿌듯한 경험이었다. 프로젝트에 대해 더 자세히 알고 싶다면 아래 발표 파일을 참고할 것!참고: 발표 파일","link":"/2022/05/02/2022-05-02-Desilo-Intern-04/"},{"title":"군대 싸지방에서 블로그 관리하기 (Hexo)","text":"싸지방 컴퓨터는 예전 중고등학교 시절 컴퓨터실의 컴퓨터들과 같이 껐다 키면 모든 파일이 삭제되고 초기화된다. 따라서 Github을 이용한 Hexo 블로그를 이용하는 본인과 같은 경우에는 매번 필요한 프로그램들을 설치하고 설정들을 관리하여야 했다. 이 일련의 과정을 정리해두었다. 블로그 관리 세팅 Download and install Node.js (from here) Download and install GIT (from here) Download and install Visual Studio Code if you need a markdown editor (from here) Git Clone your blog repo (from here)1git clone https://github.com/yxxshin/MyBlog Run npm install at the blog repo1npm install Install Hexo1npm install -g hexo-cli Set your GIT default account12git config --global user.email &quot;samshin3910@snu.ac.kr&quot;git config --global user.name &quot;yxxshin&quot; 끝났다! Hexo 사용법은 기존의 블로그 게시물을 참고하면 된다.","link":"/2022/06/26/2022-06-26-Army-Blog-Manual/"},{"title":"CS231n Lecture2 정리","text":"Lecture2 : Image Classification pipelineImage Classifier의 기본적인 구조, 그리고 가장 간단한 kNN (K-Nearest Neighbors) 에 대하여 설명한다. Image ClassifierInput: 이미지, Output: 그 이미지의 label (분류)123def classify_image(image): # codes return class_labelTrain, Predict의 큰 틀을 가짐 Nearest NeighborTrain: 저장만 함Predict: 가장 유사한(거리가 가까운) 이미지의 label을 출력 K-Nearest Neighbors가장 가까운 근처 K개의 점 중 다수의 label을 선정outlier들을 배제할 수 있다. Distance Metric L1(Manhattan) distance $d_1(I_1, I_2) = \\sum_{p} |I_1^p-I_2^p|$ 같은 거리의 점들이 마름모 형태 L2(Euclidean) distance $d_2(I_1, I_2) = \\sqrt{\\sum_{p}(I_1^p-I_2^p)^2}$ 같은 거리의 점들이 원 형태 Hyperparameters 정의: Train 되지 않고 내가 직접 정하는 parameters (set rather than learn) 대부분 problem-dependent 하여, 직접 다 돌려보고 선택하는 경우가 많음. Setting Hyperparameters IDEA: Data를 train, val, test로 랜덤하게 나누어, train에서 모델 학습, val에서 hyperparameter 설정, test에서 최종 검정을 한다. Cross-Validation: data를 여러 fold 들로 나누어, 각 fold를 validation으로 사용해 보고 결과를 평균낸다. Small Dataset들에선 유리하지만, 딥러닝은 보통 그렇지 않으므로 자주 쓰이지는 않음.","link":"/2022/07/10/2022-07-10-CS231n-Lecture2/"},{"title":"CS231n Lecture3 정리","text":"Lecture3 : Loss Functions and OptimizationLinear classification의 기본 (Loss function, Optimization)을 다루고, Loss function의 예시로 Multiclass SVM과 Softmax, Optimization의 예시로 Stochastic Gradient Descent(SGD) 에 대하여 설명한다. Linear Classifier의 개요다음과 같은 Parametric Approach를 생각해보자. $f(x, W) = Wx + b$의 형태로, $W$와 $b$를 정해주면 image $x$를 input으로 하였을 때 $f(x, W)$가 추측된 label을 알려준다. 다음의 두 가지를 염두해야 한다. Loss function을 정의하여 모델의 “어긋난 정도”를 파악할 방법을 마련해야 한다. optimization: 정의한 loss function을 최소화할 수 있는 parameter를 효율적으로 찾는 방법을 마련해야 한다. Loss function : 모델의 분류 성능을 대변한다$x_i$가 image, $y_i$가 label(integer) 라고 할 때 ${\\{(x_i, y_i)}\\}_{i=1}^{N}$ 의 example dataset이 주어진다. Total Loss $L$은 각 이미지의 loss를 모두 더한 것과 같다. L = {1 \\over N} \\sum_{i}L_i(f(x_i, W), y_i)Multiclass SVM lossscore vector $s = f(x_i, W)$ 와 같이 정의할 때, SVM loss는 다음과 같이 정의한다. L_i = \\sum_{j \\neq y_i} \\begin{cases} 0 & \\text{if} \\enspace s_{y_i} \\geq s_j + 1 \\\\ s_j - s_{y_i} + 1 & \\text{otherwise} \\end{cases} \\\\[2em] = \\sum_{j \\neq y_i} \\text{max}(0, s_j - s_{y_i}+1) Possible min/max loss : 0, $ \\infty $ Debugging strategy: 초기에 $W$가 매우 작아 모든 $s \\approx 0 $ 일 때, $\\text{loss} = \\text{num of classes} - 1 $ Regularization Training Data에 overfit되는 것을 방지하기 위하여, 다음과 같이 Regularization term을 추가해 준다: (SVM의 예시)L = {1 \\over N} \\sum_{i}L_i(f(x_i, W), y_i) + \\lambda R(W) Train data에서는 오차가 조금 더 생기겠지만, 모든 data(Test data)에 대해서는 더 좋은 model이 되기 위한 penalty라고 생각할 수 있다. 여기서 $\\lambda$는 hyperparameter 이다. 가장 흔한 방법은 L2 regularization이다. R(W) = \\sum_k \\sum_l W_{k,l}^2 Softmax LossSoftmax loss는 다음과 같이 정의한다. L_i = -\\log {e^{s_k} \\over \\sum_j e^{s_j}} Possible min/max loss : 0, $ \\infty $ (둘 다 이상적인 경우임) Debugging strategy: 초기에 $W$가 매우 작아 모든 $s \\approx 0 $ 일 때, $ \\text{loss} = \\log(\\text{number of classes}) $ SVM과 Softmax의 비교 SVM: 판별 자체에 중점을 두고, 그 이후는 관여하지 않음 Softmax: 더 정확하게 (독보적인 선택으로; 깔끔하게) 판별하는 것을 신경씀 따라서 한 Datapoint를 아주 조금 바꾸었을 때, SVM은 loss 값이 바뀌지 않을 수 있지만 Softmax는 반드시 바뀜 Optimization: 최고의 $W$ 찾기Loss값을 가장 빠르게 최소화하는 방향(direction of steepest descent) 이 negative gradient 임을 이용한다! Numerical Gradient미분의 정의를 이용하여 수학적으로 직접 계산한다. {df(x) \\over dx} = \\lim_{h \\to 0} {f(x+h) - f(x) \\over h}$h$를 아주 작은 0.0001 정도로 두고 각 항을 직접 loop을 돌며 계산할 수 있지만, 너무 느리다 Analytic GradientCalculus를 이용하여, 직접 $ \\nabla_WL $ 을 수학적으로 계산한다! Gradient 구하기 결론항상 Analytic Gradient를 이용하지만, Numerical Gradient를 이용하여 확인해볼 수 있다. ( gradient check ) Gradient Descentnegative gradient가 가장 급격하게 감소하는 방향임을 이용하여, 조금씩 움직이면서 반복한다. 123while True: weights_grad = evaluate_gradient(loss_func, data, weights) weights += - step_size * weights_grad 여기서 step_size는 hyperparameter인데, 생각보다 꽤 중요하다고 한다. Stochastic Gradient Descent (SGD)전체 Sum을 계산하는 것은 굉장히 expensive 하므로, minibatch 를 이용하여 작은 data만 이용하여 Gradient Descent를 적용한다., 1234while True: data_batch = sample_training_data(data, 256) # 256개의 data만 사용 weights_grad = evaluate_gradient(loss_func, data_batch, weights) weights += - step_size * weights_grad","link":"/2022/07/18/2022-07-18-CS231n-Lecture3/"},{"title":"SVM, Softmax No loop 코드 아이디어","text":"Assignment1 : svm.ipynb &amp; softmax.ipynb본 게시물에서는 CS231n의 assignment1 (Spring 2020) 중, svm.ipynb 과제와 softmax.ipynb 과제의 주요 아이디어에 대하여 설명한다. 하이퍼링크를 통해 필자가 작성한 전체 assignment solution을 확인할 수 있으며, loss function과 gradient를 구하는 코드는 linear_svm.py 와 softmax.py 에서 확인 가능하다. 목표svm.ipynb, softmax.ipynb 의 과제에서는 최종적으로 각각 SVM, Softmax classifier에 대한 fully-vectorized loss function을 구현하고, 이 loss function의 fully-vectorized analytic gradient를 구현하여 SGD를 이용하여 optimization을 진행하는 것이다. 본 게시물에서는 위의 ‘fully-vectorized’ 한 부분들의 아이디어를 설명하고자 한다. fully-vectorized는 결국 loop이 없다는 것을 의미하는데, 이에는 python skill들과 아이디어가 필요하기 때문이다. svm.ipynb시작하기에 앞서, Multiclass SVM 에서의 loss function은 다음과 같다. L_i = \\sum_{j \\neq y_i} \\begin{cases} 0 & \\text{if} \\enspace s_{y_i} \\geq s_j + 1 \\\\ s_j - s_{y_i} + 1 & \\text{otherwise} \\end{cases} \\\\[2em] = \\sum_{j \\neq y_i} \\text{max}(0, s_j - s_{y_i}+1)편의를 위해 regularization term은 생략하도록 하자. (계산 마지막에 더해주기만 하면 된다) $X$ 의 크기가 $\\text{N} \\times \\text{D}$, $W$ 의 크기가 $\\text{D} \\times \\text{C}$ 일 때 필자가 작성한 loss function의 코드는 다음과 같다. 'SVM Loss with no loops'123456S = X.dot(W)ans_S = S[np.arrange(N), y]margin = S - ans_S[:, None] + 1loss = np.sum(np.maximum(0, margin))loss /= Nloss += reg * np.sum(W*W) - 1 $X \\cdot W$ 를 통해 $S$ 를 구하였으며, $S[i][j]$ 는 $x_i \\cdot w_j$ 를 의미한다. S[np.arrange(N), y]를 해주면 $i$ 번째 칸이 $y_i$ 인 1-D vector를 얻을 수 있으며, 따라서 margin 값 ( $s_j - s_{y_i} + 1$ )을 계산할 때 Python Broadcasting을 통해 이용할 수 있다. 위 코드에서는 우선 $ j = y_i $ 인 경우까지 모두 고려하여 합쳤으며, $ j = y_i $ 인 경우는 항상 $\\text{loss} = 1$ 이 추가되므로 마지막에 1을 빼 주었다. np.maximum()은 요소 하나하나 비교한다는 면에서, np.max()과 다르다는 것을 짚고 넘어가자! gradient를 구하기 위해서는, 다음과 같은 Indicator function을 생각한다. I(x) = \\begin{cases} 1 & \\text{if} \\enspace x > 0 \\\\ 0 & \\text{else} \\end{cases}위의 loss function을 직접 미분해보면, 다음과 같은 편미분 값을 얻는다. j \\neq y_i : \\qquad {\\partial L_i \\over \\partial w_j} = I(x_i \\cdot w_j - x_i \\cdot w_{y_i} + 1) \\cdot x_i^Tj = y_i : \\qquad {\\partial L_i \\over \\partial w_{y_i}} = (\\enspace \\sum_{j \\neq y_i} I(x_i \\cdot w_j - x_i \\cdot w_{y_i} + 1) \\enspace ) \\cdot (-x_i^T)여기서 $x_i$는 $X$의 $i$번째 row vector, $w_j$는 $W$의 $j$번째 column vector 이다. (notation 주의!) 이 식들을 이용하여 $ L = {1 \\over N} \\sum_{i = 1}^{N} L_i $ 를 통해 total loss $L$ 을 구한다. 아래는 필자가 작성한 python no-loop 코드이다. (위의 코드를 이용한다) 'SVM Gradient with no loops'123456binary = np.maximum(0, margin)binary[binary&gt;0] = 1binary[np.arange(N), y] -= binary.sum(axis = 1)dW = np.dot(X.T, binary)dW /= NdW += 2 * reg * W Matrix의 shape을 통해 $X^T$와 binary를 곱하는 아이디어를 얻는다. 실제로 Matrix의 shape을 통해 유추하는 방식이 굉장히 자주 등장한다!! Gradient의 크기는 $W$와 같아야 하며, 주어진 matrix들의 곱 만을 이용한다면 $X^T$와 $\\text{N} \\times \\text{C}$의 크기를 가진 matrix을 곱해야 한다. binary[i][j]은 “$x_i^T$가 이 $j$에 대하여 몇 번 계산되는가?”를 의미한다. 위에 유도한 식에서 0보다 큰 margin 값들만 유지되었고, $j = y_i$인 경우에는 그 행에서 margin 값이 0보다 큰 애들의 개수만큼 빼 주었기 때문이다. 이를 바탕으로, $X^T$ 를 곱하는 정당성은 다음과 같이 생각해 볼 수 있다. \\left[ \\begin{matrix} \\vec{a} & \\vec{b} \\end{matrix} \\right] \\left[ \\begin{matrix} x & l \\\\ y & m \\\\ \\end{matrix} \\right] = \\left[ \\begin{matrix} \\vec{a}x + \\vec{b}y & \\vec{a}l +\\vec{b}m \\end{matrix} \\right]$X^T$ 를 $ \\left[ \\begin{matrix} \\vec{x_1^T} &amp; \\vec{x_2^T} &amp; … &amp; \\vec{x_N^T} \\end{matrix} \\right] $ 와 같이 보고 위와 비교해보면, 이해가 될 것이다! softmax.ipynbSoftmax에서의 loss function은 다음과 같다. L_i = -\\log {e^{s_k} \\over \\sum_j e^{s_j}}필자가 작성한 코드는 아래와 같다. 'Softmax Loss with no loops'123456exp_scores = np.exp(np.dot(X, W))scores_row_sum = np.sum(exp_scores, axis = 1)normalized_scores = exp_scores / scores_row_sum[:, None]loss = np.sum(-np.log(normalized_scores[np.arange(N), y]))loss /= Nloss += reg * np.sum(W*W) 각 행의 log 안쪽 분모 값을 scores_row_sum에 담았고, 전체 exp_scores 행렬의 각 행을 이 scores_row_sum으로 나누어 normalized_scores를 만들었다. (Python Broadcasting이 사용된다) 이후에는 -log을 씌우고 더해주면 된다. Gradient를 구하기 위해서는 마찬가지로 $L_i$를 편미분해야 한다. j \\neq y_i : \\qquad {\\partial L_i \\over \\partial w_j} = {e^{s_j} \\over \\sum_k e^{s_k}} \\cdot x_ij = y_i : \\qquad {\\partial L_i \\over \\partial w_{y_i}} = ( {e^{s_j} \\over \\sum_k e^{s_k}} - 1) \\cdot x_i$ j = y_i $ 인 경우만 $x_i$를 한 번씩 더 빼주면 된다! 위 SVM의 경우와 마찬가지로 $X^T$와 곱하는 아이디어를 사용하여, 아래와 같이 해결할 수 있다. 1234normalized_scores[np.arange(N), y] -= 1dW = np.dot(X.T, normalized_scores)dW /= NdW += 2 * reg * W","link":"/2022/07/19/2022-07-19-SVM-Softmax-IDEA/"},{"title":"CS231n Lecture4 정리","text":"Lecture 4 : Backpropagation and Neural NetworksBackpropagation이 무엇인지, 그리고 Gate를 어떻게 modularization하는지를 다루며, Neural Network에 대하여 간단하게 설명한다. Backpropagation각 변수의 편미분을 구하기 위하여, 알고 있는 “뒤쪽” 에서부터 거슬러 올라간다. 기본적인 원리는 Chain Rule 이다. 쉽게 해석하면, 뒤에서 들어온 편미분 값 $\\times$ local 편미분 값 을 해주면 된다! Backpropagtion을 적용할 때 첫 단계는 아래와 같은 computational graph을 그리는 것이다. 이후 차근차근 거슬러 올라가면서 계산해주면 된다! (backward flow) 특수한 케이스 몇 개는 다음과 같다: add gate: gradient distributor (같은 값이 뒤로 전달됨) max gate: gradient router (max 값만이 앞쪽으로 전달됨) mul gate: gradient switcher (앞에서 넘어온 값과 상대 노드 입력값이 뒤쪽으로 전달됨) 뒤로 전달되는 과정 중, 다음과 같이 모아진다면 (branch) gradient들은 더해진다! {\\partial f \\over \\partial X} = \\sum_i {\\partial f \\over \\partial q_i} \\cdot {\\partial q_i \\over \\partial X} Modularized Implementation한 종류의 Gate는 Forward / Backward API를 가진 하나의 모듈로 modularization 할 수 있다. 12345678class MyGate(): # x, y --&gt; z def forward(x,y): # calculate z from x, y return z def backward(dz): # calculate dx, dy from dz return [dx, dy] Neural Networks기본적인 Neural Network에 대하여 소개하였다. 아래와 같은 $ f = W_2 \\max (0, W_1 x) $ 형태의 2-layer Neural Network을 살펴보자. 이 경우에서는 max 함수가 non-linearity를 보장해준다. (linear classification의 단점 보완!)자동차를 분류하는 모델을 가정해보자. Train data에 빨간색 차가 많았다면, $W_1$ 에서 빨간 차들이 high score를 가지고 있을 것이다. 이대로 모델 학습을 끝낸다면 (linear classifier), 이 모델은 빨간 차는 잘 식별하겠지만 다른 색깔의 차는 식별에 어려움을 겪는다. $W_2$ 에서 다양한 template에 대하여 combine하고 모델의 score 함수 값들을 조정해주면, 최종적으로 다른 색의 차도 식별에 유리해진다!","link":"/2022/07/25/2022-07-25-CS231n-Lecture4/"},{"title":"ReLU, Affine 계층에서의 Backpropagation","text":"CS231n assignment1 two_layer_net.ipynb 의 구조는 input - fully connected layer - ReLU - fully connected layer - softmax 로 이루어진다. (neural_net.py 참고) 등장하는 ReLU 계층, Affine 계층을 Lecture 4에 소개했듯 modularization 하여 정리해 보려고 한다. ReLU 계층ReLU function의 형태는 다음과 같다. y = \\begin{cases} x & \\enspace (x \\geq 0) \\\\ 0 & \\enspace (x < 0) \\end{cases}따라서 $x$로 편미분 하면 다음과 같다. {\\partial y \\over \\partial x} = \\begin{cases} 1 & \\enspace (x \\geq 0) \\\\ 0 & \\enspace (x < 0) \\end{cases}즉, Backpropagation 결과는 다음과 같다. {\\partial L \\over \\partial x} = \\begin{cases} {\\partial L \\over \\partial y} & \\enspace (x \\geq 0) \\\\ 0 & \\enspace (x < 0) \\end{cases} Affine 계층 Affine 계층이란 Neural Network에서의 fully-connected layer를 의미한다. 본 과제에서는 $X$가 $(N, D)$ 의 행렬의 형태로써 다음과 같이 vectorized된 형태를 제시한다. Y = X \\cdot W + b 이를 computational graph로 표현하면 다음과 같다. Lecture 4 에서 add gate 가 gradient distributor의 역할을 한다 하였고, Backpropagation for a Linear Layer 를 이용하면 ${\\partial L \\over \\partial X}$ 와 ${\\partial L \\over \\partial W}$ 는 쉽게 구할 수 있다. 문제는 ${\\partial L \\over \\partial b}$ 인데, 결과론적으론 다음을 얻는다. {\\partial L \\over \\partial X} = {\\partial L \\over \\partial Y} \\cdot W^T{\\partial L \\over \\partial W} = X^T \\cdot {\\partial L \\over \\partial Y}{\\partial L \\over \\partial b} = {\\partial L \\over \\partial Y}.\\text{sum(axis = 0)} 즉, ${\\partial L \\over \\partial b}$ 는 ${\\partial L \\over \\partial Y}$ 의 row 방향 합(axis = 0)이다. 일단 shape의 측면에선 맞아 떨어지는데, 어떻게 이를 해석할 수 있는지 생각해보자. Affine 계층에서 $Y = X \\cdot W + b$ 가 되면 $b$ 가 broadcasting 되어 모든 row에 더해진다. 쉽게 생각하였을 때 ${\\partial L \\over \\partial b}$ 는 $b$ 가 $L$ 에 미치는 영향을 의미한다. $b$ 가 모든 row에 더해졌으므로 $b$ 가 $L$ 에 미치는 전체 영향을 구하려면 편미분 값을 row 방향으로 합쳐서 모두 더해주어야 하지 않겠는가? 최종적으로 gradient를 표시한 computational graph는 다음과 같다. 위의 수학적 계산 결과를 알고 있다면, CS231n assignment1의 two_layer_net.ipynb 는 매우 쉽게 해결할 수 있다.","link":"/2022/08/07/2022-08-07-Affine-Layer-Backprop/"},{"title":"Batch Normalization에서의 Backpropagation","text":"CS231n assignment2의 BatchNormalization.ipynb 의 풀이 과정에서 Batch Normalization Backward flow 가 요구되는데, 이를 해결한 두 가지 방법을 간단히 소개하고자 한다. 각각의 아이디어가 batchnorm_backward 와 batchnorm_backward_alt 에 사용되었다. 풀이 1) computational graph을 직접 그려 한 단계씩 계산 풀이 2) 편미분과 연쇄법칙을 직접 활용한 수학적 계산","link":"/2022/09/13/2022-09-13-Batch-Normalization-Backprop/"},{"title":"Backpropagation for a Linear Layer","text":"CS231n assignment1 의 two_layer_net.ipynb 해결에 필수적이었던, Matrix들에서의 Backpropagation (Chain Rule) 에 대하여 설명한다. 원문 파일은 아래와 같다.Backpropagation for a Linear Layer 목표$Y$, $X$, $W$ 가 모두 행렬이고 $L$ 이 스칼라량이라 하자.${\\partial L \\over \\partial Y }$ 를 알고 있을 때, ${\\partial L \\over \\partial X}$ 와 ${\\partial L \\over \\partial W}$ 를 계산하는 것이 목표이다. 이것이 기본적인 Chain Rule을 이용한 Backpropagation이다. 조건직접 Chain Rule을 이용하면, ${\\partial Y \\over \\partial X}$ 나 ${\\partial Y \\over \\partial W}$ 와 같은 항들이 등장한다. 이 항들은 Jacobian Matrix 인데, 너무나 크기 때문에 이 Jacobian 항들을 쓰고 싶지 않다. 방법위의 원문 파일에서는 one element at a time 방식을 이용한다. 행렬을 원소 단위로 나누어 생각하고 계산해 본다는 것인데, 작은 사이즈의 경우를 예시로 직접 계산한 뒤 이를 일반화하였다. 결론{\\partial L \\over \\partial X} = {\\partial L \\over \\partial Y} \\cdot W^T{\\partial L \\over \\partial W} = X^T \\cdot {\\partial L \\over \\partial Y}참고 ${\\partial (\\text{scalar}) \\over \\partial(\\text{matrix})} $ 와 ${\\partial (\\text{matrix}) \\over \\partial(\\text{scalar})} $ 모두 결과값의 shape는 matrix의 shape와 같다! 원문에서 두 matrix의 dot product와 곱셈(multiplication)을 구분하는 듯 하였는데, 개인적으로 이 용법은 잘못되었다고 생각한다. Dot product는 두 matrix 사이에서 정의되지 않으며 조금 더 포괄적으로 생각하더라도 행렬들에 해당되는 dot product는 행렬의 곱셈이다. (그래서 필자와 같이 헷갈리는 사람을 만들어낸다 ㅜㅜ) 의미상 행렬의 dot product를 스칼라량이 output으로 나오는 inner product로 생각하면 깔끔하게 맞아 떨어진다. ($ &lt; A,B &gt; = \\sum_{1 \\leq i, j \\leq n} a_{ij}b_{ij}$)","link":"/2022/08/05/2022-08-05-Backprop-for-a-Linear-Layer/"},{"title":"CS231n Lecture5 정리","text":"Lecture 5 : Convolutional Neural NetworksCNN의 기본 원리와 용어 설명에 대하여 설명한다. Channel(Depth), Filter, Stride, Padding, Pooling Layer 를 다룬다. CNN 기본 원리Channel (Depth)CNN의 특징은 이미지의 spatial structure를 유지한다는 것이다. (기존의 Fully Connected Network에서는 한 이미지당 한 개의 긴 row vector로 늘렸었다.) 이미지의 크기가 $ H \\times W \\times C $ 라고 하자. 여기서 $C$ 는 channel 을 의미하며, 사용된 색의 개수로 쉽게 이해할 수 있다. 컬러 이미지는 RGB의 세 가지 색을 이용하므로 channel = 3 이며, 흑백 이미지는 channel = 1 이다. Depth로 불리기도 한다. Filter이제, 이 이미지가 $ HH \\times WW \\times C $ 의 크기인 filter로 연산 된다. 실제 convolution 연산과 유사하게 (단, filter 반전은 없다) 이미지에서 filter의 크기와 같은 영역이 filter와 모두 곱해져 하나의 scalar로 계산된다. 이러기 위해서는 이미지의 depth와 filter의 depth가 같아야 한다. 필터가 $F \\times F$의 size라면, 필터의 크기를 $F$ 라고 한다. 한 개의 filter는 한 개의 2D output을 만든다. $K$개의 filter가 있으면, depth가 $K$인 3D array가 output이 된다. 주로 $K$는 2의 거듭제곱 꼴로 둔다. Stridestride란, filter와 이미지가 합성곱 될 때 filter가 한 번에 이동할 칸 수이다. 합성곱 연산을 진행하게 되면 이미지의 크기가 계속 감소하는데, 이는 어찌보면 정보를 잃는 과정이므로 이를 보완하기 위해 padding 작업을 해준다. Paddingpadding 이란 이미지의 주변에 새로 data를 붙여주는 것을 의미한다. 가장 대중적인 방법은 zero padding 인데, P개의 줄만큼 이미지의 주변에 0을 추가로 붙여준다. filter의 크기가 $ F \\times F $ 일 때, $ P = {F-1 \\over 2} $ 로 padding을 두면 연산을 해도 이미지의 크기가 보존된다. 최종적인 연산 결과 이미지의 크기: $ H \\times W \\times D $ 필터 개수: $K$ 필터의 크기: $F$ Stride: $S$ Zero padding: $P$ 의 값들로 연산된 output은 다음과 같은 $ H_2 \\times W_2 \\times D_2 $ 의 크기를 가진다: $ H_2 = {H - F + 2P \\over S} + 1 $ $ W_2 = {W - F + 2P \\over S} + 1 $ $ D_2 = K $ Pooling LayerPooling Layer는 depth의 변화 없이 output의 사이즈를 줄이기 위해 사용한다. 일종의 downsampling이라 생각하면 된다. 가장 유명한 Max Pooling은 Filter의 크기 안에서 가장 큰 값만 선택하여 남긴다. Activate하는 놈을 강조(특징 살리기)한다는 입장에서 보면,이 과정이 정당하다고 받아들일 수 있다. Pooling Layer에서는 보통 zero-padding을 사용하지 않는다. 따라서 $ H \\times W \\times D $ 의 이미지를 크기 $F$, stride $S$의 pooling filter로 max pooling 하면 $ ({H - F \\over S} + 1 )\\times ({W - F \\over S} + 1 )\\times D$ 의 output이 나온다. Typical Architectures전형적인 구조는 아래와 같다. [ (CONV - RELU)\\times N - POOL]\\times M - (FC - RELU) \\times K - SOFTMAX","link":"/2022/09/22/2022-09-22-CS231n-Lecture5/"},{"title":"CS231n Lecture6 정리","text":"Lecture 6 : Training Neural Networks, Part INeural Network를 Train 할 수 있는 다양한 방법들에 대하여 설명한다. Activation Functions, Weight Initialization, Batch Normalization, Babysitting the Learning Process, Hyperparameter Optimization 를 다룬다. Activation Functions다음과 같은 Activation Function에 대하여 논해보자. Sigmoid Function Sigmoid Function은 뉴런의 ‘활성화’를 가장 직관적으로 잘 나타내어 예전부터 사용되었는데, 다음의 문제점들을 가진다. 1) Saturated Neurons “kill” the gradients input이 가령 조금 크거나 (10 이상) 조금 작다면 (-10 이하), 기울기 값이 0이 된다 (saturated). 때문에 Chain Rule을 생각하면 이후에 등장하는 ‘모든’ gradient 값이 0이 되며, 이를 ‘killing the gradient’라고 표현한다. 2) Not zero-centered Zero-Centered는 activation function이 가져야 하는 중요한 조건 중 하나이다. Sigmoid Function의 경우에는 output이 항상 양수(positive)이다. 따라서 Backpropagation 단계 (Backward Flow)를 생각하면 들어오는 gradient 값과 나가는 gradient 값의 부호가 항상 동일하다. 즉, gradient 값들이 all positive 하거나 all negative 하다. 이 경우에는 다음과 같이 zig zag path로 최적화가 진행되므로, 굉장히 비효율적일 확률이 높다. 3) exp() is computationally expensive 위의 $tanh(x)$ function은 zero centered 라는 점에서 sigmoid function 보다 좋지만, saturated 되었을 때 발생하는 gradient killing 문제는 해결되지 않았다. ReLU Function (Rectified Linear Unit) ReLU function은 + region 에서 saturate 되지 않고, very computationally efficient 하며, sigmoid와 tanh에 비해 빨리 수렴한다(약 6배)는 장점이 있지만, zero-centered 하지 않다. 절반의 영역(- region)에서 saturate 되므로, 아주 작은 양의 bias를 통해 ReLU neuron을 initialize 하는 것이 좋다. ReLU function의 문제들을 극복하기 위하여 Leaky ReLU(saturate 하지 않으며, 따라서 뉴런이 “죽지” 않는다), ELU(Leaky ReLU에 비해 노이즈에 강하지만 computationally expensive한 exp 연산이 필요함) 등을 이용한다. 요약 ReLU 를 이용하라. (learning rate의 선정에 유의한다) Leaky ReLU, Maxout, ELU를 시도해봐라. tanh 를 시도해 보되, 큰 기대는 하지 마라. Sigmoid는 사용하지 마라 Weight InitializationFully Connected Net 에서 등장하는 weight $W$ 는 모델이 학습을 통하여 최적의 값을 정해 나간다(backprop). 그렇다면, 처음에는 어떤 값들로 초기화를 해 주어야 하는가? Idea 1 ) W = 0 init모든 값들을 0으로 초기화하는 방법은 어떨까. 결론적으로, 이는 절대 하지 말아야 하는 방법이다. 이 경우에는 모든 뉴런들이 같은 행위를 하여, 결국 같은 gradient 값을 가지며, 같은 양만큼 update 될 것이다. 따라서 많은 뉴런이 전혀 의미가 없어진다. Idea 2 ) Small Random Numbers init가령 weight_scale 같은 걸 지정하여 W = np.random.randn(D, H) * weight_scale 와 같이 랜덤하게 주는 방법이다. 이 경우는 작은 네트워크에선 잘 들어맞지만, 네트워크가 깊어질수록 문제가 생긴다. weight_scale의 정도에 따라 초기 값들이 작으면 계속해서 작은 gradient가 만들어져 작은 값을 넘겨준다(backprop). 따라서 최종적으로 모든 뉴런의 activation이 0으로 몰리게 된다. (모든 뉴런이 죽음) 초기 값들이 크다면, activation이 모두 1이나 -1로 몰리게 된다. (모든 뉴런이 포화) 두 경우 다 네트워크의 층이 의미가 없어지는 방향이므로 좋지 못하다. Idea 3 ) Xavier initinput의 variance와 output의 variance를 같게 유지하자는 것이 목표인데, 결과적으로 굉장히 잘 들어맞는다! 각 layer의 입력에 대략적인 unit gaussian 형태가 입력되기 때문에 위에서 언급한 문제가 발생하는 것을 방지한다. 단 ReLU를 사용할 때에는 절반의 뉴런이 어차피 죽게 되기 때문에, 추가적으로 /2 를 붙여주어야 한다. 강의에서 General Rule of Thumb으로, Xavier부터 시작하라는 조언을 해 주었다. Batch Normalization 배치 단위로 입력 데이터를 (각 dimension에 대하여) 정규화시키는 행위를 의미한다. (아래 사진 참고) 참고로, dimension(feature) 단위로 mean과 std를 계산하여 정규화를 진행하는 Batch Normalization과 다르게, Layer Normalization이라는 놈은 batch 단위로 mean과 std를 계산하여 정규화한다. 이외에도 다양한 Normalization 기법이 존재하는데, 아래의 직관적인 그림이 많은 도움이 되었다. Batch의 크기가 결과에 유의미한 영향을 주는 Batch Normalization과는 달리, Layer Normalization은 Batch의 크기와 결과가 무관하다. (즉, hyperparameter 하나가 줄어드니까 이득!) 주로 Fully Connected Layer나 Convolutional Layer 이후에, 그리고 nonlinearity 이전에 적용한다. $\\gamma, \\beta$ 의 parameter들을 이용하여 최종적으로 $y_i$를 scale 및 shift 하며, $\\gamma$와 $\\beta$는 BN의 backpropagation을 통해 학습된다. 전체적인 과정은 아래와 같다. Test Time 시에는 Train Time과 비교하였을 때 BatchNorm layer가 다르게 작동한다! 각 mean, std가 train time 시에는 배치별로 계산되어 사용되지만, test time에서는 일일히 배치들의 mean과 std를 계산할 필요가 없기 때문에 training 과정에서 계산되는 running mean, running var와 같이 고정된 값의 mean, std를 사용한다. Babysitting the Learning ProcessData Preprocessing을 완료하고, 적절한 architecture도 정했다고 하자. 이제 double checking 과정들을 통해 모델을 검증하면서, 좋은 성능을 낼 수 있도록 hyperparameter들을 잘 골라 모델을 train 해주면 된다. Loss value Double Check SoftMax Loss에서, 초기에 W가 매우 작을 때 $ \\text{loss} = \\log(\\text{number of classes}) $ 이었다 (참고: CS231n Lecture3) 따라서 weight_scale을 매우 작게(0.0001) 두고 regularization = 0.0 으로 두었을 때 loss 값이 $\\log(\\text{number of classes})$ 가 나오는지 확인한다. 위의 상황에서 regularization 값을 크게 올렸을 때(1e3) loss 값이 더 커지는지 확인한다. Training (Learning Rate 찾기) 아주 작은 portion(20개)의 training data로 overfit이 가능한지 확인한다. 결과적으로 아주 작은 loss와 train accuracy 1.00 이 나와야 한다. small regularization(0.000001)로 두고, loss가 줄어드는 적절한 learning rate를 찾는다. 만약 loss가 줄어들지 않는다면 learning rate가 너무 작은 것이고, loss가 발산한다면 learning rate가 너무 높은 것이다. cost가 NaN이 뜬다면 거의 대부분 learning rate가 크다는 것을 의미한다. Hyperparameter Optimization기본적으로 coarse -&gt; fine cross-validation을 실행한다: 처음에는 소량의 epoch만 돌려 보며 param의 대강적인 구간을 파악하고, 이후 running time을 늘린 finer search를 해준다. log space에서 optimize 해주는 것이 팁이다. (ex: lr = 10 ** uniform(-3, -6)) 또 하나의 팁은, 기존의 cost보다 다음 cost가 3배 이상보다 커진다면 발산하는 것이니 바로 break out 해줘도 된다. 위의 예시와 같이 Random Search를 해주는 것이 Grid Search를 해주는 것보다 유리한데, 그 이유는 Random Search 시에 더 많은 종류의 ‘중요 parameter’ 예시를 실험해 볼 수 있기 때문이다. 아래의 그림을 참고하라. Loss Curve를 monitor, visualize 하는 것도 좋은 방법이다. Learning Rate에 따라 아래와 같이 다양한 형태의 loss curve가 나타날 수 있다. 이를 참고하여 learning rate 값 설정에 적용하자.","link":"/2022/09/23/2022-09-23-CS231n-Lecture6/"},{"title":"CS231n Lecture7 정리","text":"Lecture 7 : Training Neural Networks, Part IINeural Network를 train할 때 필요한 Optimization 및 Regularization 기법들, 그리고 Model Ensemble과 Transfer Learning에 대하여 소개한다. OptimizationSGD보다 나은 optimization 방법들에 대하여 알아본다. Problems of SGD1) loss가 한 쪽 방향으로는 빠르게 변하지만 한 쪽 방향으로는 느리게 변한다면? 굉장히 비효율적인 탐색. 2) loss function이 local minima나 saddle point를 가진다면? Gradient가 작은 지점들이므로, 그 지점에 ‘빠지게’ 된다. (Gradient descent gets stuck). 참고로, high dimension 일수록 saddle point가 매우 흔해진다. 3) gradient가 minibatch 들로부터 계산되므로 굉장히 noisy 할 수 있다. Momentum 왼쪽 그림과 같이 SGD에 momentum을 도입하는 아이디어가 제시되었다. 오른쪽 그림은 Nesterov Momentum에 관한 그림이다. 식으로 표현하면 다음과 같다: v_{t+1} = \\rho v_t - \\alpha \\nabla f(x_t + \\rho v_t)x_{t+1} = x_t + v_{t+1}$x_t$와 $\\nabla f(x_t)$ 에 대한 식으로 표현하기 위해서, $\\tilde{x}_t = x_t + \\rho v_t$ 로 두고 식을 정리하면 아래와 같다. v_{t+1} = \\rho v_t - \\alpha \\nabla f(\\tilde{x}_t)\\tilde{x}_{t+1} = \\tilde{x}_t - \\rho v_t + (1 + \\rho)v_{t+1}\\quad \\quad \\quad = \\tilde{x}_t + v_{t+1} + \\rho (v_{t+1} - v_t)AdaGradAdaGrad는 매 단계에서 각 dimension의 historical sum of squares를 바탕으로 한, gradient의 element-wise scaling을 더하는 것이다. (Added element-wise scaling of the gradient based on the historical sum of squares in each dimension) 이미 많이 변화한 변수들은 optimum에 거의 도달했다고 생각하고 step size를 줄이고, 그렇지 않은 경우는 step size를 크게 하기 위해서이다. h \\leftarrow h + {\\partial L \\over \\partial W} \\odot {\\partial L \\over \\partial W}W \\leftarrow W - \\eta \\cdot {1 \\over \\sqrt{h}} {\\partial L \\over \\partial W}AdaGrad의 문제점은, step size가 점점 작아지기 때문에 stuck 할 수 있다는 것이다. RMSProp위의 문제점을 보완하기 위하여, $h$ 값을 계산할 때 decay rate를 준다., 즉, 과거의 정보에 가중치를 작게 부여하고 최근 값에 큰 가중치를 부여한다. h_i \\leftarrow \\rho \\cdot h_{i-1} + (1-\\rho)\\cdot {\\partial L_i \\over \\partial W} \\odot {\\partial L_i \\over \\partial W}AdamAdam은 momentum이 있는 RMSProp 이라고 생각할 수 있다. 한 특징은, AdaGrad과 Momentum 방식에서 정의한 $h$, $v$가 최초 0으로 설정되어 학습 초반에 0으로 biased 되는 문제를 해결하였다는 점이다. (초반에 너무 큰 보폭 방지) m_i \\leftarrow \\beta_{1} \\cdot m_{i-1} + (1-\\beta_{1}) \\cdot {\\partial L \\over \\partial W}\\hat{m}_i \\leftarrow {m_i \\over 1 - \\beta_{1}^{i}}v_i \\leftarrow \\beta_{2} \\cdot v_{i-1} + (1-\\beta_{2}) \\cdot ({\\partial L \\over \\partial W} \\odot {\\partial L \\over \\partial W})\\hat{v}_i \\leftarrow {v_i \\over 1 - \\beta_{2}^{i}}\\text{next W} = \\text{W} - { \\text{learning rate} \\times \\hat{m}_i \\over \\sqrt{\\hat{v}_i} + \\text{epsilon}}$\\beta_{1} = 0.9$, $\\beta_{2} = 0.999$, $\\text{learning rate} = 1e-3 \\ \\ \\text{or} \\ \\ 5e-4 $ 가 많은 모델의 좋은 starting point라고 한다. Learning rate decay위에서 제시한 SGD, SGD + Momentum, AdaGrad, RMSProp, Adam 모두 learning rate를 hyperparameter로 가진다. 이 때, learning rate에 다음과 같은 decay 방식들을 사용해 줄 수 있다. step decay : 몇 개의 epoch 마다 얼마 정도(ex. 절반)씩 learning rate를 낮춘다. exponential decay : $ \\alpha = \\alpha_{0} e^{-kt} $ 1/t decay : $ \\alpha = \\alpha_{0}/(1+kt) $ learning rate decay는 second-order hyperparamter라 처음부터 optimize할 필요는 없다. 이 효과는 SGD+Momentum에 중요하고, Adam에서는 자주 쓰이지는 않는다. First-Order Optimization Use gradient to form linear approximation Step to minimize the approximation Second-Order Optimization Use gradient and Hessian to form quadratic approximation Step to the minima of the approximation J(\\theta) \\approx J(\\theta_{0}) + (\\theta - \\theta_{0})^T \\nabla_{\\theta}J(\\theta_{0}) + {1 \\over 2}(\\theta - \\theta_{0})^T H(\\theta - \\theta_{0})\\theta^{*} = \\theta_{0} - H^{-1} \\nabla_{\\theta} J(\\theta_{0})Second-Order Optimization은 learning rate이 필요하지 않다는 장점을 가진다. (No hyperparameters) 하지만 Hessian이 $O(N^2)$의 공간복잡도를 가지며 inverting에는 $O(N^3)$의 공간이 필요한 것을 고려하면 딥러닝에서는 적합하지 않다. (N이 1000만~1억 정도임을 고려하라.) 따라서 다음과 같은 방법들로 이를 해결한다. Quasi-Newton methods (e.g. BGFS): Hessian을 invert 하지 않고, inverse Hessian을 $O(N^2)$으로 근사하여 사용. L-BGFS(Limited memory BGFS): 전체 inverse Hessian을 저장하지 않는다. L-BGFS는 full batch, deterministic mode에서 굉장히 잘 먹힌다. mini-batch setting에서는 잘 먹히지 않는다. 결과론적으로 대부분의 상황에서 Adam이 좋으며, 만약 full batch update를 할 수 없는 상황이라면 L-BGFS를 고려해 보아라. Model EnsemblesModel Ensemble이란 여러 개의 model들을 학습시킨 후, test time에서 이 결과들의 평균으로 최종 결정을 하는 기법을 말한다. 극적인 점수 향상보다는 2% 정도의 성능 향상을 기대할 수 있다. 아래는 몇 가지 제시된 팁이다. 여러 개의 Independent한 모델을 쓰기보다는, 한 모델을 학습할 때 등장한 여러 snapshot들을 사용해 보아라! Polyak averaging: actual parameter vector를 이용하기보다는 parameter vector의 moving average를 저장했다가 이를 test time에 사용하라. RegularizationSingle-model의 성능을 향상시키기 위해서는 Regularization 작업을 해줄 수 있다. 다양한 Regularization 기법들에 대하여 알아보자. Add term to lossL = {1 \\over N} \\sum_{i = 1}^{N} \\sum_{j \\neq y_i} \\max (0, f(x_i ; W)_j - f(x_i ; W)_{y_i} + 1 ) + \\lambda R(W)가장 흔히 사용되는 L2 regularization은 다음과 같다. R(W) = \\sum_{k} \\sum_{l} W_{k,l}^2DropoutDropout은 각 forward pass마다 random하게 몇 개의 뉴런을 zero로 바꾸어주는 것이다 (비활성화 시키기). 각 뉴런이 비활성화될 확률이 hyperparameter가 되며, 0.5가 가장 많이 쓰인다. 이 방법은 모델로 하여금 예상하지 못한 feature 선정을 강요하여, 각 특징의 co-adaption을 막음으로써 regularization 역할을 해준다. 또한 Dropout을 parameter를 공유하는 large ensemble of model 이라고 해석할 수도 있다. 각 binary mask가 하나의 모델이 되는 것이다. Dropout을 하게 되면 output이 random하게 나온다. 따라서 test time에서는 randomness를 평균 처리하여 output이 바뀌는 것을 방지한다. 전체 결과를 연산한 후, dropout probability를 곱해주면 된다. Dropout probability에 영향을 받지 않는 prediction code를 만드려면, prediction할 때 probability를 곱하는 대신에 train할 때 각 연산 단게마다 probability로 나누어주면 된다. Data AugmentationHorizonatl Flips, Random crops and scales, Color Jitter 등등 다양한 기법을 이용하여 input data를 늘려, 모델의 성능을 향상시킨다. Transfer LearningTransfer Learning이란 특정 dataset(e.g. Imagenet)을 대상으로 학습한 model을 가져다가 다른 유사한 문제에 그대로 가져와서 사용하여 학습하는 기법을 말한다. Transfer Learning은 현재 굉장히 자주 쓰이는 기법임을 알아두자! (특별한게 아니라 쓰는 경우가 더 많다) Train Dataset의 이미지 개수가 1M (백만) 이하라면, transfer learning을 고려해 보자. 참고자료https://dalpo0814.tistory.com/29","link":"/2022/11/15/2022-11-15-CS231n-Lecture7/"},{"title":"존리의 금융문맹 탈출","text":"“당신이 길에서 마주치는 10명 중에 9명이 금융문맹이다” 부족하더라도 조금씩 투자의 첫 발을 내딛게 하는 책 기초 투자 철학 확립을 위한 메시지를 담은 책! 돈에 대한 불안과 두려움에서 벗어나는 요기를 주는 책 책 내용 정리저평가된 기업을 찾기 위한 핵심 지표 PER (Price Earning Ratio, 주가수익비율) 기업의 주식 가격을 주당순이익으로 나눈 값 기업이 투자한 돈을 얼마나 짧은 시간에 회수할 수 있는가? PER이 1이면, 1년 만에 원금을 회수할 수 있다는 뜻이다. PER이 높다는 것은 고평가 되었다는 의미일 수도 있지만, 시장에서 해당기업의 성장성을 높게 평가한다는 의미이기도 하다. (절대적인 기준 X) PDR (Price to Dream Ratio, 주당 미래 전망 ) ‘꿈’이란 요소를 넣은 지표 (e.g. TESLA) 재무제표나 PER만 보았을 때 납득할 수 없는 주가가 PDR을 감안하면 이해될 수 있음. PBR (Price to Book Value Ratio, 주가순자산비율) 주식 가격을 주당순자산으로 나눈 값 주가가 순자산(회사 전체 자산에서 부채를 뺀 값)에 비해 1주당 몇 배로 거래되고 있는지 측정하는 지표 PER은 수익성을 기준으로 주식이 싼지 비싼지 평가하는 지표라면, PBR은 기업이 보유한 자산에 비해 주식이 싼지 비싼지 평가 대체로 성장이 둔화된 기업의 PBR은 낮고 성장이 높은 기업의 PBR은 높다. EV/EBITDA EV(Enterprise Value): 시가총액에 그 회사의 순현금 혹은 현금성 자산을 제외하고 부채를 더한 값 EBITDA(Earnings Before Interest, Taxes, Depreciation and Amortization): 회사의 총이익에 감가상각비와 세금을 더한 것. EV/EBITDA가 낮을수록 인수가격이 부담이 없다는 뜻이다. PEG (Price/Earnings-to-Growth) PER을 (보통 5년간의) 이익증가율로 나눈 지표로, 장기적 예측을 위함. PEG 값이 낮다는 것은 향후 이익성장율이 높은 회사가 저평가되어 있다는 의미이므로, 투자해도 좋다는 시그널이 될 수 있음. 한국 주식시장이 ‘프리미엄’으로 거래되기 위한 사항 (존리의 생각) 퇴직연금제도의 전환이 필요하다. 주식시장에 들어와서 활약해야 할 자금이 은행 예금 등의 ‘원금 지키기’ 상태에 머물러 있음. 국민연금 등 연기금 역시 한국 주식시장에의 투자 비중을 높여야 한다. 한국 시장이 영원히 성장하지 않을 것이란 가정은 지극히 패배적인 사고방식이다. 시장이 연못처럼 작아서 문제라면, 바다로 만들겠다는 상상력과 의지가 필요하지 않을까. 우리나라의 퇴직연금 자산 가운데 주식이 차지하는 비중은 부끄러울 정도로 낮다. 기업지배구조의 발전이 필요하다. 한국의 기업지배구조는 아시아에서도 후진국에 속한다. 기업지배구조가 전반적으로 좋아지게 되면 회사의 주식 가격이 올라가게 되고 자본조달 비용이 줄어들면서 사회적 비용이 크게 줄어드는 효과가 있다. 또 하나의 큰 효과는 거대한 규모의 외국인 자금이 한국으로 들어오는 것이다. 열악한 기업지배구조는 특정 기업의 흥망성쇠에 직접 영향을 끼치는 것은 물론, 더 나아가 기업이 속한 나라에 위기를 초래하기도 한다. 부동산으로 몰리는 어마어마한 크기의 자금이 방향을 바꾸어 기업에 투자되어야 한다. 자본이 부동산에 묶이게 되면 자본이 열심히 일하지 않게 되고, 전망 좋은 기업들이 투자받지 못하게 되면서 주식시장의 ‘선순환’ 역할을 저해하게 된다. 연금제도다양한 사적연금 가운데 가장 효율적으로 노후의 생활을 지지할 수 있는 ‘퇴직연금’과 ‘연금저축’의 활용 방법. 퇴직연금 확정기여형 퇴직연금(DC = Defined Contribution)회사는 퇴직금 지급을 위한 재원을 외부 금융기관에 적립해주고, 근로자가 그 적립금을 직접 운용한다. 그리고 그 운용 결과에 따라 근로자가 받을 퇴직금이 더 커질 수도 있고 반대로 더 줄어드는 위험도 있다. 확정급여형 퇴직연금(DB = Defined Benefit) 회사가 근로자를 대신하여 적립금을 운용한다. 대신 그러한 운용 결과와 관계없이 근로자는 사전에 확정된 퇴직금을 받게 된다.본인이 속한 기업의 퇴직연금제도를 반드시 확인해야 하고, DC형을 택해서 주식투자 비중이 높은 펀드에 가입해야 한다. 회사가 DB형만 채택하고 있다면 DC형을 추가로 채택할 수 있도록 설득하자. 연금저축연금저축에는 ‘연금저축보험’과 ‘연금저축펀드’의 2가지 종류가 있다. 주식투자 등의 운용으로 수익을 낼 수 있는 연금저축펀드가 더 유리하다. 올바른 투자의 시작일단 월급의 10%는 무조건 떼어서 투자해야 한다. 여기서 몇 가지 중요한게 있다. 우선 빚지지 말아야 하고, 라이프스타일을 바꿔야 한다. “Pay Yourself First!”미국에서 흔히 주고받는 말이다. 돈이 생기면 그 돈을 쓰기 전에 자신에게 먼저 지불하라는 뜻이다. … 이처럼 나 자신을 위해 먼저 돈을 지불한(여유자금을 떼놓은) 다음에 다른 소비 항목들의 우선순위를 정해 남은 돈을 쓴다. 그러다가 돈이 떨어지면, 거기서 멈추어야 한다. 이제부터 ‘매일, 조금씩’ 부자가 되어야 한다. 어제보다는 오늘 조금 더 부자가 되어야 한다는 마음으로, 라이프스타일에 변화를 줘야 한다. 무엇보다 아끼는 습관이 중요하다. 존리의 금융문맹 탈출p.171 후기책 전반적으로 금융에 대한 많은 이론적 지식을 소개할 줄 알았는데, 생각보다 어려운 지식이 많진 않았다. 아무래도 금융에 대해 무지한 한국 사람들, 특히 30~40대를 대상으로 쓴 책이라 그런 것 같다. 그래서 내가 이 책을 선정하기도 하였다. 최소한의 지식을 바탕으로, ‘어떻게 부자가 될 것인지’에 대한 가치관과 세부적인 방법들을 소개하는 책이었다. 책 전체를 관통하는 가치관이 있었는데, 주식에 투자한다는 것은 누군가가 항상 내 노후를 위해서 일하게 만든다는 뜻이다는 것이다. 장기적인 주식 투자를 강조하며, 한국 주식 시장이 현재 이미지와는 다르게 매력적이라는 것을 자주 언급하였다. 부동산이나 은행 예금과 같이 ‘돈이 일하지 않는’ 방식들은 강력하게 지양하였다. 실제로 장기적인 주식 투자를 하고 있는 나에게 이 가치관을 받아들이는 것은 어렵지 않았다. 다만 국내 주식 시장이 좁다는 이유로 쳐다도 안 보고 미국 주식 시장으로 뛰어들었기에, 한국 주식 시장 투자에 대한 새로운 관점을 제시해주었다.","link":"/2022/11/30/2022-11-30-Book1/"},{"title":"브람스를 좋아하세요...","text":"프랑스 문단의 매력적인 작은 괴물, 섬세한 심리 묘사의 대가프랑수아즈 사강이 그려 낸 사강, 그 난해하고 모호한 감정 문구들그녀는 자아를 잃어버렸다. 자기 자신의 흔적을 잃어버렸고 결코 그것을 다시 찾을 수 없었다. “브람스를 좋아하세요?” 그녀는 열린 창 앞에서 눈부신 햇빛을 받으며 잠시 서 있었다. 그러자 “브람스를 좋아하세요?” 라는 그 짧은 질문이 그녀에게는 갑자기 거대한 망각 덩어리를, 다시 말해 그녀가 잊고 있던 모든 것, 의도적으로 피하고 있던 모든 질문을 환기시키는 것처럼 여겨졌다. “브람스를 좋아하세요?” 자기 자신 이외의 것, 자기 생활 너머의 것을 좋아할 여유를 그녀가 아직도 갖고 있기는 할까? 브람스를 좋아하세요...p.60 “그 반 덴 베시라는 청년이 나를 그 연주회에 초대했어. 나는 달리 할 일이 없었고. 그런데 내가 브람스를 좋아하는지 어떤지 더 이상 알 수가 없더라고…… 믿어져? 내가 브람스를 좋아하는지 어떤지 더 이상 알 수도 없다는게……” 그녀는 웃기 시작했다. 처음에는 조그맣게, 이윽고 웃음소리가 점점 커졌다. … 로제의 머릿속에서 폭풍우가 몰아치기 시작했다. (생략) 그것보다도, 도대체 그녀는 지금 왜 웃고 있는 것일까? 브람스를 좋아하세요...p.74 책을 읽으면서 제목이 어떠한 방식으로 스토리에 스며들지 궁금증이 커져만 갈 때쯤, 제목이 처음 등장했다. 자신이 무엇을 좋아하는지조차도 잊고 살아가던 폴에게 시몽의 “브람스를 좋아하세요?”는 그녀의 머릿속을 강타한 하나의 철퇴와 같았다. 인간은 살아가면서 자신만의 가치관이라는 것을 정립한다. 나는 흔히 이를 ‘인생의 기둥 원칙’이라고 표현한다. 살아가는데 기둥이 되는 자신만의 원칙. “세계인권선언의 신전”과 같이 몇 개의 기둥들이 지붕, 즉 삶을 뒷받침하는 것이다. 무지보다 잘못된 가치관이 더 위험하듯, 이 견고한 기둥들은 잘 바뀌지 않는다. 그러나 사소한 질문 하나가 기둥을 무너뜨리기도 한다. 폴의 경우가 그렇다. 시몽의 한 질문이 40년을 살아온 그녀의 기둥을 무너뜨렸다. 우리는 ‘자신’을 잃어버리면 안 된다. 사실 안 되는 건 아니다. 허나 내가 나를 잃어버리면 내 삶, 내 인생이 너무나 아까울 것 같다는 생각을 자주 했다. “내가 내 자신을 모르면 누가 나를 알아주는가?” 하는 어디선가 들은 질문도 인상 깊게 박혀있다. 현생이 힘들더라도 내가 좋아하는 것, 내가 살아가는 이유, 내가 행동하는 이유, 내가 선택하는 이유들을 이따금씩 돌아보며 앞으로 나아가는 것이 바람직한 전진이라고 믿는다. 미래에도 후회하지 않을 것이다. 제목에는 물음표가 아닌 온점 세 개라는 점이 차별점이다. 시몽에게서 질문을 받고 머릿속에 되뇌이는 폴의 모습을 형상화했다는 의견이 지배적이다. ‘죄송합니다. 실제로 제겐 당신에게 그런 이야기를 할 권리가 없었습니다. 저는 질투심에 사로잡혀 있었지만 이제는 질투심은 자신이 소유한 것에 대해서만 가질 수 있는 권리라고 생각합니다. 브람스를 좋아하세요...p.76 마음에 드는 문구였다. 질투심은 자신이 소유한 것에 대해서만 가질 수 있는 권리이다. 나는 ‘모든 사람은 다른 사람을 비난할 권리가 없다’라는 말을 많이 한다. 아무리 상대방이 잘못했어도, 그 사람을 내가 직접 비난할 권리는 없다는 것이다. 잘못한 사람은 그에 합당한 처벌을 받을 것이고, 그러려고 법과 규칙이 있는 것이고.. 너가 뭔데 다른 사람을 비난하냐? 위 문구도 마찬가지로 인간의 다른 인간에 대한 ‘권리’의 이야기이다. 이 문구의 ‘질투’는 사실 우리가 사용하는 의미와는 조금 다르다. 문맥상 “소유욕을 가지다”나 “집착”과 같은 의미로 받아들였다. 내 것이 아닌 물건, 내 것이 아닌 사람 (= 애인, 부인) 에게는 조금이라도 집착을 해선 안 된다. 가령 썸을 타는 관계라고 할 지라도, 앞서가거나 집착하는 것은 금물이지 않는가. 냉철하게 바라보면, 애당초에 아무것도 아닌 관계이다. 상대방이 연락을 해줄 이유나 명목조차 없는. 폴은 눈치채지 못했지만 그들이 처음으로 함께 밤을 보낸 날 시몽은 잠을 이루지 못했다. (생략) ‘자는 체하려면 애정이 지나치든가 권태가 지나치든가 해야겠군.’ 하고 그는 막연하게 생각했다. 이제까지 권태가 지나친 쪽의 경험만을 해 온 그는 잠든 폴에 대해 순수한 열정을 바친 숫처녀에게보다 더 큰 책임감을 느꼈다. 두 사람은 그렇게 조심스럽게 감동되어 각자 자고 있는 체하며 상대가 깰까 봐 꼼짝도 하지 않은 채 몸을 맞대고 서로를 지켜보며 밤을 지새웠다. 시몽은 행복했다. 그는 자신보다 열네 살 연상인 폴에게 열 여섯 살짜리 여자아이에게보다 더 큰 책임감을 느꼈다. 브람스를 좋아하세요...p.109 무려 열네 살이나 연상인 여자와 사랑을 하게 된 시몽이, 상대가 나이가 많음에도 불구하고 더 큰 책임감을 느꼈다는 심리 묘사가 이 문구를 포함하여 책의 곳곳에 드러났다. 처음엔 이 심리가 신기했는데, 조금 더 생각해보니 책임감이 애정으로부터 기원하여, 애정의 척도로 볼 수 있다고 생각했다. 이에 주변의 부정적인 시선까지 합쳐져 시몽은 엄청난 책임감을 느낀 것이다. 나였어도 그랬을 것이다. “모르지. 어째서 당신은 내가 미래를 준비하느라 현재를 망치기를 바라는 거지? 내가 관심 있는 건 오직 내 현재뿐인데 말이야. 그것만으로도 난 충분해.” 브람스를 좋아하세요...p.113 20대 중반 시몽의 패기가 느껴지는 문구다. 한 단어로 표현하면 ‘낭만’이다. 성공 욕심이 많은 대한민국의 20대로서, 남은 험난한 20대를 대비하여 마음 속 고이 접어 숨겨두었던 낭만을 일깨워주는 문구였다. “알다시피 난 지금 당신과 함께 있어서 무척 행복해. 하지만 내가 바라는 건 그 이상이야. 난 당신도 나와 함께 있어서 행복했으면 좋겠어. 지금 당신은 행복해지기에는 지나치게 로제에게 집착하고 있어. 당신은 우리의 사랑을 우연한 것이 아니라 확실한 그 무엇으로 받아들여야 해. 내가 그렇게 만들 수 있도록 도와줘야 한다고.” 브람스를 좋아하세요...p.140 표현이 멋있어서 적었다. 우연한 것이 아니라 확실한 그 무엇으로 받아들여야 해. 후기한 남자 로제만 사랑하는 폴, 그러나 여러 여자들과의 관계를 즐기는 로제, 이 사이에 끼어들어 순수한 사랑만으로 접근하는 시몽. 폴은 일방적으로 주는 사랑에 익숙해져 있다가 시몽을 통해 ‘자신’을 되찾고 받는 사랑에 유혹되지만, 결국 견디지 못하고 돌아간다. 그리고 그 첫 날부터 바뀔 것 같았지만 전혀 바뀌지 않은 로제의 모습으로 책이 마무리된다. 소수의 주인공만 등장하여 생생한 심리 묘사를 맛볼 수 있었다. 가볍고 재밌게 읽은 고전 책이었다. 이 책을 스물 네 살이 적었다는게 처음부터 끝까지 믿겨지지 않았다.","link":"/2022/12/03/2022-12-03-Book2/"},{"title":"MAICON 후기","text":"2022년 9월 30일부터 시작하여, 11월 8일부터 11월 14일까지의 MAICON 예선을 참여한 후기를 적었다. 필자와 같은 부대에서 참여한 총 4명의 팀원들은 모두 AI 프로젝트 경험이 사실상 없는 초보였으며, 전원 코딩테스트 통과 이후 예선전에서 25위 / 35팀 을 하여 여정을 마쳤다. 참여 과정MAICON(Military AI CompetitiON)은 군 장병들을 대상으로 한 AI/SW 강의(Elice) 사이트에 올라온 공지사항에서 처음 발견하였다. 일정은 아래와 같았다. 2022.09.30(금) ~ 10.14(금) : 참가 신청 및 코딩테스트 진행 2022.11.08(화) ~ 11.14(월) : 온라인 예선 2022.11.30(수) ~ 12.01(목) : 오프라인 본선 필자는 7월 경 AI에 입문하여 CS231n 강의 시청과 Assignment를 한창 달려오던 중 번아웃이 온 시기였다. 눈 앞에 보이지 않는 보상은 역시나 정신적 동기부여를 흐릿하게 만들었고, 나 혼자 잠을 줄여가며 하는 공부에 회의감이 몰려 오던 찰나였다. AI 경진대회 참여는 확실한 동기부여이자, 보상이자, 성장의 지름길이라고 판단했다. 예선 부터는 반드시 4인 1팀으로 참여해야 했고, 같은 부대의 아는 사람들끼리 하는 것이 편할 것 같아 동기 두 명과 후임 한 명을 데려와 팀을 만들었다. 목표는 예선에서 10팀 안에 들어 본선 진출. 코딩테스트군 장병 부문은 전체를 대상으로 알고리즘 코딩 테스트를 진행하였다. 참가자들에게는 A, B, C 의 세 가지 유형이 랜덤하게 주어졌고, programmers에서 2시간 / 3문항 (300점 만점)이었다. 500명 정도 신청한 대회에서 총 140명(35팀)이 코딩테스트를 통해 선발되었다. 사실 말이 많이 나온 테스트였지만, 여기서는 생략하도록 하겠다. 개인적으로는 Python 3 만을 사용하게 한 점과, AI 경진대회의 참여 조건으로 알고리즘 테스트를 보는 이유가 이해되지 않았다. 그래도 덕분에 C++ 로만 해본 알고리즘 공부를 Python으로 하는 경험이 되었다. 일주일 남짓의 시간 동안 Programmers에서 제공하는 코딩테스트 고득점 Kit를 Python 으로 풀었는데, 생각보다 많은 도움을 주었다. 처음 알고리즘을 입문하는 사람 말고, 필자처럼 1~2년 동안 손 놓았던 알고리즘 코테를 갑자기 맞닥드렸을 때 감 잡는 용도로 활용하면 좋을 것 같다. 필자는 180점 / 300점 을 받았는데, 합격 커트가 118점, 합격자 평균이 200점인 것은 꽤나 놀라웠다. 군인을 대상으로 한 타 대회에 비해 합격 커트와 평균이 상당히 높았기 때문이다. 장병 뿐 아니라 공무원, 간부들도 포함되서 그런가 싶었다. (실제로 합격자 중에 중령 분도 계셨다) 다음에 진행되는 MAICON을 준비하는 사람들은, 이 코딩테스트 ‘생각보다 잘’ 대비해야 한다고 말해주고 싶다. 필자는 사전에 꾸린 팀원 4인이 모두 코딩 테스트를 통과하여, 별도의 팀빌딩이 필요하지 않았다. 예선예선 정보예선은 다음의 사이트 에서 진행되었다. 정보는 아래와 같았다. 주제: 항공 이미지 데이터를 활용한 건물 변화 탐지 (군 정찰 자산 활용성 극대화를 위한 AI Computer Vision) 문제 정의: 전후 이미지를 비교하여 건물 변화를 탐지 및 분할하는 문제 제출 횟수: 결과 제출 제한 - 1시간 1회 제출 제출 용량: 최대 50MB 활용 가능 데이터: 주최 측에서 제공한 학습 데이터 외의 외부 데이터 활용 금지, 테스트 데이터는 학습에 사용할 수 없음 (Pseudo labeling 금지) 사용 가능 Pre-trained model: 법적 제약이 없고 대회 공고일(2022년 9월 30일) 전까지 공개된 Pre-trained model 사용 가능 평가 지표: mIoU (mean Intersection over Union), keras.metrics.MeanIoU와 동일 로직 예선전 진행결과론적으로, 부대로부터 정말 전폭적인 지지를 받았다. 부대가 AI 교육 시범 부대로 선정되어 AI 교육을 위한 교육장까지 지어지고 있었을 정도로 대대장님, 단장님, 사령관님께서 긍정적인 관심을 가진 덕분이었던 것 같다. 도움을 받기 위해 처음이자 마지막 마음의 편지를 작성했었는데, 생각 이상으로 여건을 많이 보장 받았다. 예선전 기간과 그 전 주의 2주 정도를 대부분의 일과를 빠지고 싸지방에서 AI 공부 및 대회 참여를 하였다. 또한, 잠실의 KT 지사에 방문하여 멘토링 Meeting을 통해 도움을 받을 수 있었다. 사람이 적고 작업과 훈련이 많아 휴가 측면에서도 굉장히 엄격했던 부대라 상상도 못한 여건 보장이었다. 육군 출신이면 이게 얼마나 말이 안 되는 상황인지 알 것이다. 열심히 살아가는 사람들에게 세상이 아직 따뜻하다는 생각을 했다. 예선전 전부터 주제가 미리 공지되었던 터라 Computer Vision, 그 중에서도 Image Segmentation을 공부하였다. 기초 논문들부터 SOTA 까지 공부했고, 개인적으로 Colab과 Kaggle을 이용하여 Pytorch, Wandb와 같은 실전 툴들을 익혔다. 필자는 특히 CS231n으로 AI 입문을 하던 터라 기초 수학적 이론은 정립되어 있었지만 Pytorch를 다룰 줄 몰랐기에 이에 더 집중했다. 하지만 프로젝트 경험이 없는, 특히나 AI 경진대회 경험이 한 명도 없는 팀은 너무나 많은 시행착오를 겪어야만 했으며, 빅데이터의 세계에서 시행착오 한 번은 너무나 큰 리스크였다. 모델 학습을 돌려 놓고 자고 눈 뜨자마자 뛰어 찾아간 싸지방 모니터에 CUDA memory error로 저장도 못 하고 터져있는 모델을 마주했을 때는 울고 싶었다. 유의미한 학습에 최소 10시간은 필요한 상황에서, 학습 결과의 초반을 보고 뚝심 있게 기다리는게 맞을지 보완을 해서 바꿔 돌려야 하는지의 판단도 서툴렀다. 팀 프로젝트에서 효율적인 협업, 전략, 역할 분배, GPU 관리 등 많은 것이 부족했다. 프로젝트전체적으로 likyoo의 change_detection.pytorch을 import 하여 사용하였다. 이 library는 ‘Change Detection of remote sensing images’를 위해 만들어진 library로, 다양한 util function 들과 model, encoder를 지원해 주어 사용하였다. 대회 당시에는 본 library를 fork 하여 조금 수정하여 사용하였다. 주어진 문제의 가장 특이했던 점은 Multiclass Change Detection 이라는 점이었다. 기존의 대부분 Change Detection (이하 CD) 문제들은 바뀐 영역은 1 (흰색), 그렇지 않은 영역은 0 (검은색)으로 표현하는 것이 대부분이었다. 예선전 전까지는 당연히 이를 대비하여 공부하였다. 그러나 본 Task에서는 다음과 같은 multiclass classification을 요구하였다. Background(Pixel Value 0): 신축, 소멸, 갱신 중 어느 것에도 해당되지 않음 신축(Pixel Value 1): 왼쪽 대비 오른쪽 사진에 건물이 생성된 경우 소멸(Pixel Value 2): 왼쪽 대비 오른쪽 사진에서 건물이 붕괴되어 없는 경우 갱신(Pixel Value 3): 양쪽 같은 위치에 건물이 있으면서 한쪽에 변화가 있는 경우 Multiclass가 추가되니 굉장히 많은 Idea들이 적용될 수 있었다. 우리 팀은 다음의 idea들을 시도해 보았다. 주어진 Dataset의 사진은 전후 사진이 분리되어 있지 않고 직사각형 모양으로 주어졌는데, 직사각형 사진을 통째로 이용하는 방법과 이를 절반으로 나누어 각각 이용하는 방법 Multi-classification을 하지 않고 Mask를 픽셀별로 One-Hot Encoding 하여, 각각에 대한 Binary Classification을 한 뒤 결과를 모두 합치는 방법 주어진 Image를 2 x 2의 4개 Image로 잘라 input으로 사용하는 방법. 이 때 mask 픽셀이 없는, 즉 변화가 없는 data는 모두 소거하였다. 작은 변화 탐지와, Dataset 개수 증가에 따른 성능 향상을 기대하며 시도. 다양한 Model(Unet, Unet++, STANet)과 Encoder(noisy-student + efficientnet-b?, regnety, Swin-T, etc.) 다양한 Albumentations (Cropping, Gaussian Blur, etc.) 적용 다양한 Loss (Jaccard Loss, Dice Loss, Hybrid Loss = Jaccard Loss + Dice Loss, Cross Entropy Loss, etc.) 사용 다양한 Learning Rate (1e-3, 1e-4, 1e-5, etc.) 사용 다양한 Learning Rate Scheduler (CosineAnnealing LR, Step LR) 사용 다양한 크기의 Batch 사용 Shadow Remover 와 같은 외부 library를 이용한 data preprocessing 예선전 기간 동안 명확히 확인할 수 있었던 중요한 factor는 model 및 encoder, loss, learning rate, batch 정도였다. Model 및 encoder, learning rate의 영향을 받는 것은 당연했다. 여기에 덧붙여 Loss 종류와 Batch의 크기에 따라 생각보다 많은 영향을 받았다. 다만 이 두 factor를 다루는 데에 있어서 지식이 많이 부족하고 미숙했다. Loss의 경우에는 Binary Classification 에만 활용되고 Multiclass Classification에는 사용될 수 없는 Loss가 꽤 있었는데, 제대로 공부하지 않고 그냥 가져다 사용한 덕에 무의미한 학습으로 초반 시간을 날렸다. Batch 크기의 경우 GPU 서버의 RAM Memory와 직결되는 factor인데, 특히 SOTA에 가깝거나 parameter가 많은 무거운 모델의 경우 batch size를 조금만 올려도 CUDA memory error를 마주했다. 대회 기간 내내 어쩔 수 없이 batch의 크기를 4와 같은 작은 숫자로 진행하였는데, 결과론적으로 몇 천 장이나 되었던 dataset을 작은 크기의 batch로 학습시키는 것은 성능도 아쉬웠고 시간도 너무 오래 걸렸다. 대회가 끝난 후, 같이 참여한 예선전에서 1등을 한 과 후배가 Auto Mixed Precision이라는 방법을 알려주었는데, 이를 사용했으면 성능이 많이 향상되었을 것 같다고 생각했다. 이외의 Idea들이 무의미했다는 것이 아니라, 대회 기간 내에 미처 확인을 하지 못했다. 필자는 Hyperparameter Tuning 쪽 보다는 문제 해결의 접근법 자체에 집중하여 One-Hot Encoding, 2 x 2 Split 등의 Idea를 제시하고 코드로 옮겨 시도했었는데 시간 상의 문제로 각 Idea에서 최적의 결과를 확인하지 못했다. 최종 제출한 Submission도 어떤 방법을 사용한 방법인지 사실 기억이 안 날 정도다. 그럼에도 다양한 Idea를 떠올리고 코드로 변환, 적용할 수 있었던 점에서 뿌듯함을 느꼈다. 대회 기간 동안 다양한 Notebook 형태의 코드들을 돌렸는데, 이 중 몇 개를 GitHub에 올려두었다. 팀원 김태한이 정리한 것을 Fork 하여 올린 repo이다. 허나 시간이 굉장히 촉박했던 해커톤 형태였던 만큼, 코드들이 굉장히 더럽고 오류 난 결과가 그대로 있는 코드이므로 정말 참고용으로만 봐주기 바란다. 촉박한 시간 안에도 침착하게 깔끔하고 re-usable한, 자동화된 코드를 짜내는 것이 코딩 실력 아닐까? 지금 봐도 변수명들이나, 코드 아키텍처 등 잔뜩 hardcoding된 코드를 보면 굉장히 부끄럽다. 살제로 대회가 끝나자마자 코드를 컴퓨터에서 다 지워버렸을 정도였다. 그래도 지금 보면, 이게 해커톤 코드의 매력인 것 같기도 하다. 느낀 점 정리 (프로젝트) 생각보다 GPU 서버의 성능이 굉장히, 굉장히 중요했다. 왜 주변에서 고액의 서버를 지원 받았다고 그렇게 자랑하고, 서버 지원 여부에 따라 강의 평가가 그렇게 갈리는지 뼈저리게 깨달았다. 근데 그만큼 중요한 건 Memory 관리 능력이다. Auto Mixed Precision 과 같이 적은 RAM Memory 안에서 고효율의 작업을 하는 것이 매우 중요함을 깨달았다. 받은 Dataset에 오류가 있는 Data도 꽤 있었다. 데이터 개수도 충분히 많았는데, 왜 얘네를 아예 빼고 학습시킬 생각을 못 했는지 모르겠다. 오류가 있는 Data를 걸러내는 작업은 필수적으로 선행해야 한다. 위의 내용에 이어, Data를 전부 이용할 필요도 없다고 느꼈다. 학습에 더 도움이 되는 데이터만을 이용해서, 같은 시간 내 더 큰 batch size로 더 많은 epoch을 돌려 더 좋은 성능을 낸 경우를 보았다. 후기엄청난 지지와 기대를 어깨에 짊어진 우리 팀원 모두는 부족한 이론 베이스를 어떻게든 극복하고자 정말 열심히 고군분투 했다. 나는 감히 ‘성인 되고 이보다 치열하고 집중했던 적이 없었다’는 표현을 여러 번 사용했는데, 지금 되돌아봐도 과장은 아니었다. 모두가 간절했고, 진심이었다. 그래서 많은 감정을 느꼈다. 필자는 이번 기억을 기억에 남는 첫 실패 라고 정리하였다. 팀원 한 명이 친구가 해외 IT 대기업 면접에서 실패 경험을 물었을 때, 제대로 답변하지 못했다고 했다. 사실 필자도 지금까지 실패 한 경험이 있나, 돌아봤을 때 딱히 떠오르지 않았다. 고등학교부터 대학교까지, 노력한 대가로는 모두 목표했었던 대로 훌륭한 결실을 맺었다. 이번 경험은 조금 달랐다. 예선 기간 내내 대회 말고 한 게 잠, 식사, 점호 뿐일 만큼 매달렸지만, 결과는 처참했다. 그러나 후회는 없다. 예선전이 끝난 날에는 ‘지금부터 일주일을 줬으면 순위권 안에 충분히 들어갔다’고 확신했다. 그만큼 예선전이 시작됐을 때 부족했고, 예선전 진행 동안 배운 점도 많았다. MAICON 참여 여부를 고민하는 채로 이 글을 찾아온 사람이라면, 꼭 참가해라. 지원도 최대한 요구해서 많이 받아내라. 귀찮고 두려울수록 더욱 참여해라. 성공하는 사람은 하기 싫은 일을 남들보다 더 많이 한 사람이라고 필자는 생각한다. 변화와 성장은 언제나 사람의 한계점에서 유지할 때 일어난다는 말을 들었다. MAICON은 어찌 보면 스트레스와 부담의 연속이었지만, 내 군생활에서 잊을 수 없는 최고의 경험이었다.","link":"/2022/12/07/2022-12-07-MAICON/"},{"title":"라이브 아카데미 토들러 Study","text":"Youtube 라이브 아카데미 토들러 채널의 토들러 연습가이드 재생목록 복습을 위하여 나온 문단들을 정리한 게시물이다. 01. 1주일 전쯤에 옛날에 알고 지내던 친구한테서 메일이 왔어요. 몇 년은 연락을 안하고 지냈었는데 서로 전화번호 주고 받고 통화도 몇 번 했고요 문자로 꽤 자주 연락하고 있어요. About a week ago, I got an email from an old friend. We hadn't been in touch for a couple of years. We exchanged phone numbers and we spoke(talked) on the phone a couple of times and we've been texting quite frequently. 02. 저는 최소한 1주일에 3번 헬스장에 가요. 주중에 두 번, 그리고 주말에는 한 번. 평일에는 보통 아침에, 출근하기 전에 가요. 주말에는 이른 오후에 가는걸 좋아해요. 1시 쯤에요, 그 시간에 사람이 적은 편이거든요. I go to the gym at least 3 times a week. Twice during weekdays and once on weekends. On weekdays, I usually go in the morning, before I go to work. On weekends, I like to go early in the afternoon, around 1 o' clock because it's less crowded then. 03. 연휴 때 계획 있어요? 네, 가족이랑 짧게 여행을 다녀올 계획이에요. 근데 그럴려면 휴가를 내야 되서 쉽지 않을 거예요. Do you have any plans for the holidays? Yes. I'm planning to go on a short trip with my family. But that means I have to take extra time off work. So it's not going to be easy. 04. 너 오늘 뭐 해? 원래는 강아지들을 공원에 데리고 나갈려고 했는데, 미세먼지가 심할 거라는 얘기를 들어서 그냥 집에 있기로 했어. Hey, what are you going to do, today? Well, I was going to take my dogs out to the park but I heard the smog is going to be really bad today. So, I just decided to stay home. 05. 보통 일 끝나고 뭐 해? 보통은 그냥 집에 가요. 친구랑 한 두시간 정도 만날 때도 있어요. 근데 보통은 일 끝나고 너무 피곤해서 그냥 집에 가서 일찍 자요. What do you do after work? Usually, I just go home. Sometimes, I hang out with a friend for a few hours. But normally, I'm really tired after work. So, I go home and try to go to bed early. 06. 그녀의 기분을 풀어주려고 했던 거였어. 근데 말이 잘못 나왔어. 정말 모르고 한 실수였어. 그녀를 마음 상하게 하려던 게 아니였어. I was (just) trying to cheer her up. But the(my) words came out wrong. It was an honest mistake. I didn't mean to hurt her feelings. 07. 지난 몇 달 동안 밤에 일하고 낮에는 자려고 노력 중인데 그렇게 쉽지 않아요. For the past couple of months, I've been trying to work at night and sleep during the day. It hasn't been very easy. 08. 지난 몇 주 동안 커피를 비롯한 다른 카페인 음료를 줄이려고 노력 중인데 정말 쉽지 않아요. I've been trying to cut back on coffee and other caffeinated drinks for the past couple of weeks. It really hasn't been easy. 09. 내년 초에 이사를 할 계획이에요. 지난 몇 주 동안 이사 갈 곳을 찾고 있는데 한정된 가격대 내에서 괜찮은 곳을 찾기가 정말 힘들어요. 당연한 일이지만. I'm planning to move early next year. I've been looking for a new place for the past couple of weeks. It's really difficult to find a decent place within a limited price range. Obviously. 10. 오늘 밤에 무슨 계획 있어요? 몇 시에 퇴근하는지 봐서요. 제시간에 퇴근할 수 있으면 친구들 만나서 간단하게 술 한잔 할 수도 있는데 안그러면 아마 너무 피곤해서 곧장 집으로 갈거 같아요 Do you have any plans tonight? Well, it depends on what time I get off work. If I can leave on time, I might meet up with some friends for a beer. Otherwise, I'll probably be too tired and go straight back home. 11. 벌써 10월인게 믿기지 않아. 새해 계획을 세우고 있었던게 어제 같아. I can't believe it's already October. It feels like (it was) only yesterday that I was making my new year plans. 12. 내가 벌써 37살 이라니 ... 30살 됐다고 멘붕이었던게 어제 같은데 ... I can't believe I'm already 37 years old. It feels like only yesterday that I was freaking out about turning 30. 13. 내가 이걸 벌써 2년 넘게 하고 있다니... 채널 이름을 생각해내려고 하고 있던게 어제 같은데 ... I can't believe I've been doing this for over 2 years. It feels like only yesterday that I was trying to come up with a name for my channel. 14. 예전처럼 집에서 김치 만드는 사람들이 많지는 않아요. 제가 아는 사람들은 대부분이 요즘은 그냥 사먹어요. 앞으로 몇 년 후면 사람들이 집에서 김치는 만드는 것을 보기가 어려울 것 같아요. Not many people make Kimchi at home anymore. Most people that I know, nowadays, just buy Kimchi. I think, just several years from now, it's going to be very rare to see people making Kimchi at home. 15. 한 달 전 쯤에 운전면허증을 땄어요. 기회가 있을 때마다 연습을 하고 있어요. 아직 아주 잘은 못하지만 서서히 감을 잡고 있어요. I got my driver's license about a month ago. I've been practicing every chance I get. I'm still not very good but I'm slowly getting the hang of it. 16. 친구들은 있는데 서로 자주 보지는 못해요. 일단, 다들 직업이 있어서 항상 일에 얽매여 있어요. 게다가, (우리 중) 대부분이 이제 결혼을 했고 아이가 있는 사람도 많아요. 몇몇은 해외에서 일을 하고 있고 심지어 다른 나라로 이민을 간 사 람도 있어요. 그래서, 뭐, 시간이 지나면서 연락하면서 지내는게 더 어려워지고 있어요. I have friends but we don't get to see each other very often. First of all, we all have jobs so we're always tied up at work. Plus, most of us are married now and many of us have kids. Some are working overseas and a few have even moved to other countries. So, you know, it's getting harder to keep in touch as time goes by. 17. 간략하게 얘기를 하자면, 컴퓨터에 문제가 생겨서 며칠치의 일을 날렸어. 그래서 이제 처음부터 다시 시작해야 돼. 진작에 이런 생각을 했어야 했는데 지금부터는 모든 일을 클라우드를 기반으로 하는 프로 그램만 사용할거야. Long story short, I had a problem with my computer and I lost several days worth of work. So now, I have to start all over again. I should have thought of this earlier, but from now on, I'm going to do all my work (only) on cloud-based programs. [WIP for iPad] Long story short : 간략하게 얘기를 하자면~ ( ) worth of [ ] : ( ) 값어치의 [ ]Long story short, I had a problem with my computer and I lost several days worth of work. start (do … ) all over again : 처음부터 다 해야 해.So now, I have to start all over again. should have thought of this earlier : 진작에 이런 생각을 했어야 했는데,I should have thought of this earlier. cf) should have done this earlier : 진작에 이렇게 할걸, from now on : 지금부터는From now on, I’m going to do all my work on cloud-based programs.","link":"/2023/01/01/2023-01-01-English-LA-Study/"},{"title":"공간의 미래","text":"미래는 꿈꾸는 자들이 만든다 마당 같은 발코니가 있는 아파트, 각 아이들을 위한 맞춤 교육 과정이 있는 학교, 지역과 지역을 이어 주는 선형 공원, 분산된 거점 오피스로 나눠진 회사, 내 집 가까이에 있는 작은 공원과 도서관, 자율 주행 로봇 전용 지하 물류 터널, DMZ 평화 도시 고개가 끄덕여지며 바로 적용될 것만 같은 이야기도 있지만, ‘DMZ 평화 도시’처럼 이게 될까 싶은 이야기도 있다. 하지만 이야기 끝에 저자는 힘주어 말한다. 미래는 꿈꾸는 자들이 만든다고. 소수를 위한 디스토피아가 아닌, 함께 행복한 유토피아는 멀리 있지 않다. 이 책은 그 작은 걸음들의 시작을 위한 고민의 결과다. 기록한 구절45센티미터 이내에 들어오는 사람은 특별한 관계의 사람이다. 연인이나 부모 자식 정도만 그 거리 안에 들어온다. 그런데 만원 버스나 지하철을 탔을 때에는 모르는 사람과도 45센티미터 이내로 가까워진다. 만원 버스나 지하철에서 불쾌감을 느끼는 이유다. … 가끔은 모르는 사람과 가까운 거리에 있어도 기분이 좋은 경우가 있다. 클럽에서 춤출 때다. 그 이유는 입구에서 문지기가 힘들게 나같이 분위기에 어울리지 않는 사람을 골라내서 못 들어가게 선별했기 때문이다. 그래서 그 안에 들어간 당신은 기분이 좋은 것이다. … 이처럼 관계는 사람간의 거리를 결정한다. 그리고 사람 간의 거리는 공간의 밀도를 결정한다. 공간의 밀도는 그 공간 내 사회적 관계를 결정한다. 코로나19라는 전염병은 사람과 사람 사이의 간격을 바꾸었다. 가까웠던 사람들도 멀리 떨어지게 만들었다. 극장, 야구장, 공연장에 갈 수가 없게 되었다. 사람 간의 간격이 바뀌자 사람 간의 관계가 바뀌었고, 사람 간의 관계가 바뀌자 사회도 바뀌고 있다. 공간의 미래p.8 책의 초반에 만난 긴 문단인데, 이 책이 말하고자 하는 방향성을 이해함과 동시에 반드시 끝까지 읽겠다는 강한 의지를 안겨주었다. 살면서 한 번도 ‘공간’이 주는 의미에 대해 생각해 본 적이 없었다. 허나 인간의 삶과, 인간 그 자체를 이해하는 데에 꽤나 주요한 key factor 라고 단숨에 이해했다. 코로나19로 인해 벌어진 많은 일들을 하나의 관통하는 이치로 깔끔하게 설명한 거 같다. 여러 가지 상황들을 종합해서 포스트 코로나 시대에 지어질 아파트의 디자인 원칙을 다섯 가지로 정리할 수 있다. 첫째, ‘1가구 1발코니’다. (생략) 둘째, ‘소셜 믹스 공원’이다. (생략) 셋째, ‘기둥식 구조’다. 기존의 벽식 구조가 아닌, 기둥 구조로 만들어서 바뀌는 시대적 상황에도 재건축 없이 변형해 사용될 수 있게 한다. 넷째, ‘복합 구성’이다. 도시 속에 주거, 업무, 학교 등을 나누어서 배치하는 것이 아니라, 건물 내에 입체적으로 구성하는 것이다. (생략) 다섯째, 친환경적인 목구조를 사용하는 것이다. 공간의 미래p.54 유현준 작가의 미래형 아파트에 대한 생각이다. 개인적으로 ‘복합 구성’이 가장 인상적이었다. 실제로 나도 한 공간이 다양한 역할과 유저 경험을 제공해 주었을 때 재미를 느꼈기 때문이다. 현대 사회에서 가장 시선을 많이 받는 사람은 미디어에 노출되는 사람들이다. 정해진 시간에 하루에 한 시간씩 시선의 집중을 받는 뉴스 앵커맨이 대표적인 사례다. 인스타그램 팔로워 숫자가 높을수록 권력이 높은 사람이고, 유튜브 동영상 조회 수가 높을수록 권력자가 된다. 시대가 바뀌고 기술이 바뀌면 플랫폼은 바뀌지만 시선이 모이는 곳에 권력이 만들어진다는 법칙은 그대로 유지된다. 공간의 미래p.75 작가님의 ‘권력’에 대한 해석이다. 시선이 모이는 횟수와 시간에 따라 권력이 결정되며, 시선이 모이는 것은 ‘공간’과도 직접적인 연관성이 있음을 성당의 긴 의자들을 예시로 설명하였다. 뒤쪽에서는 시간과 공간의 제약을 동시에 하면 권력이 생겨나고 공동체 의식이 만들어진다고 덧붙였다. 하루에 기도를 다섯 번 하는 이슬람교를 예시로 들며, 유목 민족이기 때문에 공간의 제약을 두지 못한 대신 시간의 제약을 더 강하게 규제한 예시라고 하였다. 현대에 대한 권력의 해석도 인상적고, 고개가 끄덕여 졌다. 그런 회사 중 한 회사가 같은 공간에서 함께 시간을 보내지도 않고, 회식도 없다 보니 팀워크에 문제를 느꼈다. 사장은 이 문제를 해결하기 위해 일 년 동안의 임대료와 회식비를 모아서 전 직원이 해외여행을 함께 갔다. 하지만 같은 시공간에서 일하면서 만들어지는 공동체 의식과 놀면서 만들어지는 공동체 의식은 다르다. 공통의 목표와 성취에 기반을 둔 공동체 의식은 같이 여행을 간다고 만들어지지는 않는다. 공간의 미래p.127 책을 읽기 이전의 나를 포함하여, 많은 사람들이 이 사실을 모른다고 생각한다. 함께하는 시간의 양이 중요한 것이 아니었다. ‘시간의 종류’와 ‘시간의 질’이 더 중요하다. 군인인 나의 입장에서, 함께 주특기 훈련을 하며 고생한 선후임들과 함께 웃으며 떠들고 논 생활관 동기들은 느낌이 달랐다. 한 쪽이 더 좋고 나쁜 것이 아니라, 공동체 의식의 종류가 다른 것이다.작가는 우리나라의 회식 문화가 가족적인 분위기의 벼농사 문화의 산물이라고 생각했다. 요즘 MZ 세대들에게 이는 이해할 수 없는 꼰대 문화로 낙인이 찍혀버린 것이다. 결국 회식 문화를 통한 공동체 의식은 일하면서 만들어지는 공동체 의식과 다른 종류이기 때문에 대체할 수 없다. 가령 내가 한 단체의 여행 혹은 MT를 주최한다면, 어떤 종류의 시간을 선사해 줄 것인지 고민해야 한다. 마스크로 인한 소통의 어려움은 동양과 서양이 다르다. 동양인인 우리는 휴대폰에서 웃는 얼굴을 표현할 때 ‘^^’로 웃는 눈을 표기한다. 반면에 서양에서는 ‘:)’로 웃는 입을 표기한다. 동양은 눈으로 감정을 표현하고 서양은 입으로 감정을 표현한다. 인간의 얼굴 근육에서 의지로 조정이 불가능한 근육이 눈 주변의 근육이라고 한다. 입은 의식적으로 웃는 표정을 지을 수 있지만 눈은 가짜로 속이기 어렵다. … 동양이 눈을 보는 이유는, 집단 노동을 해야 하는 벼농사 지역의 사람들은 다른 사람과의 감정 조율의 필요성이 개인 노동 중심의 밀 농사 지역보다 더 컸기 때문이라고 생각된다. 벼농사 지역은 생활 공간에서 사람 간의 거리가 가깝고 감정 파악도 중요하다. 그래서 다른 사람의 감정을 더 정확하게 파악할 수 있게 가까이에서 눈 주변의 근육을 관찰하는 방식으로 발전했을 것이다. 공간의 미래p.141 동양인과 서양인의 감정 표현 차이에 관한 분석이 신기했고, 결국 ‘공간’의 차이에서부터 초래되었다고 주장되는 흐름이 인상적이었다. 뒤에서 등장한 책의 ‘입이 없는 헬로 키티가 서양 진출에 실패한 이유’, ‘코와 입을 가리는 중동 지역 사람들’, ‘배트맨 등의 서양 히어로 캐릭터들이 입을 가리는 마스크를 쓰지 않고 눈만 가리는 이유’가 모두 이를 뒷받쳐 주는 증거들이었다. 마스크를 쓰고 대면하는 상황에서는 눈으로 감정을 표현하는 동양인들이 유리하다. 허나 눈의 변화보다는 입의 변화가 더 잘 포착되는 온라인 회의에서는 서양인들이 유리하다. 팀원들의 마음을 모으기 위해서는 조직 내 구성원의 의사 결정의 방향을 잡아 줄 ‘철학’이 필요하다. 다른 말로 비전이라고 할 수도 있겠다. 예를 들어서 애플 같은 회사는 누가 보아도 혁신적인 제품을 만들어서 새로운 미래를 창조해 가는 기업이라는 철학이 느껴진다. 그러한 철학이 있기에 수만 명이 되는 직원이 와해되지 않고 하나의 회사로 굴러 가는 것이다. 삼성이나 LG는 제품을 세련되고 효율적으로 만들지만 세상에 없던 혁신적인 제품을 만들어 본 경험은 적다. 효율성만 강조하는 대부분의 기업들은 강한 기업 철학이 없으니 많은 수의 사원을 하나의 마음으로 만들기 위해서 유니폼 같은 동일한 복장을 하고, 회사 로고 배지를 달고, 같은 공간에 같은 시간에 모여서 일하는 방법에 의존할 수밖에 없다. … 옷차림도 거의 비슷한 짙은 색상의 양복이 대부분이었다. 한눈에 보아도 그곳 직원이라는 것을 알 수 있는 드레스 코드였다. 우리나라 대기업은 그러한 통일성으로 거대 조직을 유지시켜 왔다. 통일성은 획일화의 다른 말이다. 이러한 문화 때문에 창조적인 사고가 더 어려워지는 것이다. 공간의 미래p.152 기업 철학의 중요성을 다시 한 번 깨닫는 구절이다. 작가님은 특히나, 재택 근무와 같이 점점 더 개인화되는 사회에서 기업 철학이 없는 기업은 생존이 어려워질 것이라는 경고를 하였다. 잘 나가는 IT 대기업들의 AI 기술자들이 회사의 기술 철학을 보고 OpenAI로 넘어왔다고 했다. 눈앞에 보이는 혜택 보다는 보이지 않는 철학이 더 중요하다는 생각을 하였다. 상대적으로 신흥국이자 후발주자였던 미국의 뉴욕은 선배격인 유럽의 도시들보다 더 높은 밀도를 가진 효율적인 도시 공간 구조를 가질 필요가 있었다. 다행히 후발주자인 뉴욕은 다른 유럽의 도시와는 달리 엘리베이터가 발명된 이후에 성장한 도시다. (생략) 밀도가 4배가 되면 같은 시간에 한 사람이 만날 수 있는 사람의 숫자도 4배로 늘어난다. 이는 도시 경쟁력으로 이어졌다. 미국이 세계를 리드할 수 있었던 배경에는 세계에서 가장 밀도가 높은 뉴욕이라는 도시가 있었기 때문이다. … 백 년 가까이 기술적인 발전이 없다가 1990년대에 들어서 도시의 시냅스를 늘릴 수 있는 획기적 기술이 개발됐다. 바로 인터넷이다. (생략) 인터넷 빅뱅을 통해 만들어 낸 시냅스의 팽창이다. 현대의 도시는 오프라인 공간에서 만나는 시냅스의 총량과 온라인 공간에서 만나는 시냅스의 총량을 합쳐서 이해해야 한다. (생략) 이렇게 인류는 꾸준하게 도시의 규모를 키우고 기술을 발전시키면서 사람들 간 관계의 시냅스를 늘려 나갔는데, 나는 이를 ‘시냅스 총량 증가의 법칙’이라고 부른다. 공간의 미래p.165 미국을 너무나 가고 싶어하는 입장에서, 개인적으로 항상 어떻게 미국이라는 나라가 세계를 리드해는지 궁금해 했었는데 작가님의 ‘밀도’를 이용한 해석이 인상적이었다! 기술은 발전할수록 눈에 보이지 않는 곳으로 사라진다. 땅 위에 있던 전봇대와 전선도 신도시를 만들 때는 전선 등을 땅에 묻어 지중화시키기 때문에 보이지 않는다. (생략) 휴대폰의 키패드도 스마트폰이 되면서 화면 속으로 사라졌다. (생략) 건축은 발전할수록 서비스 기능들이 보이지 않는 곳으로 숨겨진다. 그런데 아직도 우리의 도시에는 도로 위에서 물건을 운송하는 트럭과 사람이 혼재하고 있다. 공간의 미래p.188 읽으면 고개가 끄덕여지는 또 다른 작가님의 해석이었다. 작가님은 이를 통해 ‘자율 주행 전용 지하 물류 터널’을 제안하였다. 향후 상업 공간이 갈 길은 두 갈래로 나뉜다. 지금의 위기를 소규모 다핵 구조로 돌파할 것인가, 아니면 컨트롤된 대형 공간으로 갈 것인가. 공간의 미래p.242 상업 시설의 미래에 대한 작가의 해석이다. 소규모 다핵 구조는 편의점과 같이 오프라인 공간에 작은 상업 시설 여러 개를 두는 방법이고, 컨트롤된 대형 공간은 백화점과 같이 완전히 구분된 공간을 만드는 방법이다. 우리는 악당을 잡으면 세상이 좋아진다고 믿지만 실제로 세상에는 악당과 그 악당을 손가락질하면서 그 상황을 통해서 자신의 권력과 이익을 챙기는 위선자가 있음을 알아야 한다. 악당과 위선자 사이에서 국민은 정신을 차려야 한다. 이기적인 인간이 만드는 사회에서 권력은 쪼개서 나눠 가질수록 정의에 가까워진다. 돈은 권력이다. 따라서 부동산 자산은 권력이다. 부동산이 정부나 대자본가에 집중되기보다는 더 많은 사람이 나누어서 소유할 수 있는 사회가 더 정의로운 사회다. 공간의 미래p.279 내가 뽑은 이 책에서 가장 멋있는 구절이다. 악당과 위선자의 존재, 이들을 견제하기 위한 권력의 분배. 읽고 생각을 해 보면 고개가 끄덕여지고 나름 당연한 말이지만, 표현이 굉장히 마음에 들었다. 나만의 라이프 스타일을 찾을 수 없는 사회다 보니 불행한 사람이 늘어날 수밖에 없다. 사람의 성향은 모두 다른데, 모든 사람이 하나의 라이프 스타일에 끼워 맞춰서 살아야 하기 때문이다. 만약에 우리 사회에서 추구되는 삶의 형식이 10가지가 된다면 행복한 사람이 10배 늘어날 것이다. 100가지가 되면 100배 늘어날 것이다. 추구하는 삶의 다양성을 키워 가는 것이 소득 3만 달러를 넘긴 우리 사회에 필요한 덕목이다. 다양성을 키워 가는 데 가장 쉬운 방법은 주거 형태의 다양성을 키우는 것이다. 사람을 바꾸는 것보다는 물건을 바꾸는 것이 훨씬 더 쉽기 때문이다. 공간의 미래p.299 주거 형태의 다양성과 라이프 스타일에 관한 작가의 의견이다. 내가 아직 주거 형태와 라이프 스타일을 논하기에는 나이가 어리지만, 비슷한 느낌으로 적용해 보자. 책을 읽으면서, 나도 모르게 공간을 까다롭게 입맛대로 정하며 살아왔다는 생각이 들었다. 나는 집에서 공부하는 것을 좋아하지 않는다. 항상 카페를 찾아 나섰는데, 왜 그랬을까? 학창시절에는 ‘집에서 공부가 안된다’는 핑계로 친구들을 만나 함께 공부했다. 나이가 더 든 지금은, 집에서도 공부는 곧잘 한다. 하지만 20대의 나는 다양한 카페를 찾아, 다양한 분위기에서 공부하는 것을 즐긴다. 편안함을 느끼기 위해 단골 카페를 찾아가고, 설렘을 느끼기 위해 새로운 카페를 찾아간다. 공간은 모든 곳에 있었으며, 많은 것을 결정했다. 한창 플래그십 스토어에 꽂혀 지도 어플에 잔뜩 저장해 두었는데, 이제는 공간이 주는 유저 경험을 이해했기 때문에 온전히 즐길 수 있다. 좋은 아이디어를 자문으로 해 주면 두 가지 문제가 생긴다. 첫째, 그 아이디어가 채택됐을 경우, 자문한 사람은 좋은 아이디어를 도둑맞는 것이다. 둘째, 그 아이디어가 채택이 안 됐을 경우, 시간 낭비만 한 셈이 된다. 이런 이야기를 하면 재능 기부 차원에서 사회를 위해서 해 달라고 말하는 사람들이 꼭 있다. 재능 기부는 사회 발전을 위해서 없어져야 한다. 재능은 기부하는 것이 아니라, 재능을 통해서 돈을 벌고 그 돈을 기부해야 하는 거다. 선배들이 재능 기부를 시작하면 이후에 재능 있는 후배들이 재능으로 먹고 살 수가 없어서 그 분야를 떠난다. (생략) 이 선배들은 때로는 받은 돈보다 훨씬 많은 일을 해 주었다. 이를 통해서 더 많은 프로젝트를 수주하고 사회에서 존경받을지는 모르겠지만, 덕분에 후배들은 ‘너보다 유명한 건축가가 저 돈으로 이렇게 훌륭한 봉사를 하는데, 너는 뭔데 설계비가 이렇게 비싸냐?’라는 소리를 듣게 된다. 공간의 미래p.309 자문과 재능 기부에 대한 작가의 부정적인 시각이 담겨 있는 구절이다. 이 글을 보기 전부터 사실 나는 어느 정도 비슷한 생각을 가지고 있었다. 많은 방면으로 열심히 최선을 다하며 살아왔다는 자부심이 있는 나는, 그 노력을 갈취하거나 깎아 내리려는 행동을 그 어떠한 의미에서라도 좋아하지 않는다. 그만큼 상대방의 노력을 무료로 얻어가는 행위는 스스로 받지 않는 편이다. ‘재능을 통해서 돈을 벌고 그 돈을 기부해야 하는 거다’는 문장이 정말 마음에 든다. 후기‘공간’이라는 것에 대해 한 번도 생각해 본 적이 없던 나에게, 그 중요성과 재미를 알려준 책이다. 책도 내가 살아가는 주변의 얘기들을 담은 만큼 쉽고 재밌게 읽었다. 공간 뿐 아니라 위에 적은 구절들처럼 새로운 시각들을 많이 소개받을 수 있었다. ‘나도 이제 독서를 해봐야 하지 않을까’하고 생각하면서 눈에 보이던 진중문고 몇 권을 빼서 읽는 시기에 이 책을 읽게 되었는데, 왜 책을 읽어야 하는지 온몸으로 느끼게 해준 책이었다. 나보다 멋있고 경험도 훨씬 많이 한, ‘거대한 산’같은 사람이 다양한 시각들과 인생 조언을 해주는 느낌을 받았다. 강력 추천하는 책이다.","link":"/2023/01/02/2023-01-02-Book3/"},{"title":"그릿 GRIT","text":"왜 누군가는 중간에 포기하고 어떤 사람은 끝까지 노력해 성공하는가?성공의 정의는 ‘끝까지 해내는 것’이다! 기록한 구절크게 성공한 사람들은 왜 그렇게 끈덕지게 자신의 일에 매달렸을까? 그들 대부분이 사실상 달성이 불가능해 보일 만큼 큰 야망을 품고 있었다. 그들의 눈에는 자신이 늘 부족해 보였다. 그들은 현실에 안주하는 사람들과는 정반대였다. 그럼에도 불만을 가지는 자신에게 정말로 만족을 느꼈다. 그들 각자가 비할 바 없이 흥미롭고 중요한 일을 한다고 생각했고, 목표의 달성만큼 이를 추구하는 과정에서 만족을 느꼈다. 그들이 해야만 하는 일 중에서 일부는 지루하고 좌절감을 안기고 심지어 고통스럽다고 해도 그들은 추호도 포기할 생각을 하지 않았다. 그들의 열정은 오래 지속됐다. 요컨대 분야에 상관없이 대단히 성공한 사람들은 굳건한 결의를 보였고 이는 두 가지 특성으로 나타났다. 첫째, 그들은 대단히 회복력이 강하고 근면했다. 둘째, 자신이 원하는 바가 무엇인지 매우 깊이 이해하고 있었다. 그들은 결단력이 있을 뿐 아니라 나아갈 방향도 알고 있었다. 성공한 사람들이 가진 특별한 점은 열정과 결합된 끈기였다. 한마디로 그들에게는 그릿(grit)이 있었다. 그릿 GRITp.29 책의 제목인 그릿(grit)에 대한 설명과, 책에서 다루고자 하는 주제를 깔끔하게 설명한 구절이다. 이 부분을 읽고 개인적으로 ‘이 책을 끝까지 읽어보고 싶다’는 생각이 강렬하게 들었다. 억지로 끼워맞추지 않더라도 문단의 설명들이 나와 너무나 일치했기 때문이다. 허나 이를 누군가에게 설명해 본 적도, 직접 생각해 본 적도 없었다. 아는 만큼 보인다는 말도 있지 않은가. 책을 읽어 이 그릿이라는 것의 실체를 깨우치고, 깨닫고 지혜롭게 사용하고 싶어졌다. 이대로만 열심히 그릿을 가지고 살면 나도 성공할 수 있는 건가? 하는 다소 뻔뻔한 생각을 해보기도 하였다. 책의 1부에서는 그릿이 무엇인지, 2부에서는 내 안의 그릿을 기르는 법, 3부에서는 아이들의 그릿을 키우는 법을 다루었다. 나름의 그릿을 가지고 있다고 생각한 본인에게 1부는 스스로의 그릿을 깨닫고 정리한다는 목적성을 지니고 읽었다. 2부는 그릿을 지혜롭게 가꾸고 성장시키는 방향성에 초점을 맞추고 읽었다. 3부는 아직 먼 얘기로 느껴져, 마음이 가지 않아 솔직히 열심히 읽지 않았다. 내가 볼 때 재능에만 집착하는 자세가 해로울 수 있는 가장 큰 이유는 간단하다. 재능만 집중 조명함으로써 나머지 모두를 가릴 위험이 있기 때문이다. 우리가 그릿을 비롯한 다른 요인들이 실제보다 중요하지 않다는 메시지를 은연중에 보낼 수도 있다. 그릿 GRITp.57 소주제가 “우리가 재능 신화를 버려야 하는 이유” 이다. 많은 사람들은 재능에 열광한다. 티비 프로그램 중에서도 영재와 관련된 수많은 프로그램들이 함께 해 왔다. 개인적으로는 어렸을 때부터 소위 ‘영재반’으로 불리는 다양한 집단과의 접점이 많았는데, 나에게 참 많은 시련을 남겼다. 많은 영재반에서 떨어지고 난 후, 으뜸가는 영재반에 다니는 친구들을 ‘우러러’ 보게 되었으며 자연스럽게 나는 재능이 많지 않음을 믿게 되었다. 어쩌면 나의 이러한 배경이 지금의 끈기 있고 열정적인 나를 만들었을 수도 있다. 현재 나는 당시 내가 우러러보던 많은 친구들과 동등한 위치에 놓였거나 넘어섰다고 당당히 말할 수 있다. (나와 타인을 비교할 순 없다고 생각하고 각자가 삶을 바라보는 가치관이 다르기에 더욱 의미가 없다고 생각하지만, 문맥상 글로 표현하기 위한 문장이다. 굳이 따지자면 ‘더 잘 적응해서 행복하게 학창시절을 보냈다’ 정도로 해석해달라.) 만약 다른 친구들의 재능이 너무 조명받아 일찌감치 포기했다면? 혹은, 만약 내가 재능 있다고 조명받아 우쭐해진 나머지 열심히 노력하지 않았다면? 지금의 나는 만나볼 수 없었을 것이다. 작가의 조금 더 전문적인 해석은 아래와 같았다. “아무도 예술가의 작품 속에서 그것이 완성되기까지의 과정을 보지 못한다.” 니체는 말했다. “그 편이 나은 점도 있다. 작품으로 완성되는 과정을 보게 되는 경우에는 언제나 반응이 다소 시들해지기 때문이다.” 다시 말해서 우리는 마크 스피츠가 남들은 선천적 혹은 후천적으로도 갖지 못한 수영에 대한 재능을 갖고 태어났다고 믿고 싶어 한다. (생략) 우리는 ‘완성된 탁월한 기량’을 보는 것을 더 좋아한다. 일상성보다는 신비함을 좋아한다. 하지만 무엇 때문인가? 마크 스피츠가 우수한 기량을 노력으로 얻은 것이 아니라고 우리 스스로를 기만하는 이유는 무엇인가? “우리의 허영심과 자기애가 천재 숭배를 조장한다.” 니체가 말했다. “왜냐하면 천재를 마법적인 존재로 생각한다면 우리 자신과 비교하고 우리의 부족함을 느끼지 않아도 되기 때문이다…… 누군가를 ‘신적인 존재’로 부르면 ‘우리는 그와 경쟁할 필요가 없어진다.’” 그릿 GRITp.68 왜 ‘마흔에 읽는 니체’가 현재 베스트셀러인지 간접적으로 느꼈다. 책의 많은 곳곳에 니체가 등장하는데, 구구절절 맞는 말들이었다. 나도 곧 읽어봐야지. 사실 하위 목표를 포기하는 행동은 용인할 수 있을 뿐 아니라 때로는 꼭 필요하다. 원래 설정했던 하위 목표는 이를 대체할 수 있고 실현 가능성이 더 높은 목표가 나타나면 포기해야만 한다. 경로 변경이 필요한 또 하나의 경우는 다른 하위 목표, 즉 같은 목적을 달성할 수 있는 다른 수단이 더 효율적이거나 재미있다는 등의 이유로 원래 계획에 더 타당할 때다. … 하지만 상위 수준의 목표일수록 이를 고수하는 것이 옳다. (생략) 반면에 중간 목표는 쉽게 포기하지 않으며, 솔직히 나의 궁극적 목적, 피트 캐럴의 용어로는 내 인생철학을 바꾸는 일은 어떤 이유로든 포기한다는 것은 상상할 수 없다. 그릿 GRITp.109 하지만 목표가 상위 수준의 것일수록 그들은 더욱 고집스럽게 끝을 보려 한다. 가장 중요한 점은 그릿의 전형들은 나침반을 바꾸지 않는다는 것이다. … 두 종류의 연구를 종합했을 때 성숙한 그릿의 전형들이 공통적으로 갖고 있는 네 가지 심리적 자산이 드러났다. (생략) 첫째는 관심이다. 열정은 당신이 하는 일을 진정으로 즐기는 데서 시작된다. (생략) 둘째는 연습이다. 이는 어제보다 잘하려고 매일 단련하는 종류의 끈기를 말한다. 그러니까 특정 영역에 관심을 느끼고 발전시킨 다음에는 온 마음을 다해 집중하고 난관을 극복하며 기술을 연습하고 숙달시켜야 한다. (생략) 셋째는 목적이다. 자신의 일이 중요하다는 확신이 열정을 무르익게 한다. 목적이 없는 관심을 평생 유지하기란 대부분의 사람들에게 거의 불가능한 일이다. (생략) 마지막 넷째는 희망이다. 희망은 위기에 대처하게 해주는 끈기를 말한다. 그릿 GRITp.129 작가가 성숙한 그릿의 전형들의 공통적인 네 가지 심리적인 자산을 정리해 주었다. 위에서 말했듯 어느 정도의 그릿을 갖췄다고 생각한 나는 내 스스로를 돌아본다는 관점에서 책을 읽어 나갔는데, 개인적으로는 ‘목적’이 가장 나와 접점이 적다고 느꼈다. 내가 열심히 사는 목적이 무엇인가? 이 부분이 부족해서 군대에서 많이 헤매기도 하였다. 지금까지는 선택지가 단순했다. 좋은 고등학교 … 좋은 대학교 … 허나 성인 이후로는 선택의 폭이 기하급수적으로 불었다. 특히 공대생인 본인에게는 열심히 살수록 그에 맞추어 달콤한 선택지들이 엄청나게 생겨나 유혹을 하였고, 뚜렷한 목표의식이 없었던 나는 그 안에서 많이 헤맸다. 최근에 우연히 신기한 경험을 하였다. 태한이가 나에게 ‘퀀트(quant)’라는 직업을 추천해 주었다. 머신러닝이 경제 시장에도 스며들어, 골드만삭스와 같은 회사에서 경제 경영 지식과 전혀 관련없이 오로지 똑똑한 사람들만을 뽑는다고 한다. 취업에 IMO 실적이 반영된다는 것이 그 방증이다. 수많은 똑똑한 사람들 사이에서 찢기는 성장을 하며, 그 대가로 고액의 연봉(학사를 갓 졸업한 지인이 연봉 5~6억을 받았다고 한다)을 받으니 어떠냐는 제안이다. 굉장히 흥미로웠다. 당시 나에게 중요했던 두 가치가 ‘성장’과 ‘돈’이었기 때문에, 둘을 동시에 충족하는 훌륭한 선택지다. 허나 곰곰이 생각할수록 마음이 가지 않았다. 처음 겪어보는 일이었다. 지금까지는 머리가 가리키는 선택지와 마음이 가리키는 선택지가 일치하였다. 이번은 아니었다. 머리에서는 훌륭한 선택지로 인식되었으나, 마음이 가지 않았다. 왜였을까? 자소서나 면접 때 입버릇처럼 “세상을 바꾸는 공학도가 되고 싶다”고 한 말이 정말 마음 한 켠에 진심으로 자리잡고 있었던 것이다. 나에게 그 무엇으로도 바꿀 수 없는 인생철학이자, 상위 수준의 목표는 이것이었다. 아무리 달콤한 제안이어도 타협이 되지 않고 포기할 수 없는. 이 바뀌지 않는 나침반이 앞으로 나의 선택을 도와주길 바란다. 첫째, 아동기에는 너무 어리기 때문에 커서 무엇이 되고 싶은지 알지 못한다. (생략) 둘째, 관심사는 자기 성찰을 통해 발견되지 않는다. 오히려 외부 세계와의 상호작용이 계기가 되어 흥미가 생긴다. 관심사의 발견 과정은 혼란과 우연성이 존재하는 비능률적인 과정일 수 있다. 당신의 관심을 사로잡을 일과 그러지 못할 일을 확실히 예측할 수가 없기 때문이다. 또한 의지로 자신이 무엇을 좋아하게 만들 수도 없다. (생략) 셋째, 관심사를 발견한 뒤 오랜 시간 주도적으로 관심을 발전시켜야 한다. (생략) 마지막으로 관심은 부모, 교사, 코치, 또래 등 여러 지지자들의 격려가 있을 때 점점 깊어진다. 그릿 GRITpg.146 ‘관심사는 어떻게 발견하나요?’ 에 대한 작가의 대답을 가져왔다. 본인들의 경험을 대입해 보면, 읽으면서 고개가 끄덕여진다. 나는 은근히 두 번째를 극복하려고 억지를 부렸던 거 같다. 예를 들어 독서하는 사람이 멋있어 보여서, 막연히 독서를 좋아한다고 스스로를 세뇌시키며 독서를 시작한 경험이 있었다. 그러나 이는 일시적인 독서하는 컨셉에 불과할 뿐이었고, 결국 오래 가지 못했다. 최근의 나는 독서의 흥미와 중요성을 진실된 마음으로 깨닫고, 이제는 하나의 취미이자 습관으로 자리잡게 되었다. 어떻게 하면 의식적인 연습에서 최대의 결과를 얻어내고, 힘들게 연습한 사람만이 누릴 자격이 있는 몰입 상태를 더 경험할 수 있는가? 첫째, 과학적 원리를 이해한다. 명료하게 진술된 도전적 목표 완벽한 집중과 노력 즉각적이고 유용한 피드백 반성과 개선을 통한 반복 … 따라서 의식적인 연습을 최대한 활용하기 위한 두 번째 비결로 연습을 습관화하라는 제안을 하려고 한다. 우선 가장 편안하게 의식적인 연습을 할 수 있는 시간과 장소를 파악한다. 그런 다음에는 매일 그 시간, 그 장소에서 연습해야 한다. 어려운 일을 할 때는 일과로 만드는 것이 뜻밖의 비법이 될 수 있기 때문이다. … 세 번째 비결은 바로 연습을 경험하는 방식을 바꾸라는 것이다. (생략) 두 학자들에 의하면 아이들은 유치원에 입학할 무렵부터 자신의 실수에 어른들이 특정 반응을 보인다는 사실을 눈치채기 시작한다. … 의식적인 연습을 황홀한 몰입처럼 만들 수 있는지에 대한 답은 아직 잘 모른다. 그러나 스스로에게 그리고 타인에게 “힘들었어요! 그래도 좋았어요!” 라고 말할 만큼 노력할 수는 있다고 생각한다. 그릿 GRITpg.188 ~ 194 의식적인 연습과 몰입의 두 개념에 대한 정리이다. 전문가들은 다른 사람들과 차별적인 의식적인 연습을 꾸준히 하였다. 똑같은 시간을 쓸 때도, 그들은 더욱 효율적이고 능동적이게, 자기 자신을 극한으로 몰아넣어 연습하였다. 이와 함께 언급되는 몰입은 고난도의 과제를 수행하고 있지만 ‘생각할 필요도 없이 수월하게 그냥 실행되는 듯한’ 느낌이다. 책의 설명도 복잡하듯 뭔가 쉽게 풀어 말하기엔 어려운데, 각자 한 번쯤은 경험했을 것이다. 의식적인 연습을 하되, 몰입에 너무 집착하지는 않으면서 즐기자. 그릿의 전형들과 대화하는 동안 그들은 모두 자신이 추구하는 일에 목적이 있다고 말했다. 그것은 단순한 의도보다 훨씬 깊이 있는 무언가를 의미했다. 그릿의 전형들은 단순히 목표 지향적이라기보다 그 목표가 특별한 성격을 띠고 있다. 내가 “좀 더 애기해주시겠어요? 그게 무슨 뜻이죠?”라고 캐물으면 그들은 자신의 느낌을 정확히 표현할 말을 찾느라 더듬거리면서 진심 어린 답변을 들려주고는 했다. 그런데 그 답변에는 언제나 타인이 언급됐다. (생략) 목적 개념의 핵심은 우리가 하는 일이 자신 외의 사람들에게도 중요하다는 생각이다. 그릿 GRITpg.197 위에서 언급했던 최근에 깨달은 인생철학과 관련이 있는 파트다. 공학도로서 통 크게 ‘인류 수준의 목적’을 가져보자. 내가 제시한 증거들은 대체로 다음과 같이 정리된다. 능력에 대한 고정형 사고방식은 역경의 순간 비관적 해석을 낳고, 이는 아예 도전 상황을 회피하거나 포기하는 행동으로 이어진다. 그와 반대로 성장형 사고방식은 역경에 대한 낙관적 해석을 낳고, 이는 다시 끈기 있게 새로운 도전을 추구하는 행동으로 이어져 결국 더 강한 사람으로 만들어준다. 그릿 GRITpg.255 우리는 성장형 사고방식을 가진 강한 사람이 되어야 한다. 책에서 언급한 ‘나약한 우등생(fragile perfect: 넘어졌다가 다시 일어서는 경험을 거의 하지 못해, 성공하는 법만 알고 실패할 줄 모르는 사람)’이 되지 말자. 태한이가 기업 최종 면접에서 “실패한 경험”에 대한 질문이 들어왔을 때 대답하지 못해 면접을 망쳤다는 지인의 이야기를 해준 적 있다. 실패를 두려워하지 않으며, 더 나아가 실패할 줄 아는 사람이 되어야 한다. (관련된 자세한 내용은 블로그의 이 글의 마지막을 참고해라.) 후기까놓고 말하자면, 나는 자기계발서를 별로 좋아하지 않는다. 허나 이 책은 표지를 보고 ‘어쩌면 나를 잘 표현할 수 있는 하나의 용어를 얻어갈 수 있겠다’는 생각이 들어 책을 집어들었다. 실제로 엄청난 지식이나 팁을 배웠다기보단 나의 모습들에 대한 분석적인 결과와, 내가 가는 길의 방향과 방법에 대한 확신, 그리고 용기를 얻었다. 400쪽 가까이 ‘그릿’이라는 한 주제와 함께할 수 있었다. 책의 구절을 인용하며 마무리하겠다. 그릿이란 한 번에 한 걸음씩 계속 나아가는 것이다. 흥미롭고 목적이 뚜렷한 목표를 굳건히 지키는 것이다. 매일, 몇 주씩, 몇 해씩 도전적으로 연습하는 것이다. 일곱 번 넘어지면 여덟 번 일어나는 것이다. 그릿 GRITpg.359","link":"/2023/02/06/2023-02-06-Book4/"}],"tags":[{"name":"sorting","slug":"sorting","link":"/tags/sorting/"},{"name":"manual","slug":"manual","link":"/tags/manual/"},{"name":"backtracking","slug":"backtracking","link":"/tags/backtracking/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"dfs&amp;bfs","slug":"dfs-bfs","link":"/tags/dfs-bfs/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"greedy","slug":"greedy","link":"/tags/greedy/"},{"name":"stack","slug":"stack","link":"/tags/stack/"},{"name":"queue","slug":"queue","link":"/tags/queue/"},{"name":"deque","slug":"deque","link":"/tags/deque/"},{"name":"divide&amp;conquer","slug":"divide-conquer","link":"/tags/divide-conquer/"},{"name":"binary_search","slug":"binary-search","link":"/tags/binary-search/"},{"name":"ssp","slug":"ssp","link":"/tags/ssp/"},{"name":"asp","slug":"asp","link":"/tags/asp/"},{"name":"server","slug":"server","link":"/tags/server/"},{"name":"SEO","slug":"SEO","link":"/tags/SEO/"},{"name":"CP","slug":"CP","link":"/tags/CP/"},{"name":"Div2","slug":"Div2","link":"/tags/Div2/"},{"name":"Desilo","slug":"Desilo","link":"/tags/Desilo/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"CS231n","slug":"CS231n","link":"/tags/CS231n/"},{"name":"ML&#x2F;AI","slug":"ML-AI","link":"/tags/ML-AI/"},{"name":"Book","slug":"Book","link":"/tags/Book/"},{"name":"English","slug":"English","link":"/tags/English/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Baekjoon","slug":"Algorithm/Baekjoon","link":"/categories/Algorithm/Baekjoon/"},{"name":"Theory","slug":"Algorithm/Theory","link":"/categories/Algorithm/Theory/"},{"name":"Manual","slug":"Manual","link":"/categories/Manual/"},{"name":"Study","slug":"Study","link":"/categories/Study/"},{"name":"Others","slug":"Study/Others","link":"/categories/Study/Others/"},{"name":"ON SOPT Server Seminar","slug":"Study/ON-SOPT-Server-Seminar","link":"/categories/Study/ON-SOPT-Server-Seminar/"},{"name":"APSS &#x2F; CodeForces","slug":"Algorithm/APSS-CodeForces","link":"/categories/Algorithm/APSS-CodeForces/"},{"name":"Memories","slug":"Memories","link":"/categories/Memories/"},{"name":"CS231n","slug":"Study/CS231n","link":"/categories/Study/CS231n/"},{"name":"Book","slug":"Book","link":"/categories/Book/"},{"name":"Finance &amp; Economics","slug":"Book/Finance-Economics","link":"/categories/Book/Finance-Economics/"},{"name":"Humanities","slug":"Book/Humanities","link":"/categories/Book/Humanities/"},{"name":"Classics","slug":"Book/Classics","link":"/categories/Book/Classics/"},{"name":"Self-Help","slug":"Book/Self-Help","link":"/categories/Book/Self-Help/"}]}